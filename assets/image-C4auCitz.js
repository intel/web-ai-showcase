function lr(t,e){t&&t(e)}function Um(t){return Object.fromEntries(Object.entries(t).map(([e,n])=>[n,e]))}function kd(t){return t.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}const qt=class{constructor(){let t=function(...e){return t._call(...e)};return Object.setPrototypeOf(t,new.target.prototype)}_call(...t){throw Error("Must implement _call method in subclass")}};function Wm(t){return t?.prototype?.__proto__?.constructor?.name==="TypedArray"}function Td(t){return Number.isInteger(t)||typeof t=="bigint"}function Vm(t){return t!=null}function Y$(t){const e=[];let n=t;for(;Array.isArray(n);)e.push(n.length),n=n[0];return e}function X$(t,e,n=void 0){const r=t[e];if(r!==void 0)return delete t[e],r;if(n===void 0)throw Error(`Key ${e} does not exist in object.`);return n}function st(...t){return Array.prototype.concat.apply([],t)}function Q$(...t){return t.reduce((e,n)=>e.flatMap(r=>n.map(a=>[r,a])))}function Z$(t,e){return Math.abs((t+e)%(2*e)-e)}const Ke={},Gm=Object.freeze(Object.defineProperty({__proto__:null,default:Ke},Symbol.toStringTag,{value:"Module"})),Hm="3.0.0-alpha.0",Cd=typeof self<"u",qm=Cd&&"caches"in self,Ui=!Id(Ke),jm=!Id(Ke),ss=Ui&&jm,os=ss?Ke.dirname(Ke.dirname(Ke.fileURLToPath(import.meta.url))):"./",Km=ss?Ke.join(os,"/.cache/"):null,ho="/models/",Ym=ss?Ke.join(os,ho):ho,ot={backends:{onnx:{},tfjs:{}},__dirname:os,version:Hm,allowRemoteModels:!0,remoteHost:"https://huggingface.co/",remotePathTemplate:"{model}/resolve/{revision}/",allowLocalModels:!Cd,localModelPath:Ym,useFS:Ui,useBrowserCache:qm,useFSCache:Ui,cacheDir:Km,useCustomCache:!1,customCache:null};function Id(t){return Object.keys(t).length===0}var li={};class Ua{_CONTENT_TYPE_MAP={txt:"text/plain",html:"text/html",css:"text/css",js:"text/javascript",json:"application/json",png:"image/png",jpg:"image/jpeg",jpeg:"image/jpeg",gif:"image/gif"};constructor(e){if(this.filePath=e,this.headers=new Headers,this.exists=Ke.existsSync(e),this.exists){this.status=200,this.statusText="OK";let n=Ke.statSync(e);this.headers.set("content-length",n.size.toString()),this.updateContentType();let r=this;this.body=new ReadableStream({start(a){r.arrayBuffer().then(i=>{a.enqueue(new Uint8Array(i)),a.close()})}})}else this.status=404,this.statusText="Not Found",this.body=null}updateContentType(){const e=this.filePath.toString().split(".").pop().toLowerCase();this.headers.set("content-type",this._CONTENT_TYPE_MAP[e]??"application/octet-stream")}clone(){let e=new Ua(this.filePath);return e.exists=this.exists,e.status=this.status,e.statusText=this.statusText,e.headers=new Headers(this.headers),e}async arrayBuffer(){return(await Ke.promises.readFile(this.filePath)).buffer}async blob(){const e=await Ke.promises.readFile(this.filePath);return new Blob([e],{type:this.headers.get("content-type")})}async text(){return await Ke.promises.readFile(this.filePath,"utf8")}async json(){return JSON.parse(await this.text())}}function Wi(t,e=null){let n;try{n=new URL(t)}catch{return!1}return e&&!e.includes(n.hostname)?!1:n.protocol==="http:"||n.protocol==="https:"}async function Vi(t){if(ot.useFS&&!Wi(t))return new Ua(t);if(typeof process<"u"&&process?.release?.name==="node"){const e=!!li?.TESTING_REMOTELY,n=ot.version,r=new Headers;if(r.set("User-Agent",`transformers.js/${n}; is_ci/${e};`),Wi(t,["huggingface.co","hf.co"])){const i=li?.HF_TOKEN??li?.HF_ACCESS_TOKEN;i&&r.set("Authorization",`Bearer ${i}`)}return fetch(t,{headers:r})}else return fetch(t)}const Xm={400:"Bad request error occurred while trying to load file",401:"Unauthorized access to file",403:"Forbidden access to file",404:"Could not locate file",408:"Request timeout error occurred while trying to load file",500:"Internal server error error occurred while trying to load file",502:"Bad gateway error occurred while trying to load file",503:"Service unavailable error occurred while trying to load file",504:"Gateway timeout error occurred while trying to load file"};function Qm(t,e,n){if(!n)return null;const r=Xm[t]??`Error (${t}) occurred while trying to load file`;throw Error(`${r}: "${e}".`)}class fo{constructor(e){this.path=e}async match(e){let n=Ke.join(this.path,e),r=new Ua(n);if(r.exists)return r}async put(e,n){const r=Buffer.from(await n.arrayBuffer());let a=Ke.join(this.path,e);try{await Ke.promises.mkdir(Ke.dirname(a),{recursive:!0}),await Ke.promises.writeFile(a,r)}catch(i){console.warn("An error occurred while writing the file to cache:",i)}}}async function Zm(t,...e){for(let n of e)try{let r=await t.match(n);if(r)return r}catch{continue}}async function Gi(t,e,n=!0,r={}){if(!ot.allowLocalModels){if(r.local_files_only)throw Error("Invalid configuration detected: local models are disabled (`env.allowLocalModels=false`) but you have requested to only use local models (`local_files_only=true`).");if(!ot.allowRemoteModels)throw Error("Invalid configuration detected: both local and remote models are disabled. Fix by setting `env.allowLocalModels` or `env.allowRemoteModels` to `true`.")}lr(r.progress_callback,{status:"initiate",name:t,file:e});let a;if(!a&&ot.useBrowserCache){if(typeof caches>"u")throw Error("Browser cache is not available in this environment.");try{a=await caches.open("transformers-cache")}catch(b){console.warn("An error occurred while opening the browser cache:",b)}}if(!a&&ot.useFSCache&&(a=new fo(r.cache_dir??ot.cacheDir)),!a&&ot.useCustomCache)throw Error("`env.useCustomCache=true`, but `env.customCache` is not defined.");const i=r.revision??"main";let s=ca(t,e),o=ca(ot.localModelPath,s),l=ca(ot.remoteHost,ot.remotePathTemplate.replaceAll("{model}",t).replaceAll("{revision}",encodeURIComponent(i)))+"&FilePath="+e,d=i==="main"?s:ca(t,i,e),p,u=a instanceof fo?d:l,f=!1,m;a&&(m=await Zm(a,o,u));const _=m!==void 0;if(m===void 0){if(ot.allowLocalModels)if(Wi(s)){if(r.local_files_only)throw new Error(`\`local_files_only=true\`, but attempted to load a remote file from: ${s}.`);if(!ot.allowRemoteModels)throw new Error(`\`env.allowRemoteModels=false\`, but attempted to load a remote file from: ${s}.`)}else try{m=await Vi(o),p=o}catch(S){console.warn(`Unable to load from local path "${o}": "${S}"`)}if(m===void 0||m.status===404){if(r.local_files_only||!ot.allowRemoteModels){if(n)throw Error(`\`local_files_only=true\` or \`env.allowRemoteModels=false\` and file was not found locally at "${o}".`);return null}if(m=await Vi(l),m.status!==200)return Qm(m.status,l,n);p=u}f=a&&typeof Response<"u"&&m instanceof Response&&m.status===200}lr(r.progress_callback,{status:"download",name:t,file:e});const v={status:"progress",name:t,file:e};let $;return r.progress_callback?_&&typeof navigator<"u"&&/firefox/i.test(navigator.userAgent)?($=new Uint8Array(await m.arrayBuffer()),lr(r.progress_callback,{...v,progress:100,loaded:$.length,total:$.length})):$=await Jm(m,b=>{lr(r.progress_callback,{...v,...b})}):$=new Uint8Array(await m.arrayBuffer()),f&&p&&await a.match(p)===void 0&&await a.put(p,new Response($,{headers:m.headers})).catch(b=>{console.warn(`Unable to add response to browser cache: ${b}.`)}),lr(r.progress_callback,{status:"done",name:t,file:e}),$}async function Er(t,e,n=!0,r={}){let a=await Gi(t,e,n,r);if(a===null)return{};let s=new TextDecoder("utf-8").decode(a);return JSON.parse(s)}async function Jm(t,e){const n=t.headers.get("Content-Length");n===null&&console.warn("Unable to determine content-length from response headers. Will expand buffer when needed.");let r=parseInt(n??"0"),a=new Uint8Array(r),i=0;const s=t.body.getReader();async function o(){const{done:l,value:d}=await s.read();if(l)return;let p=i+d.length;if(p>r){r=p;let f=new Uint8Array(r);f.set(a),a=f}a.set(d,i),i=p;const u=i/r*100;return e({progress:u,loaded:i,total:r}),o()}return await o(),a}function ca(...t){return t=t.map((e,n)=>(n&&(e=e.replace(new RegExp("^/"),"")),n!==t.length-1&&(e=e.replace(new RegExp("/$"),"")),e)),t.join("/")}function eg(t,[e,n,r],[a,i],s="bilinear",o=!1){const l=i/r,d=a/n,p=new t.constructor(a*i*e),u=n*r,f=a*i;for(let m=0;m<a;++m)for(let _=0;_<i;++_){const v=m*i+_,$=(_+.5)/l-.5,b=(m+.5)/d-.5;let S=Math.floor($),T=Math.floor(b);const E=Math.min(S+1,r-1),I=Math.min(T+1,n-1);S=Math.max(S,0),T=Math.max(T,0);const M=$-S,F=b-T,L=(1-M)*(1-F),W=M*(1-F),X=(1-M)*F,A=M*F,q=T*r,te=I*r,K=q+S,B=q+E,U=te+S,G=te+E;for(let ne=0;ne<e;++ne){const oe=ne*u;p[ne*f+v]=L*t[oe+K]+W*t[oe+B]+X*t[oe+U]+A*t[oe+G]}}return p}function tg(t,e,n){const r=new Array(n.length),a=new Array(n.length);for(let o=n.length-1,l=1;o>=0;--o)a[o]=l,r[o]=e[n[o]],l*=r[o];const i=n.map((o,l)=>a[n.indexOf(l)]),s=new t.constructor(t.length);for(let o=0;o<t.length;++o){let l=0;for(let d=e.length-1,p=o;d>=0;--d)l+=p%e[d]*i[d],p=Math.floor(p/e[d]);s[l]=t[o]}return[s,r]}function ls(t){const e=Wa(t)[0],n=t.map(i=>Math.exp(i-e)),r=n.reduce((i,s)=>i+s,0);return n.map(i=>i/r)}function ng(t){return ls(t).map(r=>Math.log(r))}function Ad(t,e=0){return t=Array.from(t).map((n,r)=>[r,n]).sort((n,r)=>r[1]-n[1]),e!==null&&e>0&&(t=t.slice(0,e)),t}function rg(t){if(t.length===0)throw Error("Array must not be empty");let e=t[0],n=0;for(let r=1;r<t.length;++r)t[r]<e&&(e=t[r],n=r);return[e,n]}function Wa(t){if(t.length===0)throw Error("Array must not be empty");let e=t[0],n=0;for(let r=1;r<t.length;++r)t[r]>e&&(e=t[r],n=r);return[Number(e),n]}function Md(t){return t>0&&(t&t-1)===0}class Od{constructor(e){if(this.size=e|0,this.size<=1||!Md(this.size))throw new Error("FFT size must be a power of two larger than 1");this._csize=e<<1,this.table=new Float64Array(this.size*2);for(let r=0;r<this.table.length;r+=2){const a=Math.PI*r/this.size;this.table[r]=Math.cos(a),this.table[r+1]=-Math.sin(a)}let n=0;for(let r=1;this.size>r;r<<=1)++n;this._width=n%2===0?n-1:n,this._bitrev=new Int32Array(1<<this._width);for(let r=0;r<this._bitrev.length;++r){this._bitrev[r]=0;for(let a=0;a<this._width;a+=2){const i=this._width-a-2;this._bitrev[r]|=(r>>>a&3)<<i}}}createComplexArray(){return new Float64Array(this._csize)}fromComplexArray(e,n){const r=n||new Array(e.length>>>1);for(let a=0;a<e.length;a+=2)r[a>>>1]=e[a];return r}toComplexArray(e,n){const r=n||this.createComplexArray();for(let a=0;a<r.length;a+=2)r[a]=e[a>>>1],r[a+1]=0;return r}completeSpectrum(e){const n=this._csize,r=n>>>1;for(let a=2;a<r;a+=2)e[n-a]=e[a],e[n-a+1]=-e[a+1]}transform(e,n){if(e===n)throw new Error("Input and output buffers must be different");this._transform4(e,n,1)}realTransform(e,n){if(e===n)throw new Error("Input and output buffers must be different");this._realTransform4(e,n,1)}inverseTransform(e,n){if(e===n)throw new Error("Input and output buffers must be different");this._transform4(e,n,-1);for(let r=0;r<e.length;++r)e[r]/=this.size}_transform4(e,n,r){const a=this._csize;let s=1<<this._width,o=a/s<<1,l,d;const p=this._bitrev;if(o===4)for(l=0,d=0;l<a;l+=o,++d){const u=p[d];this._singleTransform2(n,e,l,u,s)}else for(l=0,d=0;l<a;l+=o,++d){const u=p[d];this._singleTransform4(n,e,l,u,s,r)}for(s>>=2;s>=2;s>>=2){o=a/s<<1;const u=o>>>2;for(l=0;l<a;l+=o){const f=l+u-1;for(let m=l,_=0;m<f;m+=2,_+=s){const v=m,$=v+u,b=$+u,S=b+u,T=e[v],E=e[v+1],I=e[$],M=e[$+1],F=e[b],L=e[b+1],W=e[S],X=e[S+1],A=this.table[_],q=r*this.table[_+1],te=I*A-M*q,K=I*q+M*A,B=this.table[2*_],U=r*this.table[2*_+1],G=F*B-L*U,ne=F*U+L*B,oe=this.table[3*_],ye=r*this.table[3*_+1],V=W*oe-X*ye,ie=W*ye+X*oe,$e=T+G,Le=E+ne,Pe=T-G,We=E-ne,ht=te+V,Fe=K+ie,Ve=r*(te-V),tt=r*(K-ie);e[v]=$e+ht,e[v+1]=Le+Fe,e[$]=Pe+tt,e[$+1]=We-Ve,e[b]=$e-ht,e[b+1]=Le-Fe,e[S]=Pe-tt,e[S+1]=We+Ve}}}}_singleTransform2(e,n,r,a,i){const s=e[a],o=e[a+1],l=e[a+i],d=e[a+i+1];n[r]=s+l,n[r+1]=o+d,n[r+2]=s-l,n[r+3]=o-d}_singleTransform4(e,n,r,a,i,s){const o=i*2,l=i*3,d=e[a],p=e[a+1],u=e[a+i],f=e[a+i+1],m=e[a+o],_=e[a+o+1],v=e[a+l],$=e[a+l+1],b=d+m,S=p+_,T=d-m,E=p-_,I=u+v,M=f+$,F=s*(u-v),L=s*(f-$);n[r]=b+I,n[r+1]=S+M,n[r+2]=T+L,n[r+3]=E-F,n[r+4]=b-I,n[r+5]=S-M,n[r+6]=T-L,n[r+7]=E+F}_realTransform4(e,n,r){const a=this._csize;let s=1<<this._width,o=a/s<<1,l,d;const p=this._bitrev;if(o===4)for(l=0,d=0;l<a;l+=o,++d){const u=p[d];this._singleRealTransform2(n,e,l,u>>>1,s>>>1)}else for(l=0,d=0;l<a;l+=o,++d){const u=p[d];this._singleRealTransform4(n,e,l,u>>>1,s>>>1,r)}for(s>>=2;s>=2;s>>=2){o=a/s<<1;const u=o>>>2;for(l=0;l<a;l+=o){const f=l+u-1;for(let m=l,_=0;m<f;m+=2,_+=s){const v=m,$=v+u,b=$+u,S=b+u,T=e[v],E=e[v+1],I=e[$],M=e[$+1],F=e[b],L=e[b+1],W=e[S],X=e[S+1],A=this.table[_],q=r*this.table[_+1],te=I*A-M*q,K=I*q+M*A,B=this.table[2*_],U=r*this.table[2*_+1],G=F*B-L*U,ne=F*U+L*B,oe=this.table[3*_],ye=r*this.table[3*_+1],V=W*oe-X*ye,ie=W*ye+X*oe,$e=T+G,Le=E+ne,Pe=T-G,We=E-ne,ht=te+V,Fe=K+ie,Ve=r*(te-V),tt=r*(K-ie);e[v]=$e+ht,e[v+1]=Le+Fe,e[$]=Pe+tt,e[$+1]=We-Ve,e[b]=$e-ht,e[b+1]=Le-Fe,e[S]=Pe-tt,e[S+1]=We+Ve}}}}_singleRealTransform2(e,n,r,a,i){const s=e[a],o=e[a+i];n[r]=s+o,n[r+1]=0,n[r+2]=s-o,n[r+3]=0}_singleRealTransform4(e,n,r,a,i,s){const o=i*2,l=i*3,d=e[a],p=e[a+i],u=e[a+o],f=e[a+l],m=d+u,_=d-u,v=p+f,$=s*(p-f);n[r]=m+v,n[r+1]=0,n[r+2]=_,n[r+3]=-$,n[r+4]=m-v,n[r+5]=0,n[r+6]=_,n[r+7]=$}}class ag{constructor(e){const n=2*(e-1),r=2*(2*e-1),a=2**Math.ceil(Math.log2(r));this.bufferSize=a,this._a=n;const i=new Float64Array(r),s=new Float64Array(a);this._chirpBuffer=new Float64Array(a),this._buffer1=new Float64Array(a),this._buffer2=new Float64Array(a),this._outBuffer1=new Float64Array(a),this._outBuffer2=new Float64Array(a);const o=-2*Math.PI/e,l=Math.cos(o),d=Math.sin(o);for(let p=0;p<r>>1;++p){const u=(p+1-e)**2/2,f=Math.sqrt(l**2+d**2)**u,m=u*Math.atan2(d,l),_=2*p;i[_]=f*Math.cos(m),i[_+1]=f*Math.sin(m),s[_]=i[_],s[_+1]=-i[_+1]}this._slicedChirpBuffer=i.subarray(n,r),this._f=new Od(a>>1),this._f.transform(this._chirpBuffer,s)}_transform(e,n,r){const a=this._buffer1,i=this._buffer2,s=this._outBuffer1,o=this._outBuffer2,l=this._chirpBuffer,d=this._slicedChirpBuffer,p=this._a;if(r)for(let u=0;u<d.length;u+=2){const f=u+1,m=u>>1,_=n[m];a[u]=_*d[u],a[f]=_*d[f]}else for(let u=0;u<d.length;u+=2){const f=u+1;a[u]=n[u]*d[u]-n[f]*d[f],a[f]=n[u]*d[f]+n[f]*d[u]}this._f.transform(s,a);for(let u=0;u<l.length;u+=2){const f=u+1;i[u]=s[u]*l[u]-s[f]*l[f],i[f]=s[u]*l[f]+s[f]*l[u]}this._f.inverseTransform(o,i);for(let u=0;u<o.length;u+=2){const f=o[u+p],m=o[u+p+1],_=d[u],v=d[u+1];e[u]=f*_-m*v,e[u+1]=f*v+m*_}}transform(e,n){this._transform(e,n,!1)}realTransform(e,n){this._transform(e,n,!0)}}class J${constructor(e){this.fft_length=e,this.isPowerOfTwo=Md(e),this.isPowerOfTwo?(this.fft=new Od(e),this.outputBufferSize=2*e):(this.fft=new ag(e),this.outputBufferSize=this.fft.bufferSize)}realTransform(e,n){this.fft.realTransform(e,n)}transform(e,n){this.fft.transform(e,n)}}function ig(t,e){if(e%2===0||e<=0)throw new Error("Window size must be a positive odd number");const n=new t.constructor(t.length),r=new t.constructor(e),a=Math.floor(e/2);for(let i=0;i<t.length;++i){let s=0;for(let o=-a;o<=a;++o){let l=i+o;l<0?l=Math.abs(l):l>=t.length&&(l=2*(t.length-1)-l),r[s++]=t[l]}r.sort(),n[i]=r[a]}return n}function pa(t,e){const n=Math.pow(10,e);return Math.round(t*n)/n}function e1(t){const e=Math.round(t);return Math.abs(t)%1===.5?e%2===0?e:e-1:e}/*!
 * ONNX Runtime Web v1.17.1
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */var us=Object.defineProperty,sg=Object.getOwnPropertyDescriptor,og=Object.getOwnPropertyNames,lg=Object.prototype.hasOwnProperty,Y=(t,e)=>()=>(t&&(e=t(t=0)),e),Un=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),Wn=(t,e)=>{for(var n in e)us(t,n,{get:e[n],enumerable:!0})},ug=(t,e,n,r)=>{if(e&&typeof e=="object"||typeof e=="function")for(let a of og(e))!lg.call(t,a)&&a!==n&&us(t,a,{get:()=>e[a],enumerable:!(r=sg(e,a))||r.enumerable});return t},$n=t=>ug(us({},"__esModule",{value:!0}),t),ur,sn,Dn,ds,cs=Y(()=>{ur=new Map,sn=[],Dn=(t,e,n)=>{if(e&&typeof e.init=="function"&&typeof e.createInferenceSessionHandler=="function"){let r=ur.get(t);if(r===void 0)ur.set(t,{backend:e,priority:n});else{if(r.priority>n)return;if(r.priority===n&&r.backend!==e)throw new Error(`cannot register backend "${t}" using priority ${n}`)}if(n>=0){let a=sn.indexOf(t);a!==-1&&sn.splice(a,1);for(let i=0;i<sn.length;i++)if(ur.get(sn[i]).priority<=n){sn.splice(i,0,t);return}sn.push(t)}return}throw new TypeError("not a valid backend")},ds=async t=>{let e=t.length===0?sn:t,n=[];for(let r of e){let a=ur.get(r);if(a){if(a.initialized)return a.backend;if(a.aborted)continue;let i=!!a.initPromise;try{return i||(a.initPromise=a.backend.init(r)),await a.initPromise,a.initialized=!0,a.backend}catch(s){i||n.push({name:r,err:s}),a.aborted=!0}finally{delete a.initPromise}}}throw new Error(`no available backend found. ERR: ${n.map(r=>`[${r.name}] ${r.err}`).join(", ")}`)}}),dg=Y(()=>{cs()}),zd,cg=Y(()=>{zd="1.17.1"}),ui,Nn,Rd=Y(()=>{cg(),ui="warning",Nn={wasm:{},webgl:{},webgpu:{},versions:{common:zd},set logLevel(t){if(t!==void 0){if(typeof t!="string"||["verbose","info","warning","error","fatal"].indexOf(t)===-1)throw new Error(`Unsupported logging level: ${t}`);ui=t}},get logLevel(){return ui}},Object.defineProperty(Nn,"logLevel",{enumerable:!0})}),Ne,pg=Y(()=>{Rd(),Ne=Nn}),Bd,Pd,hg=Y(()=>{Bd=(t,e)=>{let n=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);n.width=t.dims[3],n.height=t.dims[2];let r=n.getContext("2d");if(r!=null){let a,i;e?.tensorLayout!==void 0&&e.tensorLayout==="NHWC"?(a=t.dims[2],i=t.dims[3]):(a=t.dims[3],i=t.dims[2]);let s=e?.format!==void 0?e.format:"RGB",o=e?.norm,l,d;o===void 0||o.mean===void 0?l=[255,255,255,255]:typeof o.mean=="number"?l=[o.mean,o.mean,o.mean,o.mean]:(l=[o.mean[0],o.mean[1],o.mean[2],0],o.mean[3]!==void 0&&(l[3]=o.mean[3])),o===void 0||o.bias===void 0?d=[0,0,0,0]:typeof o.bias=="number"?d=[o.bias,o.bias,o.bias,o.bias]:(d=[o.bias[0],o.bias[1],o.bias[2],0],o.bias[3]!==void 0&&(d[3]=o.bias[3]));let p=i*a,u=0,f=p,m=p*2,_=-1;s==="RGBA"?(u=0,f=p,m=p*2,_=p*3):s==="RGB"?(u=0,f=p,m=p*2):s==="RBG"&&(u=0,m=p,f=p*2);for(let v=0;v<i;v++)for(let $=0;$<a;$++){let b=(t.data[u++]-d[0])*l[0],S=(t.data[f++]-d[1])*l[1],T=(t.data[m++]-d[2])*l[2],E=_===-1?255:(t.data[_++]-d[3])*l[3];r.fillStyle="rgba("+b+","+S+","+T+","+E+")",r.fillRect($,v,1,1)}if("toDataURL"in n)return n.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},Pd=(t,e)=>{let n=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),r;if(n!=null){let a,i,s;e?.tensorLayout!==void 0&&e.tensorLayout==="NHWC"?(a=t.dims[2],i=t.dims[1],s=t.dims[3]):(a=t.dims[3],i=t.dims[2],s=t.dims[1]);let o=e!==void 0&&e.format!==void 0?e.format:"RGB",l=e?.norm,d,p;l===void 0||l.mean===void 0?d=[255,255,255,255]:typeof l.mean=="number"?d=[l.mean,l.mean,l.mean,l.mean]:(d=[l.mean[0],l.mean[1],l.mean[2],255],l.mean[3]!==void 0&&(d[3]=l.mean[3])),l===void 0||l.bias===void 0?p=[0,0,0,0]:typeof l.bias=="number"?p=[l.bias,l.bias,l.bias,l.bias]:(p=[l.bias[0],l.bias[1],l.bias[2],0],l.bias[3]!==void 0&&(p[3]=l.bias[3]));let u=i*a;if(e!==void 0&&(e.format!==void 0&&s===4&&e.format!=="RGBA"||s===3&&e.format!=="RGB"&&e.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let f=4,m=0,_=1,v=2,$=3,b=0,S=u,T=u*2,E=-1;o==="RGBA"?(b=0,S=u,T=u*2,E=u*3):o==="RGB"?(b=0,S=u,T=u*2):o==="RBG"&&(b=0,T=u,S=u*2),r=n.createImageData(a,i);for(let I=0;I<i*a;m+=f,_+=f,v+=f,$+=f,I++)r.data[m]=(t.data[b++]-p[0])*d[0],r.data[_]=(t.data[S++]-p[1])*d[1],r.data[v]=(t.data[T++]-p[2])*d[2],r.data[$]=E===-1?255:(t.data[E++]-p[3])*d[3]}else throw new Error("Can not access image data");return r}}),ha,Dd,Nd,Ld,Fd,fg=Y(()=>{ps(),ha=(t,e)=>{if(t===void 0)throw new Error("Image buffer must be defined");if(e.height===void 0||e.width===void 0)throw new Error("Image height and width must be defined");if(e.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:n,width:r}=e,a=e.norm??{mean:255,bias:0},i,s;typeof a.mean=="number"?i=[a.mean,a.mean,a.mean,a.mean]:i=[a.mean[0],a.mean[1],a.mean[2],a.mean[3]??255],typeof a.bias=="number"?s=[a.bias,a.bias,a.bias,a.bias]:s=[a.bias[0],a.bias[1],a.bias[2],a.bias[3]??0];let o=e.format!==void 0?e.format:"RGBA",l=e.tensorFormat!==void 0&&e.tensorFormat!==void 0?e.tensorFormat:"RGB",d=n*r,p=l==="RGBA"?new Float32Array(d*4):new Float32Array(d*3),u=4,f=0,m=1,_=2,v=3,$=0,b=d,S=d*2,T=-1;o==="RGB"&&(u=3,f=0,m=1,_=2,v=-1),l==="RGBA"?T=d*3:l==="RBG"?($=0,S=d,b=d*2):l==="BGR"&&(S=0,b=d,$=d*2);for(let E=0;E<d;E++,f+=u,_+=u,m+=u,v+=u)p[$++]=(t[f]+s[0])/i[0],p[b++]=(t[m]+s[1])/i[1],p[S++]=(t[_]+s[2])/i[2],T!==-1&&v!==-1&&(p[T++]=(t[v]+s[3])/i[3]);return l==="RGBA"?new zt("float32",p,[1,4,n,r]):new zt("float32",p,[1,3,n,r])},Dd=async(t,e)=>{let n=typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement,r=typeof ImageData<"u"&&t instanceof ImageData,a=typeof ImageBitmap<"u"&&t instanceof ImageBitmap,i=typeof t=="string",s,o=e??{},l=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},d=p=>p instanceof HTMLCanvasElement||p instanceof OffscreenCanvas?p.getContext("2d"):null;if(n){let p=l();p.width=t.width,p.height=t.height;let u=d(p);if(u!=null){let f=t.height,m=t.width;if(e!==void 0&&e.resizedHeight!==void 0&&e.resizedWidth!==void 0&&(f=e.resizedHeight,m=e.resizedWidth),e!==void 0){if(o=e,e.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");o.tensorFormat="RGBA",o.height=f,o.width=m}else o.tensorFormat="RGBA",o.height=f,o.width=m;u.drawImage(t,0,0),s=u.getImageData(0,0,m,f).data}else throw new Error("Can not access image data")}else if(r){let p,u;if(e!==void 0&&e.resizedWidth!==void 0&&e.resizedHeight!==void 0?(p=e.resizedHeight,u=e.resizedWidth):(p=t.height,u=t.width),e!==void 0&&(o=e),o.format="RGBA",o.height=p,o.width=u,e!==void 0){let f=l();f.width=u,f.height=p;let m=d(f);if(m!=null)m.putImageData(t,0,0),s=m.getImageData(0,0,u,p).data;else throw new Error("Can not access image data")}else s=t.data}else if(a){if(e===void 0)throw new Error("Please provide image config with format for Imagebitmap");let p=l();p.width=t.width,p.height=t.height;let u=d(p);if(u!=null){let f=t.height,m=t.width;return u.drawImage(t,0,0,m,f),s=u.getImageData(0,0,m,f).data,o.height=f,o.width=m,ha(s,o)}else throw new Error("Can not access image data")}else{if(i)return new Promise((p,u)=>{let f=l(),m=d(f);if(!t||!m)return u();let _=new Image;_.crossOrigin="Anonymous",_.src=t,_.onload=()=>{f.width=_.width,f.height=_.height,m.drawImage(_,0,0,f.width,f.height);let v=m.getImageData(0,0,f.width,f.height);o.height=f.height,o.width=f.width,p(ha(v.data,o))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(s!==void 0)return ha(s,o);throw new Error("Input data provided is not supported - aborted tensor creation")},Nd=(t,e)=>{let{width:n,height:r,download:a,dispose:i}=e,s=[1,r,n,4];return new zt({location:"texture",type:"float32",texture:t,dims:s,download:a,dispose:i})},Ld=(t,e)=>{let{dataType:n,dims:r,download:a,dispose:i}=e;return new zt({location:"gpu-buffer",type:n??"float32",gpuBuffer:t,dims:r,download:a,dispose:i})},Fd=(t,e,n)=>new zt({location:"cpu-pinned",type:t,data:e,dims:n??[e.length]})}),vr,Sa,di,Ud,mg=Y(()=>{vr=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["float16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),Sa=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),di=!1,Ud=()=>{if(!di){di=!0;let t=typeof BigInt64Array<"u"&&typeof BigInt64Array.from=="function",e=typeof BigUint64Array<"u"&&typeof BigUint64Array.from=="function";t&&(vr.set("int64",BigInt64Array),Sa.set(BigInt64Array,"int64")),e&&(vr.set("uint64",BigUint64Array),Sa.set(BigUint64Array,"uint64"))}}}),Wd,Vd,gg=Y(()=>{ps(),Wd=t=>{let e=1;for(let n=0;n<t.length;n++){let r=t[n];if(typeof r!="number"||!Number.isSafeInteger(r))throw new TypeError(`dims[${n}] must be an integer, got: ${r}`);if(r<0)throw new RangeError(`dims[${n}] must be a non-negative integer, got: ${r}`);e*=r}return e},Vd=(t,e)=>{switch(t.location){case"cpu":return new zt(t.type,t.data,e);case"cpu-pinned":return new zt({location:"cpu-pinned",data:t.data,type:t.type,dims:e});case"texture":return new zt({location:"texture",texture:t.texture,type:t.type,dims:e});case"gpu-buffer":return new zt({location:"gpu-buffer",gpuBuffer:t.gpuBuffer,type:t.type,dims:e});default:throw new Error(`tensorReshape: tensor location ${t.location} is not supported`)}}}),zt,ps=Y(()=>{hg(),fg(),mg(),gg(),zt=class{constructor(t,e,n){Ud();let r,a;if(typeof t=="object"&&"location"in t)switch(this.dataLocation=t.location,r=t.type,a=t.dims,t.location){case"cpu-pinned":{let s=vr.get(r);if(!s)throw new TypeError(`unsupported type "${r}" to create tensor from pinned buffer`);if(!(t.data instanceof s))throw new TypeError(`buffer should be of type ${s.name}`);this.cpuData=t.data;break}case"texture":{if(r!=="float32")throw new TypeError(`unsupported type "${r}" to create tensor from texture`);this.gpuTextureData=t.texture,this.downloader=t.download,this.disposer=t.dispose;break}case"gpu-buffer":{if(r!=="float32"&&r!=="float16"&&r!=="int32"&&r!=="int64"&&r!=="uint32"&&r!=="bool")throw new TypeError(`unsupported type "${r}" to create tensor from gpu buffer`);this.gpuBufferData=t.gpuBuffer,this.downloader=t.download,this.disposer=t.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let s,o;if(typeof t=="string")if(r=t,o=n,t==="string"){if(!Array.isArray(e))throw new TypeError("A string tensor's data must be a string array.");s=e}else{let l=vr.get(t);if(l===void 0)throw new TypeError(`Unsupported tensor type: ${t}.`);if(Array.isArray(e)){if(t==="float16")throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");t==="uint64"||t==="int64"?s=l.from(e,BigInt):s=l.from(e)}else if(e instanceof l)s=e;else throw new TypeError(`A ${r} tensor's data must be type of ${l}`)}else if(o=e,Array.isArray(t)){if(t.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let l=typeof t[0];if(l==="string")r="string",s=t;else if(l==="boolean")r="bool",s=Uint8Array.from(t);else throw new TypeError(`Invalid element type of data array: ${l}.`)}else{let l=Sa.get(t.constructor);if(l===void 0)throw new TypeError(`Unsupported type for tensor data: ${t.constructor}.`);r=l,s=t}if(o===void 0)o=[s.length];else if(!Array.isArray(o))throw new TypeError("A tensor's dims must be a number array");a=o,this.cpuData=s,this.dataLocation="cpu"}let i=Wd(a);if(this.cpuData&&i!==this.cpuData.length)throw new Error(`Tensor's size(${i}) does not match data length(${this.cpuData.length}).`);this.type=r,this.dims=a,this.size=i}static async fromImage(t,e){return Dd(t,e)}static fromTexture(t,e){return Nd(t,e)}static fromGpuBuffer(t,e){return Ld(t,e)}static fromPinnedBuffer(t,e,n){return Fd(t,e,n)}toDataURL(t){return Bd(this,t)}toImageData(t){return Pd(this,t)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}async getData(t){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let e=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=e,t&&this.disposer&&(this.disposer(),this.disposer=void 0),e}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(t){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return Vd(this,t)}}}),ct,hs=Y(()=>{ps(),ct=zt}),kr,ci,Bt,Pt,Gd=Y(()=>{Rd(),kr=(t,e)=>{Nn.wasm.trace&&console.timeStamp(`${t}::ORT::${e}`)},ci=(t,e)=>{let n=new Error().stack?.split(/\r\n|\r|\n/g)||[],r=!1;for(let a=0;a<n.length;a++){if(r&&!n[a].includes("TRACE_FUNC")){let i=`FUNC_${t}::${n[a].trim().split(" ")[1]}`;e&&(i+=`::${e}`),kr("CPU",i);return}n[a].includes("TRACE_FUNC")&&(r=!0)}},Bt=t=>{Nn.wasm.trace&&ci("BEGIN",t)},Pt=t=>{Nn.wasm.trace&&ci("END",t)}}),Hd,_g=Y(()=>{cs(),hs(),Gd(),Hd=class qd{constructor(e){this.handler=e}async run(e,n,r){Bt();let a={},i={};if(typeof e!="object"||e===null||e instanceof ct||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let s=!0;if(typeof n=="object"){if(n===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(n instanceof ct)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(n)){if(n.length===0)throw new TypeError("'fetches' cannot be an empty array.");s=!1;for(let d of n){if(typeof d!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(d)===-1)throw new RangeError(`'fetches' contains invalid output name: ${d}.`);a[d]=null}if(typeof r=="object"&&r!==null)i=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else{let d=!1,p=Object.getOwnPropertyNames(n);for(let u of this.outputNames)if(p.indexOf(u)!==-1){let f=n[u];(f===null||f instanceof ct)&&(d=!0,s=!1,a[u]=f)}if(d){if(typeof r=="object"&&r!==null)i=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else i=n}}else if(typeof n<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let d of this.inputNames)if(typeof e[d]>"u")throw new Error(`input '${d}' is missing in 'feeds'.`);if(s)for(let d of this.outputNames)a[d]=null;let o=await this.handler.run(e,a,i),l={};for(let d in o)if(Object.hasOwnProperty.call(o,d)){let p=o[d];p instanceof ct?l[d]=p:l[d]=new ct(p.type,p.data,p.dims)}return Pt(),l}async release(){return this.handler.dispose()}static async create(e,n,r,a){Bt();let i,s={};if(typeof e=="string"){if(i=e,typeof n=="object"&&n!==null)s=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof Uint8Array){if(i=e,typeof n=="object"&&n!==null)s=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&e instanceof SharedArrayBuffer){let d=e,p=0,u=e.byteLength;if(typeof n=="object"&&n!==null)s=n;else if(typeof n=="number"){if(p=n,!Number.isSafeInteger(p))throw new RangeError("'byteOffset' must be an integer.");if(p<0||p>=d.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${d.byteLength}).`);if(u=e.byteLength-p,typeof r=="number"){if(u=r,!Number.isSafeInteger(u))throw new RangeError("'byteLength' must be an integer.");if(u<=0||p+u>d.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${d.byteLength-p}].`);if(typeof a=="object"&&a!==null)s=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else if(typeof r<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof n<"u")throw new TypeError("'options' must be an object.");i=new Uint8Array(d,p,u)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let o=(s.executionProviders||[]).map(d=>typeof d=="string"?d:d.name),l=await(await ds(o)).createInferenceSessionHandler(i,s);return Pt(),new qd(l)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}}),fs,wg=Y(()=>{_g(),fs=Hd}),yg=Y(()=>{}),mo,jd,vg=Y(()=>{cs(),hs(),mo="Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.",jd=class Kd{constructor(e,n,r){this.handler=e,this.hasOptimizerModel=n,this.hasEvalModel=r}get trainingInputNames(){return this.handler.inputNames}get trainingOutputNames(){return this.handler.outputNames}get evalInputNames(){if(this.hasEvalModel)return this.handler.evalInputNames;throw new Error("This training session has no evalModel loaded.")}get evalOutputNames(){if(this.hasEvalModel)return this.handler.evalOutputNames;throw new Error("This training session has no evalModel loaded.")}static async create(e,n){let r=e.evalModel||"",a=e.optimizerModel||"",i=n||{},s=(i.executionProviders||[]).map(l=>typeof l=="string"?l:l.name),o=await ds(s);if(o.createTrainingSessionHandler){let l=await o.createTrainingSessionHandler(e.checkpointState,e.trainModel,r,a,i);return new Kd(l,!!e.optimizerModel,!!e.evalModel)}else throw new Error(mo)}typeNarrowingForRunStep(e,n,r,a,i){let s={},o={};if(typeof r!="object"||r===null||r instanceof ct||Array.isArray(r))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let l=!0;if(typeof a=="object"){if(a===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(a instanceof ct)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(a)){if(a.length===0)throw new TypeError("'fetches' cannot be an empty array.");l=!1;for(let d of a){if(typeof d!="string")throw new TypeError("'fetches' must be a string array or an object.");if(n.indexOf(d)===-1)throw new RangeError(`'fetches' contains invalid output name: ${d}.`);s[d]=null}if(typeof i=="object"&&i!==null)o=i;else if(typeof i<"u")throw new TypeError("'options' must be an object.")}else{let d=!1,p=Object.getOwnPropertyNames(a);for(let u of n)if(p.indexOf(u)!==-1){let f=a[u];(f===null||f instanceof ct)&&(d=!0,l=!1,s[u]=f)}if(d){if(typeof i=="object"&&i!==null)o=i;else if(typeof i<"u")throw new TypeError("'options' must be an object.")}else o=a}}else if(typeof a<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let d of e)if(typeof r[d]>"u")throw new Error(`input '${d}' is missing in 'feeds'.`);if(l)for(let d of n)s[d]=null;return[s,o]}convertHandlerReturnTypeToMapOfTensors(e){let n={};for(let r in e)if(Object.hasOwnProperty.call(e,r)){let a=e[r];a instanceof ct?n[r]=a:n[r]=new ct(a.type,a.data,a.dims)}return n}async lazyResetGrad(){await this.handler.lazyResetGrad()}async runTrainStep(e,n,r){let[a,i]=this.typeNarrowingForRunStep(this.trainingInputNames,this.trainingOutputNames,e,n,r),s=await this.handler.runTrainStep(e,a,i);return this.convertHandlerReturnTypeToMapOfTensors(s)}async runOptimizerStep(e){if(this.hasOptimizerModel)await this.handler.runOptimizerStep(e||{});else throw new Error("This TrainingSession has no OptimizerModel loaded.")}async runEvalStep(e,n,r){if(this.hasEvalModel){let[a,i]=this.typeNarrowingForRunStep(this.evalInputNames,this.evalOutputNames,e,n,r),s=await this.handler.runEvalStep(e,a,i);return this.convertHandlerReturnTypeToMapOfTensors(s)}else throw new Error("This TrainingSession has no EvalModel loaded.")}async getParametersSize(e=!0){return this.handler.getParametersSize(e)}async loadParametersBuffer(e,n=!0){let r=await this.getParametersSize(n);if(e.length!==4*r)throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");return this.handler.loadParametersBuffer(e,n)}async getContiguousParameters(e=!0){return this.handler.getContiguousParameters(e)}async release(){return this.handler.dispose()}}}),ms,bg=Y(()=>{vg(),ms=jd}),Yd={};Wn(Yd,{InferenceSession:()=>fs,TRACE:()=>kr,TRACE_FUNC_BEGIN:()=>Bt,TRACE_FUNC_END:()=>Pt,Tensor:()=>ct,TrainingSession:()=>ms,env:()=>Ne,registerBackend:()=>Dn});var Dt=Y(()=>{dg(),pg(),wg(),hs(),Gd(),yg(),bg()}),gs={};Wn(gs,{createReadStream:()=>Zd,readFile:()=>Xd,readFileSync:()=>Qd});var Xd,Qd,Zd,Jd=Y(()=>{Xd=void 0,Qd=void 0,Zd=void 0}),_s={};Wn(_s,{join:()=>ec});var ec,tc=Y(()=>{ec=void 0}),$g=Un((t,e)=>{var n=(()=>{var r=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(r=r||__filename),function(a={}){var i=a,s,o;i.ready=new Promise((h,w)=>{s=h,o=w}),i.mountExternalData=(h,w)=>{(i.Fa||(i.Fa=new Map)).set(h,w)},i.unmountExternalData=()=>{delete i.Fa},i.jsepInit=(h,w,x,C,P,j,ee,_e)=>{i.ab=h,i.Qa=w,i.Sa=x,i.La=C,i.Ra=P,i.sa=j,i.Ta=ee,i.Ua=_e,w=(se,ue,me)=>(...ke)=>{let ze=ft,z=ue?.();ke=se(...ke);let ge=ue?.();return z!==ge&&(se=ge,me(z),ue=me=null),ft!=ze?ea():ke},x=se=>async(...ue)=>{try{if(i.Ea)throw Error("Session already started");let me=i.Ea={Va:ue[0],errors:[]},ke=await se(...ue);if(i.Ea!==me)throw Error("Session mismatch");h.flush();let ze=me.errors;if(0<ze.length){let z=await Promise.all(ze);if(z=z.filter(ge=>ge),0<z.length)throw Error(z.join(`
`))}return ke}finally{i.Ea=null}},i._OrtRun=x(w(i._OrtRun,()=>i._OrtRun,se=>i._OrtRun=se)),i._OrtRunWithBinding=x(w(i._OrtRunWithBinding,()=>i._OrtRunWithBinding,se=>i._OrtRunWithBinding=se)),i._OrtBindInput=w(i._OrtBindInput,()=>i._OrtBindInput,se=>i._OrtBindInput=se),i.jsepRegisterBuffer=(se,ue,me,ke)=>h.registerBuffer(se,ue,me,ke),i.jsepUnregisterBuffers=se=>{h.unregisterBuffers(se)},i.jsepGetBuffer=se=>h.getBuffer(se),i.jsepCreateDownloader=(se,ue,me)=>h.createDownloader(se,ue,me)};var l=Object.assign({},i),d="./this.program",p=(h,w)=>{throw w},u=typeof window=="object",f=typeof importScripts=="function",m=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",_="",v,$,b;if(m){var S=(Jd(),$n(gs)),T=(tc(),$n(_s));_=f?T.dirname(_)+"/":__dirname+"/",v=(h,w)=>(h=$e(h)?new URL(h):T.normalize(h),S.readFileSync(h,w?void 0:"utf8")),b=h=>(h=v(h,!0),h.buffer||(h=new Uint8Array(h)),h),$=(h,w,x,C=!0)=>{h=$e(h)?new URL(h):T.normalize(h),S.readFile(h,C?void 0:"utf8",(P,j)=>{P?x(P):w(C?j.buffer:j)})},!i.thisProgram&&1<process.argv.length&&(d=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),p=(h,w)=>{throw process.exitCode=h,w},i.inspect=()=>"[Emscripten Module object]"}else(u||f)&&(f?_=self.location.href:typeof document<"u"&&document.currentScript&&(_=document.currentScript.src),r&&(_=r),_.indexOf("blob:")!==0?_=_.substr(0,_.replace(/[?#].*/,"").lastIndexOf("/")+1):_="",v=h=>{var w=new XMLHttpRequest;return w.open("GET",h,!1),w.send(null),w.responseText},f&&(b=h=>{var w=new XMLHttpRequest;return w.open("GET",h,!1),w.responseType="arraybuffer",w.send(null),new Uint8Array(w.response)}),$=(h,w,x)=>{var C=new XMLHttpRequest;C.open("GET",h,!0),C.responseType="arraybuffer",C.onload=()=>{C.status==200||C.status==0&&C.response?w(C.response):x()},C.onerror=x,C.send(null)});var E=console.log.bind(console),I=console.error.bind(console);Object.assign(i,l),l=null,typeof WebAssembly!="object"&&V("no native wasm support detected");var M,F=!1,L,W,X,A,q,te,K;function B(){var h=M.buffer;i.HEAP8=W=new Int8Array(h),i.HEAP16=new Int16Array(h),i.HEAPU8=X=new Uint8Array(h),i.HEAPU16=new Uint16Array(h),i.HEAP32=A=new Int32Array(h),i.HEAPU32=q=new Uint32Array(h),i.HEAPF32=te=new Float32Array(h),i.HEAPF64=K=new Float64Array(h)}var U=[],G=[],ne=[],oe=0,ye=null;function V(h){throw h="Aborted("+h+")",I(h),F=!0,L=1,h=new WebAssembly.RuntimeError(h+". Build with -sASSERTIONS for more info."),o(h),h}var ie=h=>h.startsWith("data:application/octet-stream;base64,"),$e=h=>h.startsWith("file://"),Le;if(Le="ort-wasm-simd.wasm",!ie(Le)){var Pe=Le;Le=i.locateFile?i.locateFile(Pe,_):_+Pe}function We(h){if(b)return b(h);throw"both async and sync fetching of the wasm failed"}function ht(h){if(u||f){if(typeof fetch=="function"&&!$e(h))return fetch(h,{credentials:"same-origin"}).then(w=>{if(!w.ok)throw"failed to load wasm binary file at '"+h+"'";return w.arrayBuffer()}).catch(()=>We(h));if($)return new Promise((w,x)=>{$(h,C=>w(new Uint8Array(C)),x)})}return Promise.resolve().then(()=>We(h))}function Fe(h,w,x){return ht(h).then(C=>WebAssembly.instantiate(C,w)).then(C=>C).then(x,C=>{I(`failed to asynchronously prepare wasm: ${C}`),V(C)})}function Ve(h,w){var x=Le;return typeof WebAssembly.instantiateStreaming!="function"||ie(x)||$e(x)||m||typeof fetch!="function"?Fe(x,h,w):fetch(x,{credentials:"same-origin"}).then(C=>WebAssembly.instantiateStreaming(C,h).then(w,function(P){return I(`wasm streaming compile failed: ${P}`),I("falling back to ArrayBuffer instantiation"),Fe(x,h,w)}))}var tt,vt={931056:(h,w,x,C)=>{if(typeof i>"u"||!i.Fa)return 1;if(h=Qe(h>>>0),h.startsWith("./")&&(h=h.substring(2)),h=i.Fa.get(h),!h)return 2;if(w>>>=0,x>>>=0,w+x>h.byteLength)return 3;try{return X.set(h.subarray(w,w+x),C>>>0>>>0),0}catch{return 4}},931557:h=>i.Qa(h),931590:h=>i.Sa(h),931622:(h,w,x)=>{i.La(h,w,x,!0)},931661:(h,w,x)=>{i.La(h,w,x)},931694:h=>{i.sa("Abs",h,void 0)},931745:h=>{i.sa("Neg",h,void 0)},931796:h=>{i.sa("Floor",h,void 0)},931849:h=>{i.sa("Ceil",h,void 0)},931901:h=>{i.sa("Reciprocal",h,void 0)},931959:h=>{i.sa("Sqrt",h,void 0)},932011:h=>{i.sa("Exp",h,void 0)},932062:h=>{i.sa("Erf",h,void 0)},932113:h=>{i.sa("Sigmoid",h,void 0)},932168:h=>{i.sa("Log",h,void 0)},932219:h=>{i.sa("Sin",h,void 0)},932270:h=>{i.sa("Cos",h,void 0)},932321:h=>{i.sa("Tan",h,void 0)},932372:h=>{i.sa("Asin",h,void 0)},932424:h=>{i.sa("Acos",h,void 0)},932476:h=>{i.sa("Atan",h,void 0)},932528:h=>{i.sa("Sinh",h,void 0)},932580:h=>{i.sa("Cosh",h,void 0)},932632:h=>{i.sa("Asinh",h,void 0)},932685:h=>{i.sa("Acosh",h,void 0)},932738:h=>{i.sa("Atanh",h,void 0)},932791:h=>{i.sa("Tanh",h,void 0)},932843:h=>{i.sa("Not",h,void 0)},932894:(h,w,x)=>{i.sa("Clip",h,{min:w,max:x})},932963:h=>{i.sa("Clip",h,void 0)},933015:(h,w)=>{i.sa("Elu",h,{alpha:w})},933073:h=>{i.sa("Relu",h,void 0)},933125:(h,w)=>{i.sa("LeakyRelu",h,{alpha:w})},933189:(h,w)=>{i.sa("ThresholdedRelu",h,{alpha:w})},933259:(h,w)=>{i.sa("Cast",h,{to:w})},933317:h=>{i.sa("Add",h,void 0)},933368:h=>{i.sa("Sub",h,void 0)},933419:h=>{i.sa("Mul",h,void 0)},933470:h=>{i.sa("Div",h,void 0)},933521:h=>{i.sa("Pow",h,void 0)},933572:h=>{i.sa("Equal",h,void 0)},933625:h=>{i.sa("Greater",h,void 0)},933680:h=>{i.sa("GreaterOrEqual",h,void 0)},933742:h=>{i.sa("Less",h,void 0)},933794:h=>{i.sa("LessOrEqual",h,void 0)},933853:(h,w,x,C,P)=>{i.sa("ReduceMean",h,{keepDims:!!w,noopWithEmptyAxes:!!x,axes:C?Array.from(A.subarray(C>>>0,P>>>0)):[]})},934012:(h,w,x,C,P)=>{i.sa("ReduceMax",h,{keepDims:!!w,noopWithEmptyAxes:!!x,axes:C?Array.from(A.subarray(C>>>0,P>>>0)):[]})},934170:(h,w,x,C,P)=>{i.sa("ReduceMin",h,{keepDims:!!w,noopWithEmptyAxes:!!x,axes:C?Array.from(A.subarray(C>>>0,P>>>0)):[]})},934328:(h,w,x,C,P)=>{i.sa("ReduceProd",h,{keepDims:!!w,noopWithEmptyAxes:!!x,axes:C?Array.from(A.subarray(C>>>0,P>>>0)):[]})},934487:(h,w,x,C,P)=>{i.sa("ReduceSum",h,{keepDims:!!w,noopWithEmptyAxes:!!x,axes:C?Array.from(A.subarray(C>>>0,P>>>0)):[]})},934645:(h,w,x,C,P)=>{i.sa("ReduceL1",h,{keepDims:!!w,noopWithEmptyAxes:!!x,axes:C?Array.from(A.subarray(C>>>0,P>>>0)):[]})},934802:(h,w,x,C,P)=>{i.sa("ReduceL2",h,{keepDims:!!w,noopWithEmptyAxes:!!x,axes:C?Array.from(A.subarray(C>>>0,P>>>0)):[]})},934959:(h,w,x,C,P)=>{i.sa("ReduceLogSum",h,{keepDims:!!w,noopWithEmptyAxes:!!x,axes:C?Array.from(A.subarray(C>>>0,P>>>0)):[]})},935120:(h,w,x,C,P)=>{i.sa("ReduceSumSquare",h,{keepDims:!!w,noopWithEmptyAxes:!!x,axes:C?Array.from(A.subarray(C>>>0,P>>>0)):[]})},935284:(h,w,x,C,P)=>{i.sa("ReduceLogSumExp",h,{keepDims:!!w,noopWithEmptyAxes:!!x,axes:C?Array.from(A.subarray(C>>>0,P>>>0)):[]})},935448:h=>{i.sa("Where",h,void 0)},935501:(h,w,x)=>{i.sa("Transpose",h,{perm:w?Array.from(A.subarray(w>>>0,x>>>0)):[]})},935609:(h,w,x,C,P,j,ee,_e,se,ue,me,ke,ze,z,ge)=>{i.sa("ConvTranspose",h,{format:se?"NHWC":"NCHW",autoPad:w,dilations:[x],group:C,kernel_shape:[P],pads:[j,ee],strides:[_e],wIsConst:()=>!!W[ue>>>0],outputPadding:me?Array.from(A.subarray(me>>>0,ke>>>0)):[],outputShape:ze?Array.from(A.subarray(ze>>>0,z>>>0)):[],activation:Qe(ge)})},936011:(h,w,x,C,P,j,ee,_e,se,ue,me,ke,ze,z)=>{i.sa("ConvTranspose",h,{format:_e?"NHWC":"NCHW",autoPad:w,dilations:Array.from(A.subarray(x>>>0,(x>>>0)+2>>>0)),group:C,kernelShape:Array.from(A.subarray(P>>>0,(P>>>0)+2>>>0)),pads:Array.from(A.subarray(j>>>0,(j>>>0)+4>>>0)),strides:Array.from(A.subarray(ee>>>0,(ee>>>0)+2>>>0)),wIsConst:()=>!!W[se>>>0],outputPadding:ue?Array.from(A.subarray(ue>>>0,me>>>0)):[],outputShape:ke?Array.from(A.subarray(ke>>>0,ze>>>0)):[],activation:Qe(z)})},936576:(h,w,x,C,P,j,ee,_e,se,ue,me,ke,ze,z,ge)=>{i.sa("ConvTranspose",h,{format:se?"NHWC":"NCHW",autoPad:w,dilations:[x],group:C,kernel_shape:[P],pads:[j,ee],strides:[_e],wIsConst:()=>!!W[ue>>>0],outputPadding:me?Array.from(A.subarray(me>>>0,ke>>>0)):[],outputShape:ze?Array.from(A.subarray(ze>>>0,z>>>0)):[],activation:Qe(ge)})},936978:(h,w,x,C,P,j,ee,_e,se,ue,me,ke,ze,z)=>{i.sa("ConvTranspose",h,{format:_e?"NHWC":"NCHW",autoPad:w,dilations:Array.from(A.subarray(x>>>0,(x>>>0)+2>>>0)),group:C,kernelShape:Array.from(A.subarray(P>>>0,(P>>>0)+2>>>0)),pads:Array.from(A.subarray(j>>>0,(j>>>0)+4>>>0)),strides:Array.from(A.subarray(ee>>>0,(ee>>>0)+2>>>0)),wIsConst:()=>!!W[se>>>0],outputPadding:ue?Array.from(A.subarray(ue>>>0,me>>>0)):[],outputShape:ke?Array.from(A.subarray(ke>>>0,ze>>>0)):[],activation:Qe(z)})},937543:(h,w)=>{i.sa("GlobalAveragePool",h,{format:w?"NHWC":"NCHW"})},937634:(h,w,x,C,P,j,ee,_e,se,ue,me,ke,ze,z,ge,Ce)=>{i.sa("AveragePool",h,{format:Ce?"NHWC":"NCHW",auto_pad:w,ceil_mode:x,count_include_pad:C,storage_order:P,dilations:[j,ee],kernel_shape:[_e,se],pads:[ue,me,ke,ze],strides:[z,ge]})},937918:(h,w)=>{i.sa("GlobalAveragePool",h,{format:w?"NHWC":"NCHW"})},938009:(h,w,x,C,P,j,ee,_e,se,ue,me,ke,ze,z,ge,Ce)=>{i.sa("AveragePool",h,{format:Ce?"NHWC":"NCHW",auto_pad:w,ceil_mode:x,count_include_pad:C,storage_order:P,dilations:[j,ee],kernel_shape:[_e,se],pads:[ue,me,ke,ze],strides:[z,ge]})},938293:(h,w)=>{i.sa("GlobalMaxPool",h,{format:w?"NHWC":"NCHW"})},938380:(h,w,x,C,P,j,ee,_e,se,ue,me,ke,ze,z,ge,Ce)=>{i.sa("MaxPool",h,{format:Ce?"NHWC":"NCHW",auto_pad:w,ceil_mode:x,count_include_pad:C,storage_order:P,dilations:[j,ee],kernel_shape:[_e,se],pads:[ue,me,ke,ze],strides:[z,ge]})},938660:(h,w)=>{i.sa("GlobalMaxPool",h,{format:w?"NHWC":"NCHW"})},938747:(h,w,x,C,P,j,ee,_e,se,ue,me,ke,ze,z,ge,Ce)=>{i.sa("MaxPool",h,{format:Ce?"NHWC":"NCHW",auto_pad:w,ceil_mode:x,count_include_pad:C,storage_order:P,dilations:[j,ee],kernel_shape:[_e,se],pads:[ue,me,ke,ze],strides:[z,ge]})},939027:(h,w,x,C,P)=>{i.sa("Gemm",h,{alpha:w,beta:x,transA:C,transB:P})},939131:h=>{i.sa("MatMul",h,void 0)},939185:(h,w,x,C)=>{i.sa("ArgMax",h,{keepDims:!!w,selectLastIndex:!!x,axis:C})},939293:(h,w,x,C)=>{i.sa("ArgMin",h,{keepDims:!!w,selectLastIndex:!!x,axis:C})},939401:(h,w)=>{i.sa("Softmax",h,{axis:w})},939464:(h,w)=>{i.sa("Concat",h,{axis:w})},939524:(h,w,x,C,P)=>{i.sa("Split",h,{axis:w,numOutputs:x,splitSizes:C?Array.from(A.subarray(C>>>0,P>>>0)):[]})},939664:h=>{i.sa("Expand",h,void 0)},939718:(h,w)=>{i.sa("Gather",h,{axis:Number(w)})},939789:(h,w)=>{i.sa("GatherElements",h,{axis:Number(w)})},939868:(h,w,x,C,P,j,ee,_e,se,ue,me)=>{i.sa("Resize",h,{antialias:w,axes:x?Array.from(A.subarray(x>>>0,C>>>0)):[],coordinateTransformMode:Qe(P),cubicCoeffA:j,excludeOutside:ee,extrapolationValue:_e,keepAspectRatioPolicy:Qe(se),mode:Qe(ue),nearestMode:Qe(me)})},940214:(h,w,x,C,P,j,ee)=>{i.sa("Slice",h,{starts:w?Array.from(A.subarray(w>>>0,x>>>0)):[],ends:C?Array.from(A.subarray(C>>>0,P>>>0)):[],axes:j?Array.from(A.subarray(j>>>0,ee>>>0)):[]})},940430:h=>{i.sa("Tile",h,void 0)},940482:(h,w,x)=>{i.sa("LayerNormalization",h,{axis:Number(w),epsilon:Number(x)})},940589:(h,w,x)=>{i.sa("InstanceNormalization",h,{epsilon:w,format:x?"NHWC":"NCHW"})},940703:(h,w,x)=>{i.sa("InstanceNormalization",h,{epsilon:w,format:x?"NHWC":"NCHW"})},940817:h=>{i.sa("Range",h,void 0)},940870:(h,w)=>{i.sa("Einsum",h,{equation:Qe(w)})},940951:(h,w,x,C,P)=>{i.sa("Pad",h,{mode:w,value:x,pads:C?Array.from(A.subarray(C>>>0,P>>>0)):[]})},941078:(h,w,x,C,P,j)=>{i.sa("BatchNormalization",h,{epsilon:w,momentum:x,spatial:!!P,trainingMode:!!C,format:j?"NHWC":"NCHW"})},941247:(h,w,x,C,P,j)=>{i.sa("BatchNormalization",h,{epsilon:w,momentum:x,spatial:!!P,trainingMode:!!C,format:j?"NHWC":"NCHW"})},941416:(h,w,x)=>{i.sa("CumSum",h,{exclusive:Number(w),reverse:Number(x)})},941513:(h,w,x,C,P,j,ee,_e,se)=>{i.sa("Attention",h,{numHeads:w,isUnidirectional:x,maskFilterValue:C,scale:P,doRotary:j,qkvHiddenSizes:ee?Array.from(A.subarray(Number(_e)>>>0,Number(_e)+ee>>>0)):[],pastPresentShareBuffer:!!se})},941785:h=>{i.sa("Gelu",h,void 0)},941837:(h,w,x,C,P,j)=>{i.sa("MultiHeadAttention",h,{numHeads:w,isUnidirectional:x,maskFilterValue:C,scale:P,doRotary:j})},941996:h=>{i.sa("BiasAdd",h,void 0)},942051:h=>{i.sa("BiasSplitGelu",h,void 0)},942112:(h,w)=>{i.sa("SkipLayerNormalization",h,{epsilon:w})},942193:(h,w,x,C,P,j,ee,_e,se,ue,me,ke,ze)=>{i.sa("Conv",h,{format:se?"NHWC":"NCHW",auto_pad:w,dilations:[x],group:C,kernel_shape:[P],pads:j?Array.from(A.subarray(j>>>0,ee>>>0)):[],strides:[_e],w_is_const:()=>!!W[ue>>>0],activation:Qe(me),activation_params:ke?Array.from(te.subarray(ke>>>0,ze>>>0)):[]})},942563:(h,w,x,C,P,j,ee,_e,se,ue,me,ke,ze,z,ge,Ce)=>{i.sa("Conv",h,{format:ke?"NHWC":"NCHW",auto_pad:w,dilations:[x,C],group:P,kernel_shape:[j,ee],pads:_e?Array.from(A.subarray(_e>>>0,se>>>0)):[],strides:[ue,me],w_is_const:()=>!!W[ze>>>0],activation:Qe(z),activation_params:ge?Array.from(te.subarray(ge>>>0,Ce>>>0)):[]})},942954:h=>{i.Ta(h)},942988:(h,w)=>i.Ua(h,w,i.Ea.Va,i.Ea.errors)};function Et(h){this.name="ExitStatus",this.message=`Program terminated with exit(${h})`,this.status=h}function Kr(h){this.Ja=h-24,this.Oa=function(w){q[this.Ja+4>>>2>>>0]=w},this.Na=function(w){q[this.Ja+8>>>2>>>0]=w},this.$a=function(w,x){this.Ma(),this.Oa(w),this.Na(x)},this.Ma=function(){q[this.Ja+16>>>2>>>0]=0}}var tn=0,qn=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,pn=(h,w,x)=>{w>>>=0;var C=w+x;for(x=w;h[x]&&!(x>=C);)++x;if(16<x-w&&h.buffer&&qn)return qn.decode(h.subarray(w,x));for(C="";w<x;){var P=h[w++];if(P&128){var j=h[w++]&63;if((P&224)==192)C+=String.fromCharCode((P&31)<<6|j);else{var ee=h[w++]&63;P=(P&240)==224?(P&15)<<12|j<<6|ee:(P&7)<<18|j<<12|ee<<6|h[w++]&63,65536>P?C+=String.fromCharCode(P):(P-=65536,C+=String.fromCharCode(55296|P>>10,56320|P&1023))}}else C+=String.fromCharCode(P)}return C},Qe=(h,w)=>(h>>>=0)?pn(X,h,w):"",kn=h=>{for(var w=0,x=0;x<h.length;++x){var C=h.charCodeAt(x);127>=C?w++:2047>=C?w+=2:55296<=C&&57343>=C?(w+=4,++x):w+=3}return w},jn=(h,w,x,C)=>{if(x>>>=0,!(0<C))return 0;var P=x;C=x+C-1;for(var j=0;j<h.length;++j){var ee=h.charCodeAt(j);if(55296<=ee&&57343>=ee){var _e=h.charCodeAt(++j);ee=65536+((ee&1023)<<10)|_e&1023}if(127>=ee){if(x>=C)break;w[x++>>>0]=ee}else{if(2047>=ee){if(x+1>=C)break;w[x++>>>0]=192|ee>>6}else{if(65535>=ee){if(x+2>=C)break;w[x++>>>0]=224|ee>>12}else{if(x+3>=C)break;w[x++>>>0]=240|ee>>18,w[x++>>>0]=128|ee>>12&63}w[x++>>>0]=128|ee>>6&63}w[x++>>>0]=128|ee&63}}return w[x>>>0]=0,x-P},Yt=h=>h%4===0&&(h%100!==0||h%400===0),Yr=[0,31,60,91,121,152,182,213,244,274,305,335],Xt=[0,31,59,90,120,151,181,212,243,273,304,334],Tn=h=>{var w=kn(h)+1,x=On(w);return x&&jn(h,X,x,w),x},hn=[],Cn=(h,w)=>{hn.length=0;for(var x;x=X[h++>>>0];){var C=x!=105;C&=x!=112,w+=C&&w%8?4:0,hn.push(x==112?q[w>>>2>>>0]:x==105?A[w>>>2>>>0]:K[w>>>3>>>0]),w+=C?8:4}return hn},In={},Nt=()=>{if(!An){var h={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:d||"./this.program"},w;for(w in In)In[w]===void 0?delete h[w]:h[w]=In[w];var x=[];for(w in h)x.push(`${w}=${h[w]}`);An=x}return An},An,Xr=[null,[],[]],nt=[31,29,31,30,31,30,31,31,30,31,30,31],Qr=[31,28,31,30,31,30,31,31,30,31,30,31];function Ue(h){var w=Array(kn(h)+1);return jn(h,w,0,w.length),w}function Kn(h,w,x,C){function P(z,ge,Ce){for(z=typeof z=="number"?z.toString():z||"";z.length<ge;)z=Ce[0]+z;return z}function j(z,ge){return P(z,ge,"0")}function ee(z,ge){function Ce(ia){return 0>ia?-1:0<ia?1:0}var Ft;return(Ft=Ce(z.getFullYear()-ge.getFullYear()))===0&&(Ft=Ce(z.getMonth()-ge.getMonth()))===0&&(Ft=Ce(z.getDate()-ge.getDate())),Ft}function _e(z){switch(z.getDay()){case 0:return new Date(z.getFullYear()-1,11,29);case 1:return z;case 2:return new Date(z.getFullYear(),0,3);case 3:return new Date(z.getFullYear(),0,2);case 4:return new Date(z.getFullYear(),0,1);case 5:return new Date(z.getFullYear()-1,11,31);case 6:return new Date(z.getFullYear()-1,11,30)}}function se(z){var ge=z.Ca;for(z=new Date(new Date(z.Da+1900,0,1).getTime());0<ge;){var Ce=z.getMonth(),Ft=(Yt(z.getFullYear())?nt:Qr)[Ce];if(ge>Ft-z.getDate())ge-=Ft-z.getDate()+1,z.setDate(1),11>Ce?z.setMonth(Ce+1):(z.setMonth(0),z.setFullYear(z.getFullYear()+1));else{z.setDate(z.getDate()+ge);break}}return Ce=new Date(z.getFullYear()+1,0,4),ge=_e(new Date(z.getFullYear(),0,4)),Ce=_e(Ce),0>=ee(ge,z)?0>=ee(Ce,z)?z.getFullYear()+1:z.getFullYear():z.getFullYear()-1}h>>>=0,w>>>=0,x>>>=0,C>>>=0;var ue=q[C+40>>>2>>>0];C={Ya:A[C>>>2>>>0],Xa:A[C+4>>>2>>>0],Ga:A[C+8>>>2>>>0],Ka:A[C+12>>>2>>>0],Ha:A[C+16>>>2>>>0],Da:A[C+20>>>2>>>0],xa:A[C+24>>>2>>>0],Ca:A[C+28>>>2>>>0],bb:A[C+32>>>2>>>0],Wa:A[C+36>>>2>>>0],Za:ue?Qe(ue):""},x=Qe(x),ue={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var me in ue)x=x.replace(new RegExp(me,"g"),ue[me]);var ke="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),ze="January February March April May June July August September October November December".split(" ");ue={"%a":z=>ke[z.xa].substring(0,3),"%A":z=>ke[z.xa],"%b":z=>ze[z.Ha].substring(0,3),"%B":z=>ze[z.Ha],"%C":z=>j((z.Da+1900)/100|0,2),"%d":z=>j(z.Ka,2),"%e":z=>P(z.Ka,2," "),"%g":z=>se(z).toString().substring(2),"%G":z=>se(z),"%H":z=>j(z.Ga,2),"%I":z=>(z=z.Ga,z==0?z=12:12<z&&(z-=12),j(z,2)),"%j":z=>{for(var ge=0,Ce=0;Ce<=z.Ha-1;ge+=(Yt(z.Da+1900)?nt:Qr)[Ce++]);return j(z.Ka+ge,3)},"%m":z=>j(z.Ha+1,2),"%M":z=>j(z.Xa,2),"%n":()=>`
`,"%p":z=>0<=z.Ga&&12>z.Ga?"AM":"PM","%S":z=>j(z.Ya,2),"%t":()=>"	","%u":z=>z.xa||7,"%U":z=>j(Math.floor((z.Ca+7-z.xa)/7),2),"%V":z=>{var ge=Math.floor((z.Ca+7-(z.xa+6)%7)/7);if(2>=(z.xa+371-z.Ca-2)%7&&ge++,ge)ge==53&&(Ce=(z.xa+371-z.Ca)%7,Ce==4||Ce==3&&Yt(z.Da)||(ge=1));else{ge=52;var Ce=(z.xa+7-z.Ca-1)%7;(Ce==4||Ce==5&&Yt(z.Da%400-1))&&ge++}return j(ge,2)},"%w":z=>z.xa,"%W":z=>j(Math.floor((z.Ca+7-(z.xa+6)%7)/7),2),"%y":z=>(z.Da+1900).toString().substring(2),"%Y":z=>z.Da+1900,"%z":z=>{z=z.Wa;var ge=0<=z;return z=Math.abs(z)/60,(ge?"+":"-")+("0000"+(z/60*100+z%60)).slice(-4)},"%Z":z=>z.Za,"%%":()=>"%"},x=x.replace(/%%/g,"\0\0");for(me in ue)x.includes(me)&&(x=x.replace(new RegExp(me,"g"),ue[me](C)));return x=x.replace(/\0\0/g,"%"),me=Ue(x),me.length>w?0:(W.set(me,h>>>0),me.length-1)}var nn=h=>{try{h()}catch(w){V(w)}};function Yn(){var h=pe,w={};for(let[x,C]of Object.entries(h))w[x]=typeof C=="function"?function(){fe.push(x);try{return C.apply(null,arguments)}finally{F||(fe.pop(),ft&&Lt===1&&fe.length===0&&(Lt=0,nn(ir),typeof Fibers<"u"&&Fibers.cb()))}}:C;return w}var Lt=0,ft=null,Zr=0,fe=[],fn={},Xn={},ti=0,Mn=null,Jr=[];function ea(){return new Promise((h,w)=>{Mn={resolve:h,reject:w}})}function ta(){var h=On(65548),w=h+12;q[h>>>2>>>0]=w,q[h+4>>>2>>>0]=w+65536,w=fe[0];var x=fn[w];return x===void 0&&(x=ti++,fn[w]=x,Xn[x]=w),A[h+8>>>2>>>0]=x,h}function na(h){if(!F){if(Lt===0){var w=!1,x=!1;h((C=0)=>{if(!F&&(Zr=C,w=!0,x)){Lt=2,nn(()=>sr(ft)),typeof Browser<"u"&&Browser.Ia.Pa&&Browser.Ia.resume(),C=!1;try{var P=(0,pe[Xn[A[ft+8>>>2>>>0]]])()}catch(_e){P=_e,C=!0}var j=!1;if(!ft){var ee=Mn;ee&&(Mn=null,(C?ee.reject:ee.resolve)(P),j=!0)}if(C&&!j)throw P}}),x=!0,w||(Lt=1,ft=ta(),typeof Browser<"u"&&Browser.Ia.Pa&&Browser.Ia.pause(),nn(()=>ar(ft)))}else Lt===2?(Lt=0,nn(or),Jn(ft),ft=null,Jr.forEach(C=>{if(!F)try{C();try{L=L=C=L,i.onExit?.(C),F=!0,p(C,new Et(C))}catch(P){P instanceof Et||P=="unwind"||p(1,P)}}catch(P){P instanceof Et||P=="unwind"||p(1,P)}})):V(`invalid state: ${Lt}`);return Zr}}function Qn(h){return na(w=>{h().then(w)})}var ra={n:function(h,w,x){return Qn(async()=>{await i.Ra(h,w,x)})},a:function(h,w,x){throw h>>>=0,new Kr(h).$a(w>>>0,x>>>0),tn=h,tn},g:function(){return 0},J:function(){},A:function(){},C:function(){},L:function(){return 0},H:function(){},D:function(){},G:function(){},l:function(){},B:function(){},y:function(){},I:function(){},z:function(){},m:()=>1,q:function(h,w,x){h=w+2097152>>>0<4194305-!!h?(h>>>0)+4294967296*w:NaN,x>>>=0,h=new Date(1e3*h),A[x>>>2>>>0]=h.getUTCSeconds(),A[x+4>>>2>>>0]=h.getUTCMinutes(),A[x+8>>>2>>>0]=h.getUTCHours(),A[x+12>>>2>>>0]=h.getUTCDate(),A[x+16>>>2>>>0]=h.getUTCMonth(),A[x+20>>>2>>>0]=h.getUTCFullYear()-1900,A[x+24>>>2>>>0]=h.getUTCDay(),A[x+28>>>2>>>0]=(h.getTime()-Date.UTC(h.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},r:function(h,w,x){h=w+2097152>>>0<4194305-!!h?(h>>>0)+4294967296*w:NaN,x>>>=0,h=new Date(1e3*h),A[x>>>2>>>0]=h.getSeconds(),A[x+4>>>2>>>0]=h.getMinutes(),A[x+8>>>2>>>0]=h.getHours(),A[x+12>>>2>>>0]=h.getDate(),A[x+16>>>2>>>0]=h.getMonth(),A[x+20>>>2>>>0]=h.getFullYear()-1900,A[x+24>>>2>>>0]=h.getDay(),A[x+28>>>2>>>0]=(Yt(h.getFullYear())?Yr:Xt)[h.getMonth()]+h.getDate()-1|0,A[x+36>>>2>>>0]=-(60*h.getTimezoneOffset()),w=new Date(h.getFullYear(),6,1).getTimezoneOffset();var C=new Date(h.getFullYear(),0,1).getTimezoneOffset();A[x+32>>>2>>>0]=(w!=C&&h.getTimezoneOffset()==Math.min(C,w))|0},s:function(h){h>>>=0;var w=new Date(A[h+20>>>2>>>0]+1900,A[h+16>>>2>>>0],A[h+12>>>2>>>0],A[h+8>>>2>>>0],A[h+4>>>2>>>0],A[h>>>2>>>0],0),x=A[h+32>>>2>>>0],C=w.getTimezoneOffset(),P=new Date(w.getFullYear(),6,1).getTimezoneOffset(),j=new Date(w.getFullYear(),0,1).getTimezoneOffset(),ee=Math.min(j,P);return 0>x?A[h+32>>>2>>>0]=+(P!=j&&ee==C):0<x!=(ee==C)&&(P=Math.max(j,P),w.setTime(w.getTime()+6e4*((0<x?ee:P)-C))),A[h+24>>>2>>>0]=w.getDay(),A[h+28>>>2>>>0]=(Yt(w.getFullYear())?Yr:Xt)[w.getMonth()]+w.getDate()-1|0,A[h>>>2>>>0]=w.getSeconds(),A[h+4>>>2>>>0]=w.getMinutes(),A[h+8>>>2>>>0]=w.getHours(),A[h+12>>>2>>>0]=w.getDate(),A[h+16>>>2>>>0]=w.getMonth(),A[h+20>>>2>>>0]=w.getYear(),h=w.getTime(),isNaN(h)?(A[Zn()>>>2>>>0]=61,h=-1):h/=1e3,er((tt=h,1<=+Math.abs(tt)?0<tt?+Math.floor(tt/4294967296)>>>0:~~+Math.ceil((tt-+(~~tt>>>0))/4294967296)>>>0:0)),h>>>0},o:function(){return-52},p:function(){},w:function(h,w,x){function C(se){return(se=se.toTimeString().match(/\(([A-Za-z ]+)\)$/))?se[1]:"GMT"}x>>>=0;var P=new Date().getFullYear(),j=new Date(P,0,1),ee=new Date(P,6,1);P=j.getTimezoneOffset();var _e=ee.getTimezoneOffset();q[h>>>0>>>2>>>0]=60*Math.max(P,_e),A[w>>>0>>>2>>>0]=+(P!=_e),h=C(j),w=C(ee),h=Tn(h),w=Tn(w),_e<P?(q[x>>>2>>>0]=h,q[x+4>>>2>>>0]=w):(q[x>>>2>>>0]=w,q[x+4>>>2>>>0]=h)},e:()=>{V("")},b:function(h,w,x){return h>>>=0,w=Cn(w>>>0,x>>>0),vt[h].apply(null,w)},i:function(h,w,x){return h>>>=0,w=Cn(w>>>0,x>>>0),vt[h].apply(null,w)},h:()=>Date.now(),x:function(){return 4294901760},c:()=>performance.now(),K:function(h,w,x){return w>>>=0,X.copyWithin(h>>>0>>>0,w>>>0,w+(x>>>0)>>>0)},u:function(h){h>>>=0;var w=X.length;if(4294901760<h)return!1;for(var x=1;4>=x;x*=2){var C=w*(1+.2/x);C=Math.min(C,h+100663296);var P=Math;C=Math.max(h,C);e:{P=(P.min.call(P,4294901760,C+(65536-C%65536)%65536)-M.buffer.byteLength+65535)/65536;try{M.grow(P),B();var j=1;break e}catch{}j=void 0}if(j)return!0}return!1},E:function(h,w){h>>>=0,w>>>=0;var x=0;return Nt().forEach((C,P)=>{var j=w+x;for(P=q[h+4*P>>>2>>>0]=j,j=0;j<C.length;++j)W[P++>>>0>>>0]=C.charCodeAt(j);W[P>>>0>>>0]=0,x+=C.length+1}),0},F:function(h,w){h>>>=0,w>>>=0;var x=Nt();q[h>>>2>>>0]=x.length;var C=0;return x.forEach(P=>C+=P.length+1),q[w>>>2>>>0]=C,0},f:()=>52,k:function(){return 52},t:function(){return 70},j:function(h,w,x,C){w>>>=0,x>>>=0,C>>>=0;for(var P=0,j=0;j<x;j++){var ee=q[w>>>2>>>0],_e=q[w+4>>>2>>>0];w+=8;for(var se=0;se<_e;se++){var ue=X[ee+se>>>0],me=Xr[h];ue===0||ue===10?((h===1?E:I)(pn(me,0)),me.length=0):me.push(ue)}P+=_e}return q[C>>>2>>>0]=P,0},v:Kn,d:function(h,w,x,C){return Kn(h>>>0,w>>>0,x>>>0,C>>>0)}},pe=function(){function h(x){return pe=x.exports,pe=Yn(),pe=aa(),M=pe.M,B(),G.unshift(pe.N),oe--,oe==0&&ye&&(x=ye,ye=null,x()),pe}var w={a:ra};if(oe++,i.instantiateWasm)try{return i.instantiateWasm(w,h)}catch(x){I(`Module.instantiateWasm callback failed with error: ${x}`),o(x)}return Ve(w,function(x){h(x.instance)}).catch(o),{}}();i._OrtInit=(h,w)=>(i._OrtInit=pe.O)(h,w),i._OrtGetLastError=(h,w)=>(i._OrtGetLastError=pe.P)(h,w),i._OrtCreateSessionOptions=(h,w,x,C,P,j,ee,_e,se,ue)=>(i._OrtCreateSessionOptions=pe.Q)(h,w,x,C,P,j,ee,_e,se,ue),i._OrtAppendExecutionProvider=(h,w)=>(i._OrtAppendExecutionProvider=pe.R)(h,w),i._OrtAddFreeDimensionOverride=(h,w,x)=>(i._OrtAddFreeDimensionOverride=pe.S)(h,w,x),i._OrtAddSessionConfigEntry=(h,w,x)=>(i._OrtAddSessionConfigEntry=pe.T)(h,w,x),i._OrtReleaseSessionOptions=h=>(i._OrtReleaseSessionOptions=pe.U)(h),i._OrtCreateSession=(h,w,x)=>(i._OrtCreateSession=pe.V)(h,w,x),i._OrtReleaseSession=h=>(i._OrtReleaseSession=pe.W)(h),i._OrtGetInputOutputCount=(h,w,x)=>(i._OrtGetInputOutputCount=pe.X)(h,w,x),i._OrtGetInputName=(h,w)=>(i._OrtGetInputName=pe.Y)(h,w),i._OrtGetOutputName=(h,w)=>(i._OrtGetOutputName=pe.Z)(h,w),i._OrtFree=h=>(i._OrtFree=pe._)(h),i._OrtCreateTensor=(h,w,x,C,P,j)=>(i._OrtCreateTensor=pe.$)(h,w,x,C,P,j),i._OrtGetTensorData=(h,w,x,C,P)=>(i._OrtGetTensorData=pe.aa)(h,w,x,C,P),i._OrtReleaseTensor=h=>(i._OrtReleaseTensor=pe.ba)(h),i._OrtCreateRunOptions=(h,w,x,C)=>(i._OrtCreateRunOptions=pe.ca)(h,w,x,C),i._OrtAddRunConfigEntry=(h,w,x)=>(i._OrtAddRunConfigEntry=pe.da)(h,w,x),i._OrtReleaseRunOptions=h=>(i._OrtReleaseRunOptions=pe.ea)(h),i._OrtCreateBinding=h=>(i._OrtCreateBinding=pe.fa)(h),i._OrtBindInput=(h,w,x)=>(i._OrtBindInput=pe.ga)(h,w,x),i._OrtBindOutput=(h,w,x,C)=>(i._OrtBindOutput=pe.ha)(h,w,x,C),i._OrtClearBoundOutputs=h=>(i._OrtClearBoundOutputs=pe.ia)(h),i._OrtReleaseBinding=h=>(i._OrtReleaseBinding=pe.ja)(h),i._OrtRunWithBinding=(h,w,x,C,P)=>(i._OrtRunWithBinding=pe.ka)(h,w,x,C,P),i._OrtRun=(h,w,x,C,P,j,ee,_e)=>(i._OrtRun=pe.la)(h,w,x,C,P,j,ee,_e),i._OrtEndProfiling=h=>(i._OrtEndProfiling=pe.ma)(h),i._JsepOutput=(h,w,x)=>(i._JsepOutput=pe.na)(h,w,x),i._JsepGetNodeName=h=>(i._JsepGetNodeName=pe.oa)(h);var Zn=()=>(Zn=pe.pa)(),On=i._malloc=h=>(On=i._malloc=pe.qa)(h),Jn=i._free=h=>(Jn=i._free=pe.ra)(h),er=h=>(er=pe.ta)(h),tr=()=>(tr=pe.ua)(),nr=h=>(nr=pe.va)(h),rr=h=>(rr=pe.wa)(h),ar=h=>(ar=pe.ya)(h),ir=()=>(ir=pe.za)(),sr=h=>(sr=pe.Aa)(h),or=()=>(or=pe.Ba)();i.___start_em_js=943100,i.___stop_em_js=943261;function aa(){var h=pe;h=Object.assign({},h);var w=C=>()=>C()>>>0,x=C=>P=>C(P)>>>0;return h.pa=w(h.pa),h.qa=x(h.qa),h.ua=w(h.ua),h.wa=x(h.wa),h}i.stackAlloc=rr,i.stackSave=tr,i.stackRestore=nr,i.UTF8ToString=Qe,i.stringToUTF8=(h,w,x)=>jn(h,X,w,x),i.lengthBytesUTF8=kn;var rn;ye=function h(){rn||mn(),rn||(ye=h)};function mn(){if(!(0<oe)){if(i.preRun)for(typeof i.preRun=="function"&&(i.preRun=[i.preRun]);i.preRun.length;){var h=i.preRun.shift();U.unshift(h)}for(;0<U.length;)U.shift()(i);if(!(0<oe||rn||(rn=!0,i.calledRun=!0,F))){for(;0<G.length;)G.shift()(i);for(s(i);0<ne.length;)ne.shift()(i)}}}return mn(),a.ready}})();typeof t=="object"&&typeof e=="object"?e.exports=n:typeof define=="function"&&define.amd&&define([],()=>n)}),xg=Un(()=>{}),Sg=Un(()=>{}),nc={};Wn(nc,{cpus:()=>rc});var rc,Eg=Y(()=>{rc=void 0}),kg=Un((t,e)=>{var n=(()=>{var r=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(r=r||__filename),function(a={}){function i(){return U.buffer!=ye.buffer&&We(),ye}function s(){return U.buffer!=ye.buffer&&We(),V}function o(){return U.buffer!=ye.buffer&&We(),ie}function l(){return U.buffer!=ye.buffer&&We(),$e}function d(){return U.buffer!=ye.buffer&&We(),Le}function p(){return U.buffer!=ye.buffer&&We(),Pe}var u=a,f,m;u.ready=new Promise((c,g)=>{f=c,m=g}),u.mountExternalData=(c,g)=>{(u.cb||(u.cb=new Map)).set(c,g)},u.unmountExternalData=()=>{delete u.cb},u.jsepInit=(c,g,y,k,O,N,H,he)=>{u.Mb=c,u.wb=g,u.yb=y,u.kb=k,u.xb=O,u.Ea=N,u.zb=H,u.Ab=he,g=(de,ce,we)=>(...Oe)=>{let De=Ut,R=ce?.();Oe=de(...Oe);let ve=ce?.();return R!==ve&&(de=ve,we(R),ce=we=null),Ut!=De?zm():Oe},y=de=>async(...ce)=>{try{if(u.bb)throw Error("Session already started");let we=u.bb={Cb:ce[0],errors:[]},Oe=await de(...ce);if(u.bb!==we)throw Error("Session mismatch");c.flush();let De=we.errors;if(0<De.length){let R=await Promise.all(De);if(R=R.filter(ve=>ve),0<R.length)throw Error(R.join(`
`))}return Oe}finally{u.bb=null}},u._OrtRun=y(g(u._OrtRun,()=>u._OrtRun,de=>u._OrtRun=de)),u._OrtRunWithBinding=y(g(u._OrtRunWithBinding,()=>u._OrtRunWithBinding,de=>u._OrtRunWithBinding=de)),u._OrtBindInput=g(u._OrtBindInput,()=>u._OrtBindInput,de=>u._OrtBindInput=de),u.jsepRegisterBuffer=(de,ce,we,Oe)=>c.registerBuffer(de,ce,we,Oe),u.jsepUnregisterBuffers=de=>{c.unregisterBuffers(de)},u.jsepGetBuffer=de=>c.getBuffer(de),u.jsepCreateDownloader=(de,ce,we)=>c.createDownloader(de,ce,we)};var _=Object.assign({},u),v="./this.program",$=(c,g)=>{throw g},b=typeof window=="object",S=typeof importScripts=="function",T=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",E=u.ENVIRONMENT_IS_PTHREAD||!1,I="";function M(c){return u.locateFile?u.locateFile(c,I):I+c}var F,L,W;if(T){var X=(Jd(),$n(gs)),A=(tc(),$n(_s));I=S?A.dirname(I)+"/":__dirname+"/",F=(g,y)=>(g=pn(g)?new URL(g):A.normalize(g),X.readFileSync(g,y?void 0:"utf8")),W=g=>(g=F(g,!0),g.buffer||(g=new Uint8Array(g)),g),L=(g,y,k,O=!0)=>{g=pn(g)?new URL(g):A.normalize(g),X.readFile(g,O?void 0:"utf8",(N,H)=>{N?k(N):y(O?H.buffer:H)})},!u.thisProgram&&1<process.argv.length&&(v=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),$=(g,y)=>{throw process.exitCode=g,y},u.inspect=()=>"[Emscripten Module object]";let c;try{c=xg()}catch(g){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),g}global.Worker=c.Worker}else(b||S)&&(S?I=self.location.href:typeof document<"u"&&document.currentScript&&(I=document.currentScript.src),typeof r<"u"&&r&&(I=r),I.indexOf("blob:")!==0?I=I.substr(0,I.replace(/[?#].*/,"").lastIndexOf("/")+1):I="",T||(F=c=>{var g=new XMLHttpRequest;return g.open("GET",c,!1),g.send(null),g.responseText},S&&(W=c=>{var g=new XMLHttpRequest;return g.open("GET",c,!1),g.responseType="arraybuffer",g.send(null),new Uint8Array(g.response)}),L=(c,g,y)=>{var k=new XMLHttpRequest;k.open("GET",c,!0),k.responseType="arraybuffer",k.onload=()=>{k.status==200||k.status==0&&k.response?g(k.response):y()},k.onerror=y,k.send(null)}));T&&typeof performance>"u"&&(global.performance=Sg().performance);var q=console.log.bind(console),te=console.error.bind(console);T&&(q=(...c)=>X.writeSync(1,c.join(" ")+`
`),te=(...c)=>X.writeSync(2,c.join(" ")+`
`));var K=q,B=te;Object.assign(u,_),_=null,typeof WebAssembly!="object"&&tn("no native wasm support detected");var U,G,ne=!1,oe,ye,V,ie,$e,Le,Pe;function We(){var c=U.buffer;u.HEAP8=ye=new Int8Array(c),u.HEAP16=new Int16Array(c),u.HEAPU8=V=new Uint8Array(c),u.HEAPU16=new Uint16Array(c),u.HEAP32=ie=new Int32Array(c),u.HEAPU32=$e=new Uint32Array(c),u.HEAPF32=Le=new Float32Array(c),u.HEAPF64=Pe=new Float64Array(c)}var ht=16777216;if(E)U=u.wasmMemory;else if(u.wasmMemory)U=u.wasmMemory;else if(U=new WebAssembly.Memory({initial:ht/65536,maximum:65536,shared:!0}),!(U.buffer instanceof SharedArrayBuffer))throw B("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),T&&B("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");We(),ht=U.buffer.byteLength;var Fe=[],Ve=[],tt=[],vt=0,Et=null;function Kr(){if(vt--,vt==0&&Et){var c=Et;Et=null,c()}}function tn(c){throw c="Aborted("+c+")",B(c),ne=!0,oe=1,c=new WebAssembly.RuntimeError(c+". Build with -sASSERTIONS for more info."),m(c),c}var qn=c=>c.startsWith("data:application/octet-stream;base64,"),pn=c=>c.startsWith("file://"),Qe;Qe="ort-wasm-simd-threaded.wasm",qn(Qe)||(Qe=M(Qe));function kn(c){if(W)return W(c);throw"both async and sync fetching of the wasm failed"}function jn(c){if(b||S){if(typeof fetch=="function"&&!pn(c))return fetch(c,{credentials:"same-origin"}).then(g=>{if(!g.ok)throw"failed to load wasm binary file at '"+c+"'";return g.arrayBuffer()}).catch(()=>kn(c));if(L)return new Promise((g,y)=>{L(c,k=>g(new Uint8Array(k)),y)})}return Promise.resolve().then(()=>kn(c))}function Yt(c,g,y){return jn(c).then(k=>WebAssembly.instantiate(k,g)).then(k=>k).then(y,k=>{B(`failed to asynchronously prepare wasm: ${k}`),tn(k)})}function Yr(c,g){var y=Qe;return typeof WebAssembly.instantiateStreaming!="function"||qn(y)||pn(y)||T||typeof fetch!="function"?Yt(y,c,g):fetch(y,{credentials:"same-origin"}).then(k=>WebAssembly.instantiateStreaming(k,c).then(g,function(O){return B(`wasm streaming compile failed: ${O}`),B("falling back to ArrayBuffer instantiation"),Yt(y,c,g)}))}var Xt,Tn={932428:(c,g,y,k)=>{if(typeof u>"u"||!u.cb)return 1;if(c=nt(c>>>0),c.startsWith("./")&&(c=c.substring(2)),c=u.cb.get(c),!c)return 2;if(g>>>=0,y>>>=0,k>>>=0,g+y>c.byteLength)return 3;try{return s().set(c.subarray(g,g+y),k>>>0),0}catch{return 4}},932929:c=>u.wb(c),932962:c=>u.yb(c),932994:(c,g,y)=>{u.kb(c,g,y,!0)},933033:(c,g,y)=>{u.kb(c,g,y)},933066:c=>{u.Ea("Abs",c,void 0)},933117:c=>{u.Ea("Neg",c,void 0)},933168:c=>{u.Ea("Floor",c,void 0)},933221:c=>{u.Ea("Ceil",c,void 0)},933273:c=>{u.Ea("Reciprocal",c,void 0)},933331:c=>{u.Ea("Sqrt",c,void 0)},933383:c=>{u.Ea("Exp",c,void 0)},933434:c=>{u.Ea("Erf",c,void 0)},933485:c=>{u.Ea("Sigmoid",c,void 0)},933540:c=>{u.Ea("Log",c,void 0)},933591:c=>{u.Ea("Sin",c,void 0)},933642:c=>{u.Ea("Cos",c,void 0)},933693:c=>{u.Ea("Tan",c,void 0)},933744:c=>{u.Ea("Asin",c,void 0)},933796:c=>{u.Ea("Acos",c,void 0)},933848:c=>{u.Ea("Atan",c,void 0)},933900:c=>{u.Ea("Sinh",c,void 0)},933952:c=>{u.Ea("Cosh",c,void 0)},934004:c=>{u.Ea("Asinh",c,void 0)},934057:c=>{u.Ea("Acosh",c,void 0)},934110:c=>{u.Ea("Atanh",c,void 0)},934163:c=>{u.Ea("Tanh",c,void 0)},934215:c=>{u.Ea("Not",c,void 0)},934266:(c,g,y)=>{u.Ea("Clip",c,{min:g,max:y})},934335:c=>{u.Ea("Clip",c,void 0)},934387:(c,g)=>{u.Ea("Elu",c,{alpha:g})},934445:c=>{u.Ea("Relu",c,void 0)},934497:(c,g)=>{u.Ea("LeakyRelu",c,{alpha:g})},934561:(c,g)=>{u.Ea("ThresholdedRelu",c,{alpha:g})},934631:(c,g)=>{u.Ea("Cast",c,{to:g})},934689:c=>{u.Ea("Add",c,void 0)},934740:c=>{u.Ea("Sub",c,void 0)},934791:c=>{u.Ea("Mul",c,void 0)},934842:c=>{u.Ea("Div",c,void 0)},934893:c=>{u.Ea("Pow",c,void 0)},934944:c=>{u.Ea("Equal",c,void 0)},934997:c=>{u.Ea("Greater",c,void 0)},935052:c=>{u.Ea("GreaterOrEqual",c,void 0)},935114:c=>{u.Ea("Less",c,void 0)},935166:c=>{u.Ea("LessOrEqual",c,void 0)},935225:(c,g,y,k,O)=>{u.Ea("ReduceMean",c,{keepDims:!!g,noopWithEmptyAxes:!!y,axes:k?Array.from(o().subarray(k>>>0,O>>>0)):[]})},935384:(c,g,y,k,O)=>{u.Ea("ReduceMax",c,{keepDims:!!g,noopWithEmptyAxes:!!y,axes:k?Array.from(o().subarray(k>>>0,O>>>0)):[]})},935542:(c,g,y,k,O)=>{u.Ea("ReduceMin",c,{keepDims:!!g,noopWithEmptyAxes:!!y,axes:k?Array.from(o().subarray(k>>>0,O>>>0)):[]})},935700:(c,g,y,k,O)=>{u.Ea("ReduceProd",c,{keepDims:!!g,noopWithEmptyAxes:!!y,axes:k?Array.from(o().subarray(k>>>0,O>>>0)):[]})},935859:(c,g,y,k,O)=>{u.Ea("ReduceSum",c,{keepDims:!!g,noopWithEmptyAxes:!!y,axes:k?Array.from(o().subarray(k>>>0,O>>>0)):[]})},936017:(c,g,y,k,O)=>{u.Ea("ReduceL1",c,{keepDims:!!g,noopWithEmptyAxes:!!y,axes:k?Array.from(o().subarray(k>>>0,O>>>0)):[]})},936174:(c,g,y,k,O)=>{u.Ea("ReduceL2",c,{keepDims:!!g,noopWithEmptyAxes:!!y,axes:k?Array.from(o().subarray(k>>>0,O>>>0)):[]})},936331:(c,g,y,k,O)=>{u.Ea("ReduceLogSum",c,{keepDims:!!g,noopWithEmptyAxes:!!y,axes:k?Array.from(o().subarray(k>>>0,O>>>0)):[]})},936492:(c,g,y,k,O)=>{u.Ea("ReduceSumSquare",c,{keepDims:!!g,noopWithEmptyAxes:!!y,axes:k?Array.from(o().subarray(k>>>0,O>>>0)):[]})},936656:(c,g,y,k,O)=>{u.Ea("ReduceLogSumExp",c,{keepDims:!!g,noopWithEmptyAxes:!!y,axes:k?Array.from(o().subarray(k>>>0,O>>>0)):[]})},936820:c=>{u.Ea("Where",c,void 0)},936873:(c,g,y)=>{u.Ea("Transpose",c,{perm:g?Array.from(o().subarray(g>>>0,y>>>0)):[]})},936981:(c,g,y,k,O,N,H,he,de,ce,we,Oe,De,R,ve)=>{u.Ea("ConvTranspose",c,{format:de?"NHWC":"NCHW",autoPad:g,dilations:[y],group:k,kernel_shape:[O],pads:[N,H],strides:[he],wIsConst:()=>!!i()[ce>>>0],outputPadding:we?Array.from(o().subarray(we>>>0,Oe>>>0)):[],outputShape:De?Array.from(o().subarray(De>>>0,R>>>0)):[],activation:nt(ve)})},937383:(c,g,y,k,O,N,H,he,de,ce,we,Oe,De,R)=>{u.Ea("ConvTranspose",c,{format:he?"NHWC":"NCHW",autoPad:g,dilations:Array.from(o().subarray(y>>>0,(y>>>0)+2>>>0)),group:k,kernelShape:Array.from(o().subarray(O>>>0,(O>>>0)+2>>>0)),pads:Array.from(o().subarray(N>>>0,(N>>>0)+4>>>0)),strides:Array.from(o().subarray(H>>>0,(H>>>0)+2>>>0)),wIsConst:()=>!!i()[de>>>0],outputPadding:ce?Array.from(o().subarray(ce>>>0,we>>>0)):[],outputShape:Oe?Array.from(o().subarray(Oe>>>0,De>>>0)):[],activation:nt(R)})},937948:(c,g,y,k,O,N,H,he,de,ce,we,Oe,De,R,ve)=>{u.Ea("ConvTranspose",c,{format:de?"NHWC":"NCHW",autoPad:g,dilations:[y],group:k,kernel_shape:[O],pads:[N,H],strides:[he],wIsConst:()=>!!i()[ce>>>0],outputPadding:we?Array.from(o().subarray(we>>>0,Oe>>>0)):[],outputShape:De?Array.from(o().subarray(De>>>0,R>>>0)):[],activation:nt(ve)})},938350:(c,g,y,k,O,N,H,he,de,ce,we,Oe,De,R)=>{u.Ea("ConvTranspose",c,{format:he?"NHWC":"NCHW",autoPad:g,dilations:Array.from(o().subarray(y>>>0,(y>>>0)+2>>>0)),group:k,kernelShape:Array.from(o().subarray(O>>>0,(O>>>0)+2>>>0)),pads:Array.from(o().subarray(N>>>0,(N>>>0)+4>>>0)),strides:Array.from(o().subarray(H>>>0,(H>>>0)+2>>>0)),wIsConst:()=>!!i()[de>>>0],outputPadding:ce?Array.from(o().subarray(ce>>>0,we>>>0)):[],outputShape:Oe?Array.from(o().subarray(Oe>>>0,De>>>0)):[],activation:nt(R)})},938915:(c,g)=>{u.Ea("GlobalAveragePool",c,{format:g?"NHWC":"NCHW"})},939006:(c,g,y,k,O,N,H,he,de,ce,we,Oe,De,R,ve,Re)=>{u.Ea("AveragePool",c,{format:Re?"NHWC":"NCHW",auto_pad:g,ceil_mode:y,count_include_pad:k,storage_order:O,dilations:[N,H],kernel_shape:[he,de],pads:[ce,we,Oe,De],strides:[R,ve]})},939290:(c,g)=>{u.Ea("GlobalAveragePool",c,{format:g?"NHWC":"NCHW"})},939381:(c,g,y,k,O,N,H,he,de,ce,we,Oe,De,R,ve,Re)=>{u.Ea("AveragePool",c,{format:Re?"NHWC":"NCHW",auto_pad:g,ceil_mode:y,count_include_pad:k,storage_order:O,dilations:[N,H],kernel_shape:[he,de],pads:[ce,we,Oe,De],strides:[R,ve]})},939665:(c,g)=>{u.Ea("GlobalMaxPool",c,{format:g?"NHWC":"NCHW"})},939752:(c,g,y,k,O,N,H,he,de,ce,we,Oe,De,R,ve,Re)=>{u.Ea("MaxPool",c,{format:Re?"NHWC":"NCHW",auto_pad:g,ceil_mode:y,count_include_pad:k,storage_order:O,dilations:[N,H],kernel_shape:[he,de],pads:[ce,we,Oe,De],strides:[R,ve]})},940032:(c,g)=>{u.Ea("GlobalMaxPool",c,{format:g?"NHWC":"NCHW"})},940119:(c,g,y,k,O,N,H,he,de,ce,we,Oe,De,R,ve,Re)=>{u.Ea("MaxPool",c,{format:Re?"NHWC":"NCHW",auto_pad:g,ceil_mode:y,count_include_pad:k,storage_order:O,dilations:[N,H],kernel_shape:[he,de],pads:[ce,we,Oe,De],strides:[R,ve]})},940399:(c,g,y,k,O)=>{u.Ea("Gemm",c,{alpha:g,beta:y,transA:k,transB:O})},940503:c=>{u.Ea("MatMul",c,void 0)},940557:(c,g,y,k)=>{u.Ea("ArgMax",c,{keepDims:!!g,selectLastIndex:!!y,axis:k})},940665:(c,g,y,k)=>{u.Ea("ArgMin",c,{keepDims:!!g,selectLastIndex:!!y,axis:k})},940773:(c,g)=>{u.Ea("Softmax",c,{axis:g})},940836:(c,g)=>{u.Ea("Concat",c,{axis:g})},940896:(c,g,y,k,O)=>{u.Ea("Split",c,{axis:g,numOutputs:y,splitSizes:k?Array.from(o().subarray(k>>>0,O>>>0)):[]})},941036:c=>{u.Ea("Expand",c,void 0)},941090:(c,g)=>{u.Ea("Gather",c,{axis:Number(g)})},941161:(c,g)=>{u.Ea("GatherElements",c,{axis:Number(g)})},941240:(c,g,y,k,O,N,H,he,de,ce,we)=>{u.Ea("Resize",c,{antialias:g,axes:y?Array.from(o().subarray(y>>>0,k>>>0)):[],coordinateTransformMode:nt(O),cubicCoeffA:N,excludeOutside:H,extrapolationValue:he,keepAspectRatioPolicy:nt(de),mode:nt(ce),nearestMode:nt(we)})},941586:(c,g,y,k,O,N,H)=>{u.Ea("Slice",c,{starts:g?Array.from(o().subarray(g>>>0,y>>>0)):[],ends:k?Array.from(o().subarray(k>>>0,O>>>0)):[],axes:N?Array.from(o().subarray(N>>>0,H>>>0)):[]})},941802:c=>{u.Ea("Tile",c,void 0)},941854:(c,g,y)=>{u.Ea("LayerNormalization",c,{axis:Number(g),epsilon:Number(y)})},941961:(c,g,y)=>{u.Ea("InstanceNormalization",c,{epsilon:g,format:y?"NHWC":"NCHW"})},942075:(c,g,y)=>{u.Ea("InstanceNormalization",c,{epsilon:g,format:y?"NHWC":"NCHW"})},942189:c=>{u.Ea("Range",c,void 0)},942242:(c,g)=>{u.Ea("Einsum",c,{equation:nt(g)})},942323:(c,g,y,k,O)=>{u.Ea("Pad",c,{mode:g,value:y,pads:k?Array.from(o().subarray(k>>>0,O>>>0)):[]})},942450:(c,g,y,k,O,N)=>{u.Ea("BatchNormalization",c,{epsilon:g,momentum:y,spatial:!!O,trainingMode:!!k,format:N?"NHWC":"NCHW"})},942619:(c,g,y,k,O,N)=>{u.Ea("BatchNormalization",c,{epsilon:g,momentum:y,spatial:!!O,trainingMode:!!k,format:N?"NHWC":"NCHW"})},942788:(c,g,y)=>{u.Ea("CumSum",c,{exclusive:Number(g),reverse:Number(y)})},942885:(c,g,y,k,O,N,H,he,de)=>{u.Ea("Attention",c,{numHeads:g,isUnidirectional:y,maskFilterValue:k,scale:O,doRotary:N,qkvHiddenSizes:H?Array.from(o().subarray(Number(he)>>>0,Number(he)+H>>>0)):[],pastPresentShareBuffer:!!de})},943157:c=>{u.Ea("Gelu",c,void 0)},943209:(c,g,y,k,O,N)=>{u.Ea("MultiHeadAttention",c,{numHeads:g,isUnidirectional:y,maskFilterValue:k,scale:O,doRotary:N})},943368:c=>{u.Ea("BiasAdd",c,void 0)},943423:c=>{u.Ea("BiasSplitGelu",c,void 0)},943484:(c,g)=>{u.Ea("SkipLayerNormalization",c,{epsilon:g})},943565:(c,g,y,k,O,N,H,he,de,ce,we,Oe,De)=>{u.Ea("Conv",c,{format:de?"NHWC":"NCHW",auto_pad:g,dilations:[y],group:k,kernel_shape:[O],pads:N?Array.from(o().subarray(N>>>0,H>>>0)):[],strides:[he],w_is_const:()=>!!i()[ce>>>0],activation:nt(we),activation_params:Oe?Array.from(d().subarray(Oe>>>0,De>>>0)):[]})},943935:(c,g,y,k,O,N,H,he,de,ce,we,Oe,De,R,ve,Re)=>{u.Ea("Conv",c,{format:Oe?"NHWC":"NCHW",auto_pad:g,dilations:[y,k],group:O,kernel_shape:[N,H],pads:he?Array.from(o().subarray(he>>>0,de>>>0)):[],strides:[ce,we],w_is_const:()=>!!i()[De>>>0],activation:nt(R),activation_params:ve?Array.from(d().subarray(ve>>>0,Re>>>0)):[]})},944326:c=>{u.zb(c)},944360:(c,g)=>u.Ab(c,g,u.bb.Cb,u.bb.errors)};function hn(c){this.name="ExitStatus",this.message=`Program terminated with exit(${c})`,this.status=c}var Cn=c=>{c.terminate(),c.onmessage=()=>{}},In=c=>{fe.Ya.length==0&&(ft(),fe.lb(fe.Ya[0]));var g=fe.Ya.pop();if(!g)return 6;fe.Za.push(g),fe.Qa[c.Xa]=g,g.Xa=c.Xa;var y={cmd:"run",start_routine:c.Db,arg:c.tb,pthread_ptr:c.Xa};return T&&g.unref(),g.postMessage(y,c.Jb),0},Nt=0,An=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Xr=(c,g,y)=>{g>>>=0;var k=g+y;for(y=g;c[y]&&!(y>=k);)++y;if(16<y-g&&c.buffer&&An)return An.decode(c.buffer instanceof SharedArrayBuffer?c.slice(g,y):c.subarray(g,y));for(k="";g<y;){var O=c[g++];if(O&128){var N=c[g++]&63;if((O&224)==192)k+=String.fromCharCode((O&31)<<6|N);else{var H=c[g++]&63;O=(O&240)==224?(O&15)<<12|N<<6|H:(O&7)<<18|N<<12|H<<6|c[g++]&63,65536>O?k+=String.fromCharCode(O):(O-=65536,k+=String.fromCharCode(55296|O>>10,56320|O&1023))}}else k+=String.fromCharCode(O)}return k},nt=(c,g)=>(c>>>=0)?Xr(s(),c,g):"",Qr=c=>{var g=si();return c=c(),ua(g),c};function Ue(c,g){var y=arguments.length-2,k=arguments;return Qr(()=>{for(var O=oi(8*y),N=O>>>3,H=0;H<y;H++){var he=k[2+H];p()[N+H>>>0]=he}return to(c,y,O,g)})}function Kn(c){if(E)return Ue(0,1,c);oe=c,0<Nt||(fe.Eb(),u.onExit?.(c),ne=!0),$(c,new hn(c))}var nn=c=>{if(oe=c,E)throw Xn(c),"unwind";Kn(c)},Yn=c=>{c instanceof hn||c=="unwind"||$(1,c)};function Lt(){for(var c=u.numThreads;c--;)ft();Fe.unshift(()=>{vt++,Zr(()=>Kr())})}function ft(){var c=M("ort-wasm-simd-threaded.worker.js");c=new Worker(c),fe.Ya.push(c)}function Zr(c){E?c():Promise.all(fe.Ya.map(fe.lb)).then(c)}var fe={Ya:[],Za:[],pb:[],Qa:{},hb(){E?(fe.receiveObjectTransfer=fe.Bb,fe.threadInitTLS=fe.ob,fe.setExitStatus=fe.nb):Lt()},nb:c=>oe=c,Nb:["$terminateWorker"],Eb:()=>{for(var c of fe.Za)Cn(c);for(c of fe.Ya)Cn(c);fe.Ya=[],fe.Za=[],fe.Qa=[]},mb:c=>{var g=c.Xa;delete fe.Qa[g],fe.Ya.push(c),fe.Za.splice(fe.Za.indexOf(c),1),c.Xa=0,ai(g)},Bb(){},ob(){fe.pb.forEach(c=>c())},lb:c=>new Promise(g=>{c.onmessage=N=>{N=N.data;var H=N.cmd;if(N.targetThread&&N.targetThread!=la()){var he=fe.Qa[N.targetThread];he?he.postMessage(N,N.transferList):B(`Internal error! Worker sent a message "${H}" to target pthread ${N.targetThread}, but that thread no longer exists!`)}else H==="checkMailbox"?mn():H==="spawnThread"?In(N):H==="cleanupThread"?fe.mb(fe.Qa[N.thread]):H==="killThread"?(N=N.thread,H=fe.Qa[N],delete fe.Qa[N],Cn(H),ai(N),fe.Za.splice(fe.Za.indexOf(H),1),H.Xa=0):H==="cancelThread"?fe.Qa[N.thread].postMessage({cmd:"cancel"}):H==="loaded"?(c.loaded=!0,T&&!c.Xa&&c.unref(),g(c)):H==="alert"?alert(`Thread ${N.threadId}: ${N.text}`):N.target==="setimmediate"?c.postMessage(N):H==="callHandler"?u[N.handler](...N.args):H&&B(`worker sent an unknown command ${H}`)},c.onerror=N=>{throw B(`worker sent an error! ${N.filename}:${N.lineno}: ${N.message}`),N},T&&(c.on("message",N=>c.onmessage({data:N})),c.on("error",N=>c.onerror(N)));var y=[],k=["onExit"],O;for(O of k)u.hasOwnProperty(O)&&y.push(O);c.postMessage({cmd:"load",handlers:y,urlOrBlob:u.mainScriptUrlOrBlob||r,wasmMemory:U,wasmModule:G})})};u.PThread=fe;var fn=c=>{for(;0<c.length;)c.shift()(u)};u.establishStackSpace=()=>{var c=la(),g=l()[c+52>>>2>>>0];c=l()[c+56>>>2>>>0],ao(g,g-c),ua(g)};function Xn(c){if(E)return Ue(1,0,c);nn(c)}u.invokeEntryPoint=(c,g)=>{c=io.apply(null,[c,g]),0<Nt?fe.nb(c):ii(c)};function ti(c){this.gb=c-24,this.sb=function(g){l()[this.gb+4>>>2>>>0]=g},this.rb=function(g){l()[this.gb+8>>>2>>>0]=g},this.hb=function(g,y){this.qb(),this.sb(g),this.rb(y)},this.qb=function(){l()[this.gb+16>>>2>>>0]=0}}var Mn=0;function Jr(c,g,y,k){return E?Ue(2,1,c,g,y,k):ea(c,g,y,k)}function ea(c,g,y,k){if(c>>>=0,g>>>=0,y>>>=0,k>>>=0,typeof SharedArrayBuffer>"u")return B("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var O=[];return E&&O.length===0?Jr(c,g,y,k):(c={Db:y,Xa:c,tb:k,Jb:O},E?(c.Lb="spawnThread",postMessage(c,O),0):In(c))}function ta(c,g,y){return E?Ue(3,1,c,g,y):0}function na(c,g){if(E)return Ue(4,1,c,g)}var Qn=c=>{for(var g=0,y=0;y<c.length;++y){var k=c.charCodeAt(y);127>=k?g++:2047>=k?g+=2:55296<=k&&57343>=k?(g+=4,++y):g+=3}return g},ra=(c,g,y,k)=>{if(y>>>=0,!(0<k))return 0;var O=y;k=y+k-1;for(var N=0;N<c.length;++N){var H=c.charCodeAt(N);if(55296<=H&&57343>=H){var he=c.charCodeAt(++N);H=65536+((H&1023)<<10)|he&1023}if(127>=H){if(y>=k)break;g[y++>>>0]=H}else{if(2047>=H){if(y+1>=k)break;g[y++>>>0]=192|H>>6}else{if(65535>=H){if(y+2>=k)break;g[y++>>>0]=224|H>>12}else{if(y+3>=k)break;g[y++>>>0]=240|H>>18,g[y++>>>0]=128|H>>12&63}g[y++>>>0]=128|H>>6&63}g[y++>>>0]=128|H&63}}return g[y>>>0]=0,y-O},pe=(c,g,y)=>ra(c,s(),g,y);function Zn(c,g){if(E)return Ue(5,1,c,g)}function On(c,g,y){if(E)return Ue(6,1,c,g,y)}function Jn(c,g,y){return E?Ue(7,1,c,g,y):0}function er(c,g){if(E)return Ue(8,1,c,g)}function tr(c,g,y){if(E)return Ue(9,1,c,g,y)}function nr(c,g,y,k){if(E)return Ue(10,1,c,g,y,k)}function rr(c,g,y,k){if(E)return Ue(11,1,c,g,y,k)}function ar(c,g,y,k){if(E)return Ue(12,1,c,g,y,k)}function ir(c){if(E)return Ue(13,1,c)}function sr(c,g){if(E)return Ue(14,1,c,g)}function or(c,g,y){if(E)return Ue(15,1,c,g,y)}var aa=()=>{if(!(0<Nt))try{E?ii(oe):nn(oe)}catch(c){Yn(c)}};function rn(c){c>>>=0,typeof Atomics.Kb=="function"&&(Atomics.Kb(o(),c>>>2,c).value.then(mn),c+=128,Atomics.store(o(),c>>>2,1))}u.__emscripten_thread_mailbox_await=rn;var mn=()=>{var c=la();if(c&&(rn(c),!ne))try{no(),aa()}catch(g){Yn(g)}};u.checkMailbox=mn;var h=[],w=c=>c%4===0&&(c%100!==0||c%400===0),x=[0,31,60,91,121,152,182,213,244,274,305,335],C=[0,31,59,90,120,151,181,212,243,273,304,334];function P(c,g,y,k,O,N,H,he){return E?Ue(16,1,c,g,y,k,O,N,H,he):-52}function j(c,g,y,k,O,N,H){if(E)return Ue(17,1,c,g,y,k,O,N,H)}var ee=c=>{var g=Qn(c)+1,y=ri(g);return y&&pe(c,y,g),y},_e=[],se=(c,g)=>{_e.length=0;for(var y;y=s()[c++>>>0];){var k=y!=105;k&=y!=112,g+=k&&g%8?4:0,_e.push(y==112?l()[g>>>2>>>0]:y==105?o()[g>>>2>>>0]:p()[g>>>3>>>0]),g+=k?8:4}return _e},ue={},me=()=>{if(!ke){var c={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:v||"./this.program"},g;for(g in ue)ue[g]===void 0?delete c[g]:c[g]=ue[g];var y=[];for(g in c)y.push(`${g}=${c[g]}`);ke=y}return ke},ke;function ze(c,g){if(E)return Ue(18,1,c,g);c>>>=0,g>>>=0;var y=0;return me().forEach((k,O)=>{var N=g+y;for(O=l()[c+4*O>>>2>>>0]=N,N=0;N<k.length;++N)i()[O++>>>0>>>0]=k.charCodeAt(N);i()[O>>>0>>>0]=0,y+=k.length+1}),0}function z(c,g){if(E)return Ue(19,1,c,g);c>>>=0,g>>>=0;var y=me();l()[c>>>2>>>0]=y.length;var k=0;return y.forEach(O=>k+=O.length+1),l()[g>>>2>>>0]=k,0}function ge(c){return E?Ue(20,1,c):52}function Ce(c,g,y,k){return E?Ue(21,1,c,g,y,k):52}function Ft(c,g,y,k,O){return E?Ue(22,1,c,g,y,k,O):70}var ia=[null,[],[]];function Hs(c,g,y,k){if(E)return Ue(23,1,c,g,y,k);g>>>=0,y>>>=0,k>>>=0;for(var O=0,N=0;N<y;N++){var H=l()[g>>>2>>>0],he=l()[g+4>>>2>>>0];g+=8;for(var de=0;de<he;de++){var ce=s()[H+de>>>0],we=ia[c];ce===0||ce===10?((c===1?K:B)(Xr(we,0)),we.length=0):we.push(ce)}O+=he}return l()[k>>>2>>>0]=O,0}var qs=[31,29,31,30,31,30,31,31,30,31,30,31],js=[31,28,31,30,31,30,31,31,30,31,30,31];function Cm(c){var g=Array(Qn(c)+1);return ra(c,g,0,g.length),g}var Im=(c,g)=>{i().set(c,g>>>0)};function Ks(c,g,y,k){function O(R,ve,Re){for(R=typeof R=="number"?R.toString():R||"";R.length<ve;)R=Re[0]+R;return R}function N(R,ve){return O(R,ve,"0")}function H(R,ve){function Re(po){return 0>po?-1:0<po?1:0}var gn;return(gn=Re(R.getFullYear()-ve.getFullYear()))===0&&(gn=Re(R.getMonth()-ve.getMonth()))===0&&(gn=Re(R.getDate()-ve.getDate())),gn}function he(R){switch(R.getDay()){case 0:return new Date(R.getFullYear()-1,11,29);case 1:return R;case 2:return new Date(R.getFullYear(),0,3);case 3:return new Date(R.getFullYear(),0,2);case 4:return new Date(R.getFullYear(),0,1);case 5:return new Date(R.getFullYear()-1,11,31);case 6:return new Date(R.getFullYear()-1,11,30)}}function de(R){var ve=R.$a;for(R=new Date(new Date(R.ab+1900,0,1).getTime());0<ve;){var Re=R.getMonth(),gn=(w(R.getFullYear())?qs:js)[Re];if(ve>gn-R.getDate())ve-=gn-R.getDate()+1,R.setDate(1),11>Re?R.setMonth(Re+1):(R.setMonth(0),R.setFullYear(R.getFullYear()+1));else{R.setDate(R.getDate()+ve);break}}return Re=new Date(R.getFullYear()+1,0,4),ve=he(new Date(R.getFullYear(),0,4)),Re=he(Re),0>=H(ve,R)?0>=H(Re,R)?R.getFullYear()+1:R.getFullYear():R.getFullYear()-1}c>>>=0,g>>>=0,y>>>=0,k>>>=0;var ce=l()[k+40>>>2>>>0];k={Hb:o()[k>>>2>>>0],Gb:o()[k+4>>>2>>>0],eb:o()[k+8>>>2>>>0],jb:o()[k+12>>>2>>>0],fb:o()[k+16>>>2>>>0],ab:o()[k+20>>>2>>>0],Wa:o()[k+24>>>2>>>0],$a:o()[k+28>>>2>>>0],Ob:o()[k+32>>>2>>>0],Fb:o()[k+36>>>2>>>0],Ib:ce?nt(ce):""},y=nt(y),ce={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var we in ce)y=y.replace(new RegExp(we,"g"),ce[we]);var Oe="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),De="January February March April May June July August September October November December".split(" ");ce={"%a":R=>Oe[R.Wa].substring(0,3),"%A":R=>Oe[R.Wa],"%b":R=>De[R.fb].substring(0,3),"%B":R=>De[R.fb],"%C":R=>N((R.ab+1900)/100|0,2),"%d":R=>N(R.jb,2),"%e":R=>O(R.jb,2," "),"%g":R=>de(R).toString().substring(2),"%G":R=>de(R),"%H":R=>N(R.eb,2),"%I":R=>(R=R.eb,R==0?R=12:12<R&&(R-=12),N(R,2)),"%j":R=>{for(var ve=0,Re=0;Re<=R.fb-1;ve+=(w(R.ab+1900)?qs:js)[Re++]);return N(R.jb+ve,3)},"%m":R=>N(R.fb+1,2),"%M":R=>N(R.Gb,2),"%n":()=>`
`,"%p":R=>0<=R.eb&&12>R.eb?"AM":"PM","%S":R=>N(R.Hb,2),"%t":()=>"	","%u":R=>R.Wa||7,"%U":R=>N(Math.floor((R.$a+7-R.Wa)/7),2),"%V":R=>{var ve=Math.floor((R.$a+7-(R.Wa+6)%7)/7);if(2>=(R.Wa+371-R.$a-2)%7&&ve++,ve)ve==53&&(Re=(R.Wa+371-R.$a)%7,Re==4||Re==3&&w(R.ab)||(ve=1));else{ve=52;var Re=(R.Wa+7-R.$a-1)%7;(Re==4||Re==5&&w(R.ab%400-1))&&ve++}return N(ve,2)},"%w":R=>R.Wa,"%W":R=>N(Math.floor((R.$a+7-(R.Wa+6)%7)/7),2),"%y":R=>(R.ab+1900).toString().substring(2),"%Y":R=>R.ab+1900,"%z":R=>{R=R.Fb;var ve=0<=R;return R=Math.abs(R)/60,(ve?"+":"-")+("0000"+(R/60*100+R%60)).slice(-4)},"%Z":R=>R.Ib,"%%":()=>"%"},y=y.replace(/%%/g,"\0\0");for(we in ce)y.includes(we)&&(y=y.replace(new RegExp(we,"g"),ce[we](k)));return y=y.replace(/\0\0/g,"%"),we=Cm(y),we.length>g?0:(Im(we,c),we.length-1)}var sa=c=>{try{c()}catch(g){tn(g)}};function Am(){var c=ae,g={};for(let[y,k]of Object.entries(c))g[y]=typeof k=="function"?function(){oa.push(y);try{return k.apply(null,arguments)}finally{ne||(oa.pop(),Ut&&an===1&&oa.length===0&&(an=0,Nt+=1,sa(oo),typeof Fibers<"u"&&Fibers.Pb()))}}:k;return g}var an=0,Ut=null,Ys=0,oa=[],Xs={},Qs={},Mm=0,ni=null,Om=[];function zm(){return new Promise((c,g)=>{ni={resolve:c,reject:g}})}function Rm(){var c=ri(65548),g=c+12;l()[c>>>2>>>0]=g,l()[c+4>>>2>>>0]=g+65536,g=oa[0];var y=Xs[g];return y===void 0&&(y=Mm++,Xs[g]=y,Qs[y]=g),g=y,o()[c+8>>>2>>>0]=g,c}function Bm(){var c=o()[Ut+8>>>2>>>0];return c=ae[Qs[c]],--Nt,c()}function Pm(c){if(!ne){if(an===0){var g=!1,y=!1;c((k=0)=>{if(!ne&&(Ys=k,g=!0,y)){an=2,sa(()=>lo(Ut)),typeof Browser<"u"&&Browser.ib.vb&&Browser.ib.resume(),k=!1;try{var O=Bm()}catch(he){O=he,k=!0}var N=!1;if(!Ut){var H=ni;H&&(ni=null,(k?H.reject:H.resolve)(O),N=!0)}if(k&&!N)throw O}}),y=!0,g||(an=1,Ut=Rm(),typeof Browser<"u"&&Browser.ib.vb&&Browser.ib.pause(),sa(()=>so(Ut)))}else an===2?(an=0,sa(uo),Js(Ut),Ut=null,Om.forEach(k=>{if(!ne)try{k(),aa()}catch(O){Yn(O)}})):tn(`invalid state: ${an}`);return Ys}}function Dm(c){return Pm(g=>{c().then(g)})}fe.hb();var Nm=[Kn,Xn,Jr,ta,na,Zn,On,Jn,er,tr,nr,rr,ar,ir,sr,or,P,j,ze,z,ge,Ce,Ft,Hs],Lm={r:function(c,g,y){return Dm(async()=>{await u.xb(c,g,y)})},b:function(c,g,y){throw c>>>=0,new ti(c).hb(g>>>0,y>>>0),Mn=c,Mn},N:function(c){eo(c>>>0,!S,1,!b,131072,!1),fe.ob()},l:function(c){c>>>=0,E?postMessage({cmd:"cleanupThread",thread:c}):fe.mb(fe.Qa[c])},J:ea,i:ta,T:na,F:Zn,H:On,U:Jn,R:er,L:tr,Q:nr,p:rr,G:ar,D:ir,S:sr,E:or,q:()=>1,B:function(c,g){c>>>=0,c==g>>>0?setTimeout(()=>mn()):E?postMessage({targetThread:c,cmd:"checkMailbox"}):(c=fe.Qa[c])&&c.postMessage({cmd:"checkMailbox"})},K:function(c,g,y,k){g>>>=0,h.length=y,k=k>>>0>>>3;for(var O=0;O<y;O++)h[O]=p()[k+O>>>0];return c=0>c?Tn[-c-1]:Nm[c],fe.ub=g,g=c.apply(null,h),fe.ub=0,g},M:rn,W:function(c){T&&fe.Qa[c>>>0].ref()},u:function(c,g,y){c=g+2097152>>>0<4194305-!!c?(c>>>0)+4294967296*g:NaN,y>>>=0,c=new Date(1e3*c),o()[y>>>2>>>0]=c.getUTCSeconds(),o()[y+4>>>2>>>0]=c.getUTCMinutes(),o()[y+8>>>2>>>0]=c.getUTCHours(),o()[y+12>>>2>>>0]=c.getUTCDate(),o()[y+16>>>2>>>0]=c.getUTCMonth(),o()[y+20>>>2>>>0]=c.getUTCFullYear()-1900,o()[y+24>>>2>>>0]=c.getUTCDay(),c=(c.getTime()-Date.UTC(c.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,o()[y+28>>>2>>>0]=c},v:function(c,g,y){c=g+2097152>>>0<4194305-!!c?(c>>>0)+4294967296*g:NaN,y>>>=0,c=new Date(1e3*c),o()[y>>>2>>>0]=c.getSeconds(),o()[y+4>>>2>>>0]=c.getMinutes(),o()[y+8>>>2>>>0]=c.getHours(),o()[y+12>>>2>>>0]=c.getDate(),o()[y+16>>>2>>>0]=c.getMonth(),o()[y+20>>>2>>>0]=c.getFullYear()-1900,o()[y+24>>>2>>>0]=c.getDay(),g=(w(c.getFullYear())?x:C)[c.getMonth()]+c.getDate()-1|0,o()[y+28>>>2>>>0]=g,o()[y+36>>>2>>>0]=-(60*c.getTimezoneOffset()),g=new Date(c.getFullYear(),6,1).getTimezoneOffset();var k=new Date(c.getFullYear(),0,1).getTimezoneOffset();c=(g!=k&&c.getTimezoneOffset()==Math.min(k,g))|0,o()[y+32>>>2>>>0]=c},w:function(c){c>>>=0;var g=new Date(o()[c+20>>>2>>>0]+1900,o()[c+16>>>2>>>0],o()[c+12>>>2>>>0],o()[c+8>>>2>>>0],o()[c+4>>>2>>>0],o()[c>>>2>>>0],0),y=o()[c+32>>>2>>>0],k=g.getTimezoneOffset(),O=new Date(g.getFullYear(),6,1).getTimezoneOffset(),N=new Date(g.getFullYear(),0,1).getTimezoneOffset(),H=Math.min(N,O);return 0>y?o()[c+32>>>2>>>0]=+(O!=N&&H==k):0<y!=(H==k)&&(O=Math.max(N,O),g.setTime(g.getTime()+6e4*((0<y?H:O)-k))),o()[c+24>>>2>>>0]=g.getDay(),y=(w(g.getFullYear())?x:C)[g.getMonth()]+g.getDate()-1|0,o()[c+28>>>2>>>0]=y,o()[c>>>2>>>0]=g.getSeconds(),o()[c+4>>>2>>>0]=g.getMinutes(),o()[c+8>>>2>>>0]=g.getHours(),o()[c+12>>>2>>>0]=g.getDate(),o()[c+16>>>2>>>0]=g.getMonth(),o()[c+20>>>2>>>0]=g.getYear(),c=g.getTime(),isNaN(c)?(o()[Zs()>>>2>>>0]=61,c=-1):c/=1e3,ro((Xt=c,1<=+Math.abs(Xt)?0<Xt?+Math.floor(Xt/4294967296)>>>0:~~+Math.ceil((Xt-+(~~Xt>>>0))/4294967296)>>>0:0)),c>>>0},s:P,t:j,A:function(c,g,y){function k(ce){return(ce=ce.toTimeString().match(/\(([A-Za-z ]+)\)$/))?ce[1]:"GMT"}c>>>=0,g>>>=0,y>>>=0;var O=new Date().getFullYear(),N=new Date(O,0,1),H=new Date(O,6,1);O=N.getTimezoneOffset();var he=H.getTimezoneOffset(),de=Math.max(O,he);l()[c>>>2>>>0]=60*de,o()[g>>>2>>>0]=+(O!=he),c=k(N),g=k(H),c=ee(c),g=ee(g),he<O?(l()[y>>>2>>>0]=c,l()[y+4>>>2>>>0]=g):(l()[y>>>2>>>0]=g,l()[y+4>>>2>>>0]=c)},d:()=>{tn("")},c:function(c,g,y){return c>>>=0,g=se(g>>>0,y>>>0),Tn[c].apply(null,g)},k:function(c,g,y){return c>>>=0,g=se(g>>>0,y>>>0),Tn[c].apply(null,g)},m:()=>{},j:()=>Date.now(),V:()=>{throw Nt+=1,"unwind"},C:function(){return 4294901760},f:()=>performance.timeOrigin+performance.now(),g:()=>T?(Eg(),$n(nc)).cpus().length:navigator.hardwareConcurrency,y:function(c){c>>>=0;var g=s().length;if(c<=g||4294901760<c)return!1;for(var y=1;4>=y;y*=2){var k=g*(1+.2/y);k=Math.min(k,c+100663296);var O=Math;k=Math.max(c,k);e:{O=(O.min.call(O,4294901760,k+(65536-k%65536)%65536)-U.buffer.byteLength+65535)/65536;try{U.grow(O),We();var N=1;break e}catch{}N=void 0}if(N)return!0}return!1},O:ze,P:z,I:nn,h:ge,o:Ce,x:Ft,n:Hs,a:U||u.wasmMemory,z:Ks,e:function(c,g,y,k){return Ks(c>>>0,g>>>0,y>>>0,k>>>0)}},ae=function(){function c(y,k){return ae=y.exports,ae=Am(),ae=Fm(),fe.pb.push(ae.Da),Ve.unshift(ae.X),G=k,Kr(),ae}var g={a:Lm};if(vt++,u.instantiateWasm)try{return u.instantiateWasm(g,c)}catch(y){B(`Module.instantiateWasm callback failed with error: ${y}`),m(y)}return Yr(g,function(y){c(y.instance,y.module)}).catch(m),{}}();u._OrtInit=(c,g)=>(u._OrtInit=ae.Y)(c,g),u._OrtGetLastError=(c,g)=>(u._OrtGetLastError=ae.Z)(c,g),u._OrtCreateSessionOptions=(c,g,y,k,O,N,H,he,de,ce)=>(u._OrtCreateSessionOptions=ae._)(c,g,y,k,O,N,H,he,de,ce),u._OrtAppendExecutionProvider=(c,g)=>(u._OrtAppendExecutionProvider=ae.$)(c,g),u._OrtAddFreeDimensionOverride=(c,g,y)=>(u._OrtAddFreeDimensionOverride=ae.aa)(c,g,y),u._OrtAddSessionConfigEntry=(c,g,y)=>(u._OrtAddSessionConfigEntry=ae.ba)(c,g,y),u._OrtReleaseSessionOptions=c=>(u._OrtReleaseSessionOptions=ae.ca)(c),u._OrtCreateSession=(c,g,y)=>(u._OrtCreateSession=ae.da)(c,g,y),u._OrtReleaseSession=c=>(u._OrtReleaseSession=ae.ea)(c),u._OrtGetInputOutputCount=(c,g,y)=>(u._OrtGetInputOutputCount=ae.fa)(c,g,y),u._OrtGetInputName=(c,g)=>(u._OrtGetInputName=ae.ga)(c,g),u._OrtGetOutputName=(c,g)=>(u._OrtGetOutputName=ae.ha)(c,g),u._OrtFree=c=>(u._OrtFree=ae.ia)(c),u._OrtCreateTensor=(c,g,y,k,O,N)=>(u._OrtCreateTensor=ae.ja)(c,g,y,k,O,N),u._OrtGetTensorData=(c,g,y,k,O)=>(u._OrtGetTensorData=ae.ka)(c,g,y,k,O),u._OrtReleaseTensor=c=>(u._OrtReleaseTensor=ae.la)(c),u._OrtCreateRunOptions=(c,g,y,k)=>(u._OrtCreateRunOptions=ae.ma)(c,g,y,k),u._OrtAddRunConfigEntry=(c,g,y)=>(u._OrtAddRunConfigEntry=ae.na)(c,g,y),u._OrtReleaseRunOptions=c=>(u._OrtReleaseRunOptions=ae.oa)(c),u._OrtCreateBinding=c=>(u._OrtCreateBinding=ae.pa)(c),u._OrtBindInput=(c,g,y)=>(u._OrtBindInput=ae.qa)(c,g,y),u._OrtBindOutput=(c,g,y,k)=>(u._OrtBindOutput=ae.ra)(c,g,y,k),u._OrtClearBoundOutputs=c=>(u._OrtClearBoundOutputs=ae.sa)(c),u._OrtReleaseBinding=c=>(u._OrtReleaseBinding=ae.ta)(c),u._OrtRunWithBinding=(c,g,y,k,O)=>(u._OrtRunWithBinding=ae.ua)(c,g,y,k,O),u._OrtRun=(c,g,y,k,O,N,H,he)=>(u._OrtRun=ae.va)(c,g,y,k,O,N,H,he),u._OrtEndProfiling=c=>(u._OrtEndProfiling=ae.wa)(c),u._JsepOutput=(c,g,y)=>(u._JsepOutput=ae.xa)(c,g,y),u._JsepGetNodeName=c=>(u._JsepGetNodeName=ae.ya)(c);var Zs=()=>(Zs=ae.za)(),la=u._pthread_self=()=>(la=u._pthread_self=ae.Aa)(),ri=u._malloc=c=>(ri=u._malloc=ae.Ba)(c),Js=u._free=c=>(Js=u._free=ae.Ca)(c);u.__emscripten_tls_init=()=>(u.__emscripten_tls_init=ae.Da)();var eo=u.__emscripten_thread_init=(c,g,y,k,O,N)=>(eo=u.__emscripten_thread_init=ae.Fa)(c,g,y,k,O,N);u.__emscripten_thread_crashed=()=>(u.__emscripten_thread_crashed=ae.Ga)();var to=(c,g,y,k)=>(to=ae.Ha)(c,g,y,k),ai=c=>(ai=ae.Ia)(c),ii=u.__emscripten_thread_exit=c=>(ii=u.__emscripten_thread_exit=ae.Ja)(c),no=()=>(no=ae.Ka)(),ro=c=>(ro=ae.La)(c),ao=(c,g)=>(ao=ae.Ma)(c,g),si=()=>(si=ae.Na)(),ua=c=>(ua=ae.Oa)(c),oi=c=>(oi=ae.Pa)(c),io=u.dynCall_ii=(c,g)=>(io=u.dynCall_ii=ae.Ra)(c,g),so=c=>(so=ae.Sa)(c),oo=()=>(oo=ae.Ta)(),lo=c=>(lo=ae.Ua)(c),uo=()=>(uo=ae.Va)();u.___start_em_js=944472,u.___stop_em_js=944633;function Fm(){var c=ae;c=Object.assign({},c);var g=k=>()=>k()>>>0,y=k=>O=>k(O)>>>0;return c.za=g(c.za),c.Aa=g(c.Aa),c.Ba=y(c.Ba),c.emscripten_main_runtime_thread_id=g(c.emscripten_main_runtime_thread_id),c.Na=g(c.Na),c.Pa=y(c.Pa),c}u.wasmMemory=U,u.stackAlloc=oi,u.stackSave=si,u.stackRestore=ua,u.keepRuntimeAlive=()=>0<Nt,u.UTF8ToString=nt,u.stringToUTF8=pe,u.lengthBytesUTF8=Qn,u.ExitStatus=hn,u.PThread=fe;var da;Et=function c(){da||co(),da||(Et=c)};function co(){if(!(0<vt))if(E)f(u),E||fn(Ve),startWorker(u);else{if(u.preRun)for(typeof u.preRun=="function"&&(u.preRun=[u.preRun]);u.preRun.length;)Fe.unshift(u.preRun.shift());fn(Fe),0<vt||da||(da=!0,u.calledRun=!0,ne||(E||fn(Ve),f(u),E||fn(tt)))}}return co(),a.ready}})();typeof t=="object"&&typeof e=="object"?e.exports=n:typeof define=="function"&&define.amd&&define([],()=>n)}),Tg=Un((t,e)=>{e.exports='"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs"),vm=require("vm");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>vm.runInThisContext(fs.readFileSync(e,"utf8"),{filename:e}),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(){var e=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,e+`\n`);return}console.error(e)}function threadAlert(){var e=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:e,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,t)=>{var a=Module.wasmModule;Module.wasmModule=null;var r=new WebAssembly.Instance(a,e);return t(r)},self.onunhandledrejection=e=>{throw e.reason||e};function handleMessage(e){try{if(e.data.cmd==="load"){let a=[];self.onmessage=r=>a.push(r),self.startWorker=r=>{Module=r,postMessage({cmd:"loaded"});for(let s of a)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const r of e.data.handlers)Module[r]=(...s)=>{postMessage({cmd:"callHandler",handler:r,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var t=URL.createObjectURL(e.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(a){if(a!="unwind")throw a}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err(`worker.js received unknown command ${e.data.cmd}`),err(e.data)))}catch(a){throw Module.__emscripten_thread_crashed?.(),a}}self.onmessage=handleMessage;\n'}),go,_o,pi,fa,dr,hi,wo,yo,vo,ac,et,Mr=Y(()=>{go=$g(),_o=kg(),fa=!1,dr=!1,hi=!1,wo=t=>{if(t===1)return!1;if(typeof SharedArrayBuffer>"u")return typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+t+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),!1;typeof process<"u"&&process.versions&&process.versions.node&&console.warn("env.wasm.numThreads is set to "+t+", however, currently onnxruntime-web does not support multi-threads in Node.js. Please consider using onnxruntime-node for performance critical scenarios.");try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},yo=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},vo=(t,e)=>t?e?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":e?"ort-wasm-threaded.wasm":"ort-wasm.wasm",ac=async t=>{if(fa)return Promise.resolve();if(dr)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(hi)throw new Error("previous call to 'initializeWebAssembly()' failed.");dr=!0;let e=t.initTimeout,n=t.numThreads,r=t.simd,a=wo(n),i=r&&yo(),s=t.wasmPaths,o=typeof s=="string"?s:void 0,l=vo(i,a),d=typeof s=="object"?s[l]:void 0,p=!1,u=[];if(e>0&&u.push(new Promise(f=>{setTimeout(()=>{p=!0,f()},e)})),u.push(new Promise((f,m)=>{let _=a?_o:go,v={locateFile:($,b)=>{if(a&&$.endsWith(".worker.js")&&typeof Blob<"u")return URL.createObjectURL(new Blob([Tg()],{type:"text/javascript"}));if($.endsWith(".wasm")){if(d)return d;let S=o??b;return l==="ort-wasm-simd.wasm"?S+"ort-wasm-simd.jsep.wasm":l==="ort-wasm-simd-threaded.wasm"?S+"ort-wasm-simd-threaded.jsep.wasm":S+l}return b+$}};if(a)if(v.numThreads=n,typeof Blob>"u")v.mainScriptUrlOrBlob=(void 0)(__dirname,"ort-wasm-threaded.js");else{let $=`var ortWasmThreaded=${_.toString()};`;v.mainScriptUrlOrBlob=new Blob([$],{type:"text/javascript"})}_(v).then($=>{dr=!1,fa=!0,pi=$,f()},$=>{dr=!1,hi=!0,m($)})})),await Promise.race(u),p)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},et=()=>{if(fa&&pi)return pi;throw new Error("WebAssembly is not initialized yet.")}}),Je,Ia,He,ws=Y(()=>{Mr(),Je=(t,e)=>{let n=et(),r=n.lengthBytesUTF8(t)+1,a=n._malloc(r);return n.stringToUTF8(t,a,r),e.push(a),a},Ia=(t,e,n,r)=>{if(typeof t=="object"&&t!==null){if(n.has(t))throw new Error("Circular reference in options");n.add(t)}Object.entries(t).forEach(([a,i])=>{let s=e?e+a:a;if(typeof i=="object")Ia(i,s+".",n,r);else if(typeof i=="string"||typeof i=="number")r(s,i.toString());else if(typeof i=="boolean")r(s,i?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof i}`)})},He=t=>{let e=et(),n=e.stackSave();try{let r=e.stackAlloc(8);e._OrtGetLastError(r,r+4);let a=e.HEAP32[r/4],i=e.HEAPU32[r/4+1],s=i?e.UTF8ToString(i):"";throw new Error(`${t} ERROR_CODE: ${a}, ERROR_MESSAGE: ${s}`)}finally{e.stackRestore(n)}}}),ic,Cg=Y(()=>{Mr(),ws(),ic=t=>{let e=et(),n=0,r=[],a=t||{};try{if(t?.logSeverityLevel===void 0)a.logSeverityLevel=2;else if(typeof t.logSeverityLevel!="number"||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(t?.logVerbosityLevel===void 0)a.logVerbosityLevel=0;else if(typeof t.logVerbosityLevel!="number"||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);t?.terminate===void 0&&(a.terminate=!1);let i=0;return t?.tag!==void 0&&(i=Je(t.tag,r)),n=e._OrtCreateRunOptions(a.logSeverityLevel,a.logVerbosityLevel,!!a.terminate,i),n===0&&He("Can't create run options."),t?.extra!==void 0&&Ia(t.extra,"",new WeakSet,(s,o)=>{let l=Je(s,r),d=Je(o,r);e._OrtAddRunConfigEntry(n,l,d)!==0&&He(`Can't set a run config entry: ${s} - ${o}.`)}),[n,r]}catch(i){throw n!==0&&e._OrtReleaseRunOptions(n),r.forEach(s=>e._free(s)),i}}}),bo,$o,xo,So,sc,Ig=Y(()=>{Mr(),ws(),bo=t=>{switch(t){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${t}`)}},$o=t=>{switch(t){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${t}`)}},xo=t=>{t.extra||(t.extra={}),t.extra.session||(t.extra.session={});let e=t.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly="1"),t.executionProviders&&t.executionProviders.some(n=>(typeof n=="string"?n:n.name)==="webgpu")&&(t.enableMemPattern=!1)},So=(t,e,n)=>{for(let r of e){let a=typeof r=="string"?r:r.name;switch(a){case"webnn":if(a="WEBNN",typeof r!="string"){let s=r;if(s?.deviceType){let o=Je("deviceType",n),l=Je(s.deviceType,n);et()._OrtAddSessionConfigEntry(t,o,l)!==0&&He(`Can't set a session config entry: 'deviceType' - ${s.deviceType}.`)}if(s?.numThreads){let o=s.numThreads;(typeof o!="number"||!Number.isInteger(o)||o<0)&&(o=0);let l=Je("numThreads",n),d=Je(o.toString(),n);et()._OrtAddSessionConfigEntry(t,l,d)!==0&&He(`Can't set a session config entry: 'numThreads' - ${s.numThreads}.`)}if(s?.powerPreference){let o=Je("powerPreference",n),l=Je(s.powerPreference,n);et()._OrtAddSessionConfigEntry(t,o,l)!==0&&He(`Can't set a session config entry: 'powerPreference' - ${s.powerPreference}.`)}}break;case"webgpu":if(a="JS",typeof r!="string"){let s=r;if(s?.preferredLayout){if(s.preferredLayout!=="NCHW"&&s.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${s.preferredLayout}`);let o=Je("preferredLayout",n),l=Je(s.preferredLayout,n);et()._OrtAddSessionConfigEntry(t,o,l)!==0&&He(`Can't set a session config entry: 'preferredLayout' - ${s.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${a}`)}let i=Je(a,n);et()._OrtAppendExecutionProvider(t,i)!==0&&He(`Can't append execution provider: ${a}.`)}},sc=t=>{let e=et(),n=0,r=[],a=t||{};xo(a);try{let i=bo(a.graphOptimizationLevel??"all"),s=$o(a.executionMode??"sequential"),o=typeof a.logId=="string"?Je(a.logId,r):0,l=a.logSeverityLevel??2;if(!Number.isInteger(l)||l<0||l>4)throw new Error(`log serverity level is not valid: ${l}`);let d=a.logVerbosityLevel??0;if(!Number.isInteger(d)||d<0||d>4)throw new Error(`log verbosity level is not valid: ${d}`);let p=typeof a.optimizedModelFilePath=="string"?Je(a.optimizedModelFilePath,r):0;if(n=e._OrtCreateSessionOptions(i,!!a.enableCpuMemArena,!!a.enableMemPattern,s,!!a.enableProfiling,0,o,l,d,p),n===0&&He("Can't create session options."),a.executionProviders&&So(n,a.executionProviders,r),a.freeDimensionOverrides)for(let[u,f]of Object.entries(a.freeDimensionOverrides)){if(typeof u!="string")throw new Error(`free dimension override name must be a string: ${u}`);if(typeof f!="number"||!Number.isInteger(f)||f<0)throw new Error(`free dimension override value must be a non-negative integer: ${f}`);let m=Je(u,r);e._OrtAddFreeDimensionOverride(n,m,f)!==0&&He(`Can't set a free dimension override: ${u} - ${f}.`)}return a.extra!==void 0&&Ia(a.extra,"",new WeakSet,(u,f)=>{let m=Je(u,r),_=Je(f,r);e._OrtAddSessionConfigEntry(n,m,_)!==0&&He(`Can't set a session config entry: ${u} - ${f}.`)}),[n,r]}catch(i){throw n!==0&&e._OrtReleaseSessionOptions(n),r.forEach(s=>e._free(s)),i}}}),Hi,Vt,Aa,ys,Ma,vs,qi,Ye=Y(()=>{Hi=t=>{switch(t){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${t}`)}},Vt=t=>{switch(t){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${t}`)}},Aa=t=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][t],ys=t=>{switch(t){case"float16":return Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${t}`)}},Ma=t=>{switch(t){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${t}`)}},vs=t=>t==="float32"||t==="int32"||t==="int64"||t==="bool"||t==="float16"||t==="uint32",qi=t=>{switch(t){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${t}`)}}}),Oa,oc=Y(()=>{Oa=async t=>{if(typeof t=="string")if(typeof process<"u"&&process.versions&&process.versions.node)try{return new Uint8Array(await(void 0)(t))}catch(e){if(e.code==="ERR_FS_FILE_TOO_LARGE"){let n=(void 0)(t),r=[];for await(let a of n)r.push(a);return new Uint8Array(Buffer.concat(r))}throw e}else{let e=await fetch(t);if(!e.ok)throw new Error(`failed to load external data file: ${t}`);let n=e.headers.get("Content-Length"),r=n?parseInt(n,10):0;if(r<1073741824)return new Uint8Array(await e.arrayBuffer());{if(!e.body)throw new Error(`failed to load external data file: ${t}, no response body.`);let a=e.body.getReader(),i;try{i=new ArrayBuffer(r)}catch(o){if(o instanceof RangeError){let l=Math.ceil(r/65536);i=new WebAssembly.Memory({initial:l,maximum:l}).buffer}else throw o}let s=0;for(;;){let{done:o,value:l}=await a.read();if(o)break;let d=l.byteLength;new Uint8Array(i,s,d).set(l),s+=d}return new Uint8Array(i,0,r)}}else return t instanceof Blob?new Uint8Array(await t.arrayBuffer()):t instanceof Uint8Array?t:new Uint8Array(t)}}),Eo,ko,To,Co,lc,Io,rt,xn=Y(()=>{Ye(),Eo=["V","I","W","E","F"],ko=(t,e)=>{console.log(`[${Eo[t]},${new Date().toISOString()}]${e}`)},lc=(t,e)=>{To=t,Co=e},Io=(t,e)=>{let n=Ma(t),r=Ma(To);n>=r&&ko(n,typeof e=="function"?e():e)},rt=(...t)=>{Co&&Io(...t)}}),uc,Ag=Y(()=>{Ye(),uc=(t,e)=>new(ys(e))(t)}),bs=Y(()=>{}),cr,Ao,fi,ji,Mo,dc,Mg=Y(()=>{xn(),bs(),cr=t=>Math.ceil(t/16)*16,Ao=1,fi=()=>Ao++,ji=async(t,e,n,r)=>{let a=cr(n),i=t.device.createBuffer({size:a,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let s=t.getCommandEncoder();t.endComputePass(),s.copyBufferToBuffer(e,0,i,0,a),t.flush(),await i.mapAsync(GPUMapMode.READ);let o=i.getMappedRange();if(r){let l=r();return l.set(new Uint8Array(o,0,n)),l}else return new Uint8Array(o.slice(0,n))}finally{i.destroy()}},Mo=class{constructor(t){this.backend=t,this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.externalBuffers=new Map}upload(t,e){let n=e.buffer,r=e.byteOffset,a=e.byteLength,i=cr(a),s=this.storageCache.get(t);if(!s)throw new Error("gpu data for uploading does not exist");if(s.originalSize!==a)throw new Error(`inconsistent data size. gpu data size=${s.originalSize}, data size=${a}`);let o=this.backend.device.createBuffer({mappedAtCreation:!0,size:i,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),l=o.getMappedRange();new Uint8Array(l).set(new Uint8Array(n,r,a)),o.unmap();let d=this.backend.getCommandEncoder();this.backend.endComputePass(),d.copyBufferToBuffer(o,0,s.gpuData.buffer,0,i),rt("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${t})`),this.buffersForUploadingPending.push(o)}memcpy(t,e){let n=this.storageCache.get(t);if(!n)throw new Error("source gpu data for memcpy does not exist");let r=this.storageCache.get(e);if(!r)throw new Error("destination gpu data for memcpy does not exist");if(n.originalSize!==r.originalSize)throw new Error("inconsistent source and destination gpu data size");let a=cr(n.originalSize),i=this.backend.getCommandEncoder();this.backend.endComputePass(),i.copyBufferToBuffer(n.gpuData.buffer,0,r.gpuData.buffer,0,a)}registerExternalBuffer(t,e,n){let r;if(n){if(r=this.externalBuffers.get(n),r===void 0)throw new Error("previous buffer is not registered");if(t===n)return rt("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${e}) => id=${r}, buffer is the same, skip.`),r;this.externalBuffers.delete(n)}else r=fi();return this.storageCache.set(r,{gpuData:{id:r,type:0,buffer:t},originalSize:e}),this.externalBuffers.set(t,r),rt("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${e}) => id=${r}, registered.`),r}unregisterExternalBuffer(t){let e=this.externalBuffers.get(t);e!==void 0&&(this.storageCache.delete(e),this.externalBuffers.delete(t),rt("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${e}`))}create(t,e=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let n=cr(t),r,a=(e&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,i=(e&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(a||i){let o=a?this.freeBuffers:this.freeUniformBuffers,l=o.get(n);l||(l=[],o.set(n,l)),l.length>0?r=l.pop():r=this.backend.device.createBuffer({size:n,usage:e})}else r=this.backend.device.createBuffer({size:n,usage:e});let s={id:fi(),type:0,buffer:r};return this.storageCache.set(s.id,{gpuData:s,originalSize:t}),rt("verbose",()=>`[WebGPU] GpuDataManager.create(size=${t}) => id=${s.id}`),s}get(t){return this.storageCache.get(t)?.gpuData}release(t){let e=this.storageCache.get(t);if(!e)throw new Error("releasing data does not exist");return rt("verbose",()=>`[WebGPU] GpuDataManager.release(id=${t}), gpuDataId=${e.gpuData.id}`),this.storageCache.delete(t),this.buffersPending.push(e.gpuData.buffer),e.originalSize}async download(t,e){let n=this.storageCache.get(t);if(!n)throw new Error("data does not exist");await ji(this.backend,n.gpuData.buffer,n.originalSize,e)}refreshPendingBuffers(){for(let t of this.buffersForUploadingPending)t.destroy();this.buffersForUploadingPending=[];for(let t of this.buffersPending)(t.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE?this.freeBuffers.get(t.size).push(t):(t.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM?this.freeUniformBuffers.get(t.size).push(t):t.destroy();this.buffersPending=[]}dispose(){this.freeBuffers.forEach(t=>{t.forEach(e=>{e.destroy()})}),this.freeUniformBuffers.forEach(t=>{t.forEach(e=>{e.destroy()})}),this.storageCache.forEach(t=>{t.gpuData.buffer.destroy()}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map}},dc=(...t)=>new Mo(...t)}),Oo,qe,it=Y(()=>{Oo=class{constructor(t){Object.assign(this,t)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(t=>`${this[t]}`).join(";")),this.key}},qe=t=>new Oo(t)}),zo,Ln,J,za,cc,$s,xs,Ie=Y(()=>{zo=class{static calcMatMulShape(t,e){return t[1]!==e[0]?void 0:[t[0],e[1]]}},Ln=class{static calcShape(t,e,n=!1){let r=t.length,a=e.length;if(r===0)return e;if(a===0)return t;let i=Math.max(t.length,e.length),s=new Array(i);if(n){if(r<2||a<2)return;let o=zo.calcMatMulShape([t[r-2],t[r-1]],[e[a-2],e[a-1]]);if(o===void 0)return;[s[i-2],s[i-1]]=o}for(let o=n?3:1;o<=i;o++){let l=r-o<0?1:t[r-o],d=a-o<0?1:e[a-o];if(l!==d&&l>1&&d>1)return;s[i-o]=Math.max(l,d)}return s}static isValidBroadcast(t,e){let n=t.length,r=e.length;if(n>r)return!1;for(let a=1;a<=n;a++)if(t[n-a]!==1&&t[n-a]!==e[r-a])return!1;return!0}},J=class Ea{static size(e){return Ea.getSizeFromDimensionRange(e,0,e.length)}static sizeFromDimension(e,n){if(n<0||n>e.length)throw new Error(`invalid dimension of ${n} for sizeFromDimension as Tensor has ${e.length} dimensions.`);return Ea.getSizeFromDimensionRange(e,n,e.length)}static sizeToDimension(e,n){if(n<0||n>e.length)throw new Error(`invalid dimension of ${n} for sizeToDimension as Tensor has ${e.length} dimensions.`);return Ea.getSizeFromDimensionRange(e,0,n)}static getSizeFromDimensionRange(e,n,r){let a=1;for(let i=n;i<r;i++){if(e[i]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");a*=e[i]}return a}static computeStrides(e){let n=e.length;if(n===0)return[];if(n===1)return[1];let r=new Array(n);r[n-1]=1,r[n-2]=e[n-1];for(let a=n-3;a>=0;--a)r[a]=r[a+1]*e[a+1];return r}static normalizeAxis(e,n){if(e<-n&&e>=n)throw new Error("unsupported axis for this operation.");return e<0?e+n:e}static normalizeAxes(e,n){return e.map(r=>this.normalizeAxis(r,n??e.length))}static sortBasedOnPerm(e,n){return n?n.map(r=>e[r]):e.slice().reverse()}static padShape(e,n){let r=e.length;return e.map((a,i)=>a+n[i]+n[i+r])}static areEqual(e,n){return e.length!==n.length?!1:e.every((r,a)=>r===n[a])}},za=class yr{static adjustPoolAttributes(e,n,r,a,i,s){if(!e&&r.length!==n.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(e)for(let o=0;o<n.length-2;o++)o>=r.length?r.push(n[o+2]):r[o]=n[o+2];for(let o=0;o<r.length;o++)if(o<a.length){if(a[o]<0)throw new Error("strides should be greater than or equal to 1")}else a.push(1);for(let o=0;o<r.length;o++)if(o<i.length){if(i[o]<0)throw new Error("dilations should be greater than or equal to 1")}else i.push(1);for(let o=0;o<r.length*2;o++)if(o<s.length){if(s[o]<0)throw new Error("pad should be greater than or equal to 1")}else s.push(0);for(let o=0;o<r.length;o++){if(r[o]<=0)throw new Error("kernel shapes need to be greater than 0");if(s[o]>=r[o]||s[o+r.length]>=r[o])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(e,n,r,a,i,s,o){if(o){if(i.length!==2*(e.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(n.length!==e.length-2)throw new Error("length of strides should be the length of data dimensions");if(a.length!==e.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let l=0;l<e.length-2;l++)yr.adjustPadAndReturnShape(e[l+(s?1:2)],n[l],r[l],a[l],i,l,l+e.length-2,o)}}static computePoolOutputShape(e,n,r,a,i,s,o){if(n.length<=0)throw new Error("input shape must be of size greater than 0");let l=[n[0],n[1]];return yr.computeShapeHelper(e,n,l,r,a,i,s,o),l}static computeConvOutputShape(e,n,r,a,i,s,o){if(e.length<=0||n.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let l=[e[0],n[0]];return yr.computeShapeHelper(!1,e,l,r,a,i,s,o),l}static computeShapeHelper(e,n,r,a,i,s,o,l){if(e)for(let d=0;d<n.length-2;d++)r.push(1);else for(let d=0;d<n.length-2;d++)r.push(yr.adjustPadAndReturnShape(n[d+2],a[d],i[d],s[d],o,d,d+n.length-2,l))}static adjustPadAndReturnShape(e,n,r,a,i,s,o,l){let d=r*(a-1)+1;if(l&&l!=="NOTSET")switch(l){case"VALID":return i[s]=0,i[o]=0,Math.floor((e-d)/n+1);case"SAME_LOWER":case"SAME_UPPER":if(r!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let p=((e+n-1)/n-1)*n+a-e;return i[s]=Math.floor(l==="SAME_LOWER"?(p+1)/2:p/2),i[o]=p-i[s],Math.floor((e+p-a)/n+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((e+i[s]+i[o]-d)/n+1)}},cc=class{static getShapeOfGemmResult(t,e,n,r,a){if(t.length!==2||n.length!==2)throw new Error("shape need to be of size 2");let i,s,o;e?(i=t[1],s=t[0]):(i=t[0],s=t[1]);let l=-1;if(r?(o=n[0],l=1):(o=n[1],l=0),n[l]!==s)throw new Error("dimension mismatch");if(i<=0||o<=0||s<=0)throw new Error("invalid shape specified");if(a&&!Ln.isValidBroadcast(a,[i,o]))throw new Error("gemm: invalid bias shape for broadcast");return[i,o,s]}},$s=-34028234663852886e22,xs=34028234663852886e22}),Ro,ma,xt,Qt,re,gt,mt,Zt,Ht,xe,ga,Z,be,Ss,Bo,pc,Tr,at,Te=Y(()=>{Ye(),Ie(),Ro=64,ma=(t,e)=>{if(e===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(t){case 10:return e>1?`vec${e}<f16>`:"f16";case 1:return e>1?`vec${e}<f32>`:"f32";case 6:return e>1?`vec${e}<i32>`:"i32";case 12:return e>1?`vec${e}<u32>`:"u32";case 7:if(e>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(e>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(e!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];default:throw new Error(`Unknown data type: ${t}`)}},xt=(t,e=1)=>{let n=ma(t,e);return typeof n=="string"?n:n[0]},Qt=(t,e=1)=>{let n=ma(t,e);return typeof n=="string"?n:n[1]},re=t=>t.length===0?[]:[{type:"uint32",data:t},{type:"uint32",data:J.computeStrides(t)}],gt=t=>t%4===0?4:t%2===0?2:1,mt=(t="f32",e,n="0")=>!e||e===1?`${t}(${n})`:`vec${e}<${t}>(${n})`,Zt=(t,e,n)=>t==="f32"?n:e===1?`f32(${n})`:`vec${e}f(${n})`,Ht=(t,e)=>e===4?`(${t}.x + ${t}.y + ${t}.z + ${t}.w)`:e===2?`(${t}.x + ${t}.y)`:e===3?`(${t}.x + ${t}.y + ${t}.z)`:t,xe=(t,e,n)=>t.startsWith("uniforms.")&&n>4?typeof e=="string"?`${t}[(${e}) / 4][(${e}) % 4]`:`${t}[${Math.floor(e/4)}][${e%4}]`:n>1?`${t}[${e}]`:t,ga=(t,e,n,r,a)=>{let i=typeof n=="number",s=i?n:n.length,o=[...new Array(s).keys()],l=s<2?"u32":s<=4?`vec${s}<u32>`:`array<u32, ${s}>`,d=ma(e,a),p=typeof d=="string"?d:d[1],u=typeof d=="string"?d:d[0],f={indices:l,value:p,storage:u,tensor:e},m=V=>typeof V=="string"?V:`${V}u`,_={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},v=i?"uniforms.":"",$=`${v}${t}_shape`,b=`${v}${t}_strides`,S="";for(let V=0;V<s-1;V++)S+=`
    let dim${V} = current / ${xe(b,V,s)};
    let rest${V} = current % ${xe(b,V,s)};
    indices[${V}] = dim${V};
    current = rest${V};
    `;S+=`indices[${s-1}] = current;`;let T=s<2?"":`
  fn o2i_${t}(offset: u32) -> ${f.indices} {
    var indices: ${f.indices};
    var current = offset;
    ${S}
    return indices;
  }`,E=V=>(_.offsetToIndices=!0,s<2?V:`o2i_${t}(${V})`),I=[];if(s>=2)for(let V=s-1;V>=0;V--)I.push(`${xe(b,V,s)} * (indices[${V}])`);let M=s<2?"":`
  fn i2o_${t}(indices: ${f.indices}) -> u32 {
    return ${I.join("+")};
  }`,F=V=>(_.indicesToOffset=!0,s<2?V:`i2o_${t}(${V})`),L=(...V)=>s===0?"0u":`${f.indices}(${V.map(m).join(",")})`,W=(V,ie)=>s<2?`${V}`:`${xe(V,ie,s)}`,X=(V,ie,$e)=>s<2?`${V}=${$e};`:`${xe(V,ie,s)}=${$e};`,A={},q=(V,ie)=>{_.broadcastedIndicesToOffset=!0;let $e=`${ie.name}broadcastedIndicesTo${t}Offset`;if($e in A)return`${$e}(${V})`;let Le=[];for(let Pe=s-1;Pe>=0;Pe--){let We=ie.indicesGet("outputIndices",Pe+ie.rank-s);Le.push(`${W(b,Pe)} * (${We} % ${W($,Pe)})`)}return A[$e]=`fn ${$e}(outputIndices: ${ie.type.indices}) -> u32 {
             return ${Le.length>0?Le.join("+"):"0u"};
           }`,`${$e}(${V})`},te=(V,ie)=>(()=>{if(f.storage===f.value)return`${t}[${V}]=${ie};`;if(f.storage==="vec2<u32>"&&f.value==="i32")return`${t}[${V}]=vec2<u32>(u32(${ie}), select(0u, 0xFFFFFFFFu, ${ie} < 0));`;if(f.storage==="vec2<u32>"&&f.value==="u32")return`${t}[${V}]=vec2<u32>(u32(${ie}), 0u);`;if(f.storage==="u32"&&f.value==="vec4<bool>")return`${t}[${V}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${ie}));`;throw new Error(`not supported combination of storage type ${f.storage} and value type ${f.value} yet`)})(),K=V=>(()=>{if(f.storage===f.value)return`${t}[${V}]`;if(f.storage==="vec2<u32>"&&f.value==="i32")return`i32(${t}[${V}].x)`;if(f.storage==="vec2<u32>"&&f.value==="u32")return`u32(${t}[${V}].x)`;if(f.storage==="u32"&&f.value==="vec4<bool>")return`vec4<bool>(bool(${t}[${V}] & 0xFFu), bool(${t}[${V}] & 0xFF00u), bool(${t}[${V}] & 0xFF0000u), bool(${t}[${V}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${f.storage} and value type ${f.value} yet`)})(),B=s<2?"":`
  fn get_${t}ByIndices(indices: ${f.indices}) -> ${p} {
    return ${K(`i2o_${t}(indices)`)};
  }`,U=s<2?"":(()=>{let V=o.map($e=>`d${$e}: u32`).join(", "),ie=o.map($e=>`d${$e}`).join(", ");return`
  fn get_${t}(${V}) -> ${p} {
    return get_${t}ByIndices(${L(ie)});
  }`})(),G=(...V)=>{if(V.length!==s)throw new Error(`indices length must be ${s}`);let ie=V.map(m).join(",");return s===0?K("0u"):s===1?K(ie[0]):(_.get=!0,_.getByIndices=!0,_.indicesToOffset=!0,`get_${t}(${ie})`)},ne=V=>s<2?K(V):(_.getByIndices=!0,_.indicesToOffset=!0,`get_${t}ByIndices(${V})`),oe=s<2?"":`
  fn set_${t}ByIndices(indices: ${f.indices}, value: ${p}) {
    ${te(`i2o_${t}(indices)`,"value")}
  }`,ye=s<2?"":(()=>{let V=o.map($e=>`d${$e}: u32`).join(", "),ie=o.map($e=>`d${$e}`).join(", ");return`
  fn set_${t}(${V}, value: ${p}) {
    set_${t}ByIndices(${L(ie)}, value);
  }`})();return{impl:()=>{let V=[],ie=!1;return _.offsetToIndices&&(V.push(T),ie=!0),_.indicesToOffset&&(V.push(M),ie=!0),_.broadcastedIndicesToOffset&&(Object.values(A).forEach($e=>V.push($e)),ie=!0),_.set&&(V.push(ye),ie=!0),_.setByIndices&&(V.push(oe),ie=!0),_.get&&(V.push(U),ie=!0),_.getByIndices&&(V.push(B),ie=!0),!i&&ie&&V.unshift(`const ${$} = ${f.indices}(${n.join(",")});`,`const ${b} = ${f.indices}(${J.computeStrides(n).join(",")});`),V.join(`
`)},type:f,offsetToIndices:E,indicesToOffset:F,broadcastedIndicesToOffset:q,indices:L,indicesGet:W,indicesSet:X,set:(...V)=>{if(V.length!==s+1)throw new Error(`indices length must be ${s}`);let ie=V[s];if(typeof ie!="string")throw new Error("value must be string");let $e=V.slice(0,s).map(m).join(",");return s===0?te("0u",ie):s===1?te($e[0],ie):(_.set=!0,_.setByIndices=!0,_.indicesToOffset=!0,`set_${t}(${$e}, ${ie})`)},setByOffset:te,setByIndices:(V,ie)=>s<2?te(V,ie):(_.setByIndices=!0,_.indicesToOffset=!0,`set_${t}ByIndices(${V}, ${ie});`),get:G,getByOffset:K,getByIndices:ne,usage:r,name:t,strides:b,shape:$,rank:s}},Z=(t,e,n,r=1)=>ga(t,e,n,"input",r),be=(t,e,n,r=1)=>ga(t,e,n,"output",r),Ss=(t,e,n,r=1)=>ga(t,e,n,"internal",r),Bo=class{constructor(t){this.normalizedDispatchGroup=t,this.internalVariables=[],this.variables=[],this.uniforms=[],this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(t){return`if (global_idx >= ${typeof t=="number"?`${t}u`:t}) { return; }`}mainStart(t=Ro){let e=typeof t=="number"?t:t[0],n=typeof t=="number"?1:t[1],r=typeof t=="number"?1:t[2],a=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,i=a?`@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(local_invocation_id) local_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(num_workgroups) num_workgroups : vec3<u32>`,s=a?"let global_idx = global_id.x; let local_idx = local_id.x;":`let global_idx = (workgroup_id.z * num_workgroups[0] * num_workgroups[1] +
          workgroup_id.y * num_workgroups[0] + workgroup_id.x) * ${e*n*r}u + local_idx;`;return`@compute @workgroup_size(${e}, ${n}, ${r})
  fn main(${i}) {
    ${s}
  `}appendVariableUniforms(t){t.rank!==0&&(t.shape.startsWith("uniforms.")&&this.uniforms.push({name:t.shape.replace("uniforms.",""),type:"u32",length:t.rank}),t.strides.startsWith("uniforms.")&&this.uniforms.push({name:t.strides.replace("uniforms.",""),type:"u32",length:t.rank}))}declareVariable(t,e){if(t.usage==="internal")throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(t),this.appendVariableUniforms(t);let n=t.usage==="input"?"read":"read_write",r=t.type.storage;return`@group(0) @binding(${e}) var<storage, ${n}> ${t.name}: array<${r}>;`}declareVariables(...t){return t.map(e=>this.declareVariable(e,this.variableIndex++)).join(`
`)}registerInternalVariable(t){if(t.usage!=="internal")throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(t),this.appendVariableUniforms(t)}registerInternalVariables(...t){return t.forEach(e=>this.registerInternalVariable(e)),this}registerUniform(t,e,n=1){return this.uniforms.push({name:t,type:e,length:n}),this}registerUniforms(t){return this.uniforms=this.uniforms.concat(t),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let t=[];for(let{name:e,type:n,length:r}of this.uniforms)if(r&&r>4)t.push(`${e}:array<vec4<${n}>, ${Math.ceil(r/4)}>`);else{let a=r==null||r===1?n:`vec${r}<${n}>`;t.push(`${e}:${a}`)}return`
      struct Uniforms { ${t.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map(t=>t.impl()).join(`
`)+this.internalVariables.map(t=>t.impl()).join(`
`)}},pc=t=>new Bo(t),Tr=(t,e)=>{let n=t.length,r=[];for(let a=0;a<n;a++){let i=n-1-a,s=t[i]||1;(e[e.length-1-a]||1)>1&&s===1&&r.unshift(i)}return r},at=t=>!0}),Po,mi,Do,No,cn,hc,fc,Or=Y(()=>{Ie(),it(),Te(),Po=t=>{if(!t||t.length!==1)throw new Error("Transpose requires 1 input.")},mi=(t,e)=>e&&e.length!==t?[...new Array(t).keys()].reverse():e,Do=(t,e)=>J.sortBasedOnPerm(t,mi(t.length,e)),No=(t,e,n,r)=>{let a=[];a.push(`fn perm(i: ${r.type.indices}) -> ${n.type.indices} {
    var a: ${n.type.indices};`);for(let i=0;i<e;++i)a.push(n.indicesSet("a",t[i],`i[${i}]`));return a.push("return a;}"),a.join(`
`)},cn=(t,e)=>{let n=t.dataType,r=t.dims.length,a=mi(r,e),i=at(r),s=Do(t.dims,a),o=i?s.length:s,l=i?r:t.dims,d=be("output",n,o),p=Z("a",n,l),u=f=>`
  ${f.registerUniform("output_size","u32").declareVariables(p,d)}

  ${No(a,r,p,d)}

  ${f.mainStart()}
    ${f.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${d.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${d.setByOffset("global_idx",p.getByIndices("aIndices"))}
  }`;return{name:"Transpose",shaderCache:{hint:`${e}`,inputDependencies:i?["rank"]:["dims"]},getRunData:f=>{let m=J.size(s);return{outputs:[{dims:s,dataType:f[0].dataType}],dispatchGroup:{x:Math.ceil(m/64)},programUniforms:i?[{type:"uint32",data:m},...re(f[0].dims),...re(s)]:[{type:"uint32",data:m}]}},getShaderSource:u}},hc=(t,e)=>{Po(t.inputs),t.compute(cn(t.inputs[0],e.perm))},fc=t=>qe({perm:t.perm})}),Lo,Fo,Uo,Wo,Vo,Go,Ho,qo,jo,Ko,kt,mc,gc,_c,wc,yc,vc,bc,$c,xc,Sc,Og=Y(()=>{Ie(),Te(),Es(),Or(),Lo={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},Fo={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},Uo={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},Wo={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},Vo=(t,e)=>{let n=[];for(let r=e-t;r<e;++r)n.push(r);return n},Go=(t,e)=>{let n=[],r=t.length;for(let i=0;i<r;i++)e.indexOf(i)===-1&&n.push(t[i]);let a=e.map(i=>t[i]);return[n,a]},Ho=(t,e)=>{let n=t.length+e.length,r=[],a=0;for(let i=0;i<n;i++)e.indexOf(i)===-1?r.push(t[a++]):r.push(1);return r},qo=(t,e)=>{for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0},jo=(t,e)=>{let n=[];if(!qo(t,e)){for(let r=0;r<e;++r)t.indexOf(r)===-1&&n.push(r);t.forEach(r=>n.push(r))}return n},Ko=(t,e,n,r,a,i,s)=>{let o=n[0].dims,l=J.size(i),d=J.size(s),p=Z("_A",n[0].dataType,o),u=be("output",a,i),f=32,m=`
          var<workgroup> aBestValues : array<${u.type.storage}, ${f}>;
       `;return{name:t,shaderCache:e,getShaderSource:_=>`
        ${_.registerUniform("reduceSize","u32").declareVariables(p,u)}
        ${m}
        fn DIV_CEIL(a : u32, b : u32) -> u32 {
          return ((a - 1u) / b + 1u);
         }
         ${_.mainStart(f)}

          let outputIndex = global_idx / ${f};
          let offset = outputIndex * uniforms.reduceSize;

          var bestValue = ${u.type.storage}(${Uo[r]});
          let Length = uniforms.reduceSize;
          for (var k = local_idx; k < Length; k = k + ${f}) {
           let candidate = ${u.type.storage}(${p.getByOffset("offset + k")});
           bestValue = ${Lo[r]};
          }
          aBestValues[local_idx] = bestValue;
          workgroupBarrier();

         var reduceSize = min(Length, ${f}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (local_idx < currentSize) {
            let candidate = aBestValues[local_idx + interval];
            bestValue = ${Fo[r]};
            aBestValues[local_idx] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (local_idx == 0u) {
          ${u.setByOffset("outputIndex",`${r==="mean"?`bestValue / ${u.type.storage}(uniforms.reduceSize)`:`${Wo[r]}`}`)};
         }
        }`,getRunData:()=>({outputs:[{dims:i,dataType:a}],dispatchGroup:{x:l},programUniforms:[{type:"uint32",data:d}]})}},kt=(t,e,n,r)=>{let a=t.inputs.length===1?n:Ki(t.inputs,n),i=a.axes;i.length===0&&!a.noopWithEmptyAxes&&(i=t.inputs[0].dims.map((m,_)=>_));let s=J.normalizeAxes(i,t.inputs[0].dims.length),o=s,l=t.inputs[0],d=jo(o,t.inputs[0].dims.length);d.length>0&&(l=t.compute(cn(t.inputs[0],d),{inputs:[0],outputs:[-1]})[0],o=Vo(o.length,l.dims.length));let[p,u]=Go(l.dims,o),f=p;a.keepDims&&(f=Ho(p,s)),t.compute(Ko(e,{hint:a.cacheKey,inputDependencies:["type"]},[l],r,t.inputs[0].dataType,f,u),{inputs:[l]})},mc=(t,e)=>{kt(t,"ReduceMeanShared",e,"mean")},gc=(t,e)=>{kt(t,"ReduceL1Shared",e,"l1")},_c=(t,e)=>{kt(t,"ReduceL2Shared",e,"l2")},wc=(t,e)=>{kt(t,"ReduceLogSumExpShared",e,"logSumExp")},yc=(t,e)=>{kt(t,"ReduceMaxShared",e,"max")},vc=(t,e)=>{kt(t,"ReduceMinShared",e,"min")},bc=(t,e)=>{kt(t,"ReduceProdShared",e,"prod")},$c=(t,e)=>{kt(t,"ReduceSumShared",e,"sum")},xc=(t,e)=>{kt(t,"ReduceSumSquareShared",e,"sumSquare")},Sc=(t,e)=>{kt(t,"ReduceLogSumShared",e,"logSum")}}),Tt,Yo,Ra,Ki,Ct,Xo,Qo,Zo,Jo,el,tl,nl,rl,al,il,It,Ec,kc,Tc,Cc,Ic,Ac,Mc,Oc,zc,Rc,Es=Y(()=>{Ie(),it(),Te(),Og(),Tt=t=>{if(!t||t.length===0||t.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(t.length===2&&t[1].dims.length!==1)throw new Error("Invalid axes input dims.")},Yo=t=>["","",`var value = ${t.getByIndices("input_indices")};`,""],Ra=(t,e,n,r,a,i,s=!1,o=!1)=>{let l=[],d=n[0].dims,p=d.length,u=J.normalizeAxes(a,p),f=!o&&u.length===0;d.forEach((v,$)=>{f||u.indexOf($)>=0?s&&l.push(1):l.push(v)});let m=l.length,_=J.size(l);return{name:t,shaderCache:e,getShaderSource:v=>{let $=[],b=Z("_A",n[0].dataType,p),S=be("output",i,m),T=r(b,S,u),E=T[2];for(let I=0,M=0;I<p;I++)f||u.indexOf(I)>=0?(s&&M++,E=`for(var j${I}: u32 = 0; j${I} < ${d[I]}; j${I}++) {
                  ${T[2].includes("last_index")?`let last_index = j${I};`:""}
                  ${b.indicesSet("input_indices",I,`j${I}`)}
                  ${E}
                }`):($.push(`${b.indicesSet("input_indices",I,S.indicesGet("output_indices",M))};`),M++);return`

        ${v.registerUniform("output_size","u32").declareVariables(b,S)}

        ${v.mainStart()}
          ${v.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          var input_indices: ${b.type.indices};
          let output_indices = ${S.offsetToIndices("global_idx")};

          ${$.join(`
`)}
          ${T[0]}       // init ops for reduce max/min
          ${T[1]}
          ${E}
          ${T[3]}
          ${T.length===4?S.setByOffset("global_idx","value"):T.slice(4).join(`
`)}
        }`},getRunData:()=>({outputs:[{dims:l,dataType:i}],dispatchGroup:{x:Math.ceil(_/64)},programUniforms:[{type:"uint32",data:_},...re(d),...re(l)]})}},Ki=(t,e)=>{let n=[];return t[1].dims[0]>0&&t[1].getBigInt64Array().forEach(r=>n.push(Number(r))),qe({axes:n,keepDims:e.keepDims,noopWithEmptyAxes:e.noopWithEmptyAxes})},Ct=(t,e,n,r)=>{let a=t.inputs,i=a.length===1?n:Ki(a,n);t.compute(Ra(e,{hint:i.cacheKey,inputDependencies:["rank"]},[a[0]],i.noopWithEmptyAxes&&i.axes.length===0?Yo:r,i.axes,a[0].dataType,i.keepDims,i.noopWithEmptyAxes),{inputs:[0]})},Xo=(t,e)=>{Tt(t.inputs),Ct(t,"ReduceLogSum",e,(n,r)=>[`var value = ${r.type.storage}(0);`,"",`value += ${n.getByIndices("input_indices")};`,"value = log(value);"])},Qo=(t,e)=>{Tt(t.inputs),Ct(t,"ReduceL1",e,(n,r)=>[`var value = ${r.type.storage}(0);`,"",`value += abs(${n.getByIndices("input_indices")});`,""])},Zo=(t,e)=>{Tt(t.inputs),Ct(t,"ReduceL2",e,(n,r)=>[`var t = ${r.type.value}(0); var value = ${r.type.value}(0);`,"",`t = ${n.getByIndices("input_indices")}; value += (t * t);`,"value = sqrt(value);"])},Jo=(t,e)=>{Tt(t.inputs),Ct(t,"ReduceLogSumExp",e,(n,r)=>[`var value = ${r.type.storage}(0);`,"",`value += exp(${n.getByIndices("input_indices")});`,"value = log(value);"])},el=(t,e)=>{Tt(t.inputs),Ct(t,"ReduceMax",e,(n,r,a)=>{let i=[];for(let s=0;s<n.rank;s++)(a.indexOf(s)>=0||a.length===0)&&i.push(n.indicesSet("input_indices",s,0));return[`${i.join(`
`)}`,`var value = ${n.getByIndices("input_indices")};`,`value = max(value, ${n.getByIndices("input_indices")});`,""]})},tl=(t,e)=>{Tt(t.inputs),Ct(t,"ReduceMean",e,(n,r,a)=>{let i=1;for(let s=0;s<n.rank;s++)(a.indexOf(s)>=0||a.length===0)&&(i*=t.inputs[0].dims[s]);return["var sum = f32(0);","",`sum += f32(${n.getByIndices("input_indices")});`,`let value = ${r.type.value}(sum / ${i});`]})},nl=(t,e)=>{Tt(t.inputs),Ct(t,"ReduceMin",e,(n,r,a)=>{let i=[];for(let s=0;s<n.rank;s++)(a.indexOf(s)>=0||a.length===0)&&i.push(`input_indices[${s}] = 0;`);return[`${i.join(`
`)}`,`var value = ${n.getByIndices("input_indices")};`,`value = min(value, ${n.getByIndices("input_indices")});`,""]})},rl=(t,e)=>{Tt(t.inputs),Ct(t,"ReduceProd",e,(n,r)=>[`var value = ${r.type.storage}(1);`,"",`value *= ${n.getByIndices("input_indices")};`,""])},al=(t,e)=>{Tt(t.inputs),Ct(t,"ReduceSum",e,(n,r)=>[`var value = ${r.type.storage}(0);`,"",`value += ${n.getByIndices("input_indices")};`,""])},il=(t,e)=>{Tt(t.inputs),Ct(t,"ReduceSumSquare",e,(n,r)=>[`var t = ${r.type.value}(0); var value = ${r.type.value}(0);`,"",`t = ${n.getByIndices("input_indices")}; value += t * t;`,""])},It=(t,e,n)=>{if(e.length===0)return n;let r=1,a=1;for(let i=0;i<e.length;i++)e.indexOf(i)===-1?r*=t[i]:a*=t[i];return a<32&&r>1024},Ec=(t,e)=>{It(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?tl(t,e):mc(t,e)},kc=(t,e)=>{It(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Qo(t,e):gc(t,e)},Tc=(t,e)=>{It(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Zo(t,e):_c(t,e)},Cc=(t,e)=>{It(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Jo(t,e):wc(t,e)},Ic=(t,e)=>{It(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?el(t,e):yc(t,e)},Ac=(t,e)=>{It(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?nl(t,e):vc(t,e)},Mc=(t,e)=>{It(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?rl(t,e):bc(t,e)},Oc=(t,e)=>{It(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?al(t,e):$c(t,e)},zc=(t,e)=>{It(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?il(t,e):xc(t,e)},Rc=(t,e)=>{It(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Xo(t,e):Sc(t,e)}}),gi,Bc,Pc,Yi,zg=Y(()=>{Ye(),it(),Es(),gi=t=>{if(!t||t.length===0||t.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(t[0].dataType!==1)throw new Error("Invalid input type.")},Bc=(t,e)=>{gi(t.inputs);let n=(r,a,i)=>{let s=[];for(let o=0;o<r.rank;o++)(i.indexOf(o)>=0||i.length===0)&&s.push(`input_indices[${o}] = 0;`);return[`${s.join(`
`)}`,`var value = ${r.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${r.getByIndices("input_indices")} ${e.selectLastIndex>0?"<=":"<"} value) {
         value = ${r.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",a.setByOffset("global_idx","best_index")]};t.compute(Ra("ArgMin",{hint:e.cacheKey,inputDependencies:["rank"]},[t.inputs[0]],n,[e.axis],7,e.keepDims),{inputs:[0]})},Pc=(t,e)=>{gi(t.inputs);let n=(r,a,i)=>{let s=[];for(let o=0;o<r.rank;o++)(i.indexOf(o)>=0||i.length===0)&&s.push(`input_indices[${o}] = 0;`);return[`${s.join(`
`)}`,`var value = ${r.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${r.getByIndices("input_indices")} ${e.selectLastIndex>0?">=":">"} value) {
         value = ${r.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",a.setByOffset("global_idx","best_index")]};t.compute(Ra("argMax",{hint:e.cacheKey,inputDependencies:["rank"]},[t.inputs[0]],n,[e.axis],7,e.keepDims),{inputs:[0]})},Yi=t=>qe(t)}),sl,ol,ll,ul,Ba,dl,Dc,Nc=Y(()=>{Ye(),bs(),Te(),sl=(t,e)=>{let n=t[0],r=t[1],a=t[2],i=t[3],s=t[4],o=t[5];if(s&&o)throw new Error("Attention cannot have both past and relative_position_bias");if(n.dims.length!==3)throw new Error('Input "input" must have 3 dimensions');let l=n.dims[0],d=n.dims[1],p=n.dims[2];if(a.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimensions');if(r.dims.length!==2)throw new Error('Input "weights" is expected to have 2 dimensions');if(r.dims[0]!==p)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(a.dims[0]!==r.dims[1])throw new Error('Input "bias" dimension 0 should have same length as dimension 1 of input "weights"');let u=a.dims[0]/3,f=u,m=f;if(e.qkvHiddenSizes.length>0){if(e.qkvHiddenSizes.length!==3)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let T of e.qkvHiddenSizes)if(T%e.numHeads!==0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");u=e.qkvHiddenSizes[0],f=e.qkvHiddenSizes[1],m=e.qkvHiddenSizes[2]}let _=d;if(u!==f)throw new Error("qkv_hidden_sizes first element should be same as the second");if(a.dims[0]!==u+f+m)throw new Error('Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes');let v=0;if(s){if(f!==m)throw new Error('Input "past" expect k_hidden_size == v_hidden_size');if(s.dims.length!==5)throw new Error('Input "past" must have 5 dimensions');if(s.dims[0]!==2)throw new Error('Input "past" first dimension must be 2');if(s.dims[1]!==l)throw new Error('Input "past" second dimension must be batch_size');if(s.dims[2]!==e.numHeads)throw new Error('Input "past" third dimension must be num_heads');if(s.dims[4]!==f/e.numHeads)throw new Error('Input "past" fifth dimension must be k_hidden_size / num_heads');e.pastPresentShareBuffer||(v=s.dims[3])}let $=_+v,b=-1,S=0;if(i)throw new Error("Mask not supported");if(s)throw new Error("past is not supported");if(o)throw new Error("relativePositionBias is not supported");return{batchSize:l,sequenceLength:d,pastSequenceLength:v,kvSequenceLength:_,totalSequenceLength:$,maxSequenceLength:b,inputHiddenSize:p,hiddenSize:u,vHiddenSize:m,headSize:Math.floor(u/e.numHeads),vHeadSize:Math.floor(m/e.numHeads),numHeads:e.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:e.maskFilterValue,maskType:S,scale:e.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},ol=(t,e,n,r)=>{let a=gt(r),i=64,s=r/a;s<i?i=1:s/8<64&&(i=Math.ceil(s/8));let o=Math.ceil(r/a/i),l=[{type:Vt(e.dataType),data:1/r},{type:"uint32",data:s},{type:"uint32",data:o}],d=xt(e.dataType,a),p=u=>{let f=be("x",e.dataType,e.dims,a),m="thread_max_vector";a===2?m="max(thread_max_vector.x, thread_max_vector.y)":a===4&&(m="max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))");let _=Qt(e.dataType),v=[{name:"d_inv",type:_},{name:"d_comp",type:"u32"},{name:"elements_per_wg",type:"u32"}];return`
  var<workgroup> wgMax: array<f32, ${i}>;
  var<workgroup> wgSum: array<f32, ${i}>;
  ${u.registerUniforms(v).declareVariables(f)}
  ${u.mainStart([i,1,1])}
    let localOffset = local_idx * uniforms.elements_per_wg;
    let offset: u32 = workgroup_id.x * uniforms.d_comp + localOffset;

    var thread_max_vector = ${mt("f32",a,"-3.402823e+38f")};
    for (var i: u32 = 0; i < uniforms.elements_per_wg && i + localOffset < uniforms.d_comp; i++) {
      thread_max_vector = max(${Zt(_,a,"x[offset + i]")}, thread_max_vector);
    }
    wgMax[local_idx] = ${m};
    workgroupBarrier();

    var maxValue = -3.402823e+38f;
    for (var i = 0u; i < ${i}; i++) {
      maxValue = max(wgMax[i], maxValue);
    }

    var sumVector = ${mt("f32",a,"0")};
    for (var i: u32 = 0; i < uniforms.elements_per_wg && i + localOffset < uniforms.d_comp; i++) {
      sumVector += exp(${Zt(_,a,"x[offset + i]")} - maxValue);
    }
    wgSum[local_idx] = ${Ht("sumVector",a)};
    workgroupBarrier();

    var sum: f32 = 0;
    for (var i = 0u; i < ${i}; i++) {
      sum += wgSum[i];
    }

    if (sum == 0) {
      for (var i: u32 = 0; i < uniforms.elements_per_wg && i + localOffset < uniforms.d_comp; i++) {
        x[offset + i] = ${mt("f32",a,"uniforms.d_inv")};
      }
    } else {
      for (var i: u32 = 0; i < uniforms.elements_per_wg && i + localOffset < uniforms.d_comp; i++) {
        let f32input = ${Zt(_,a,"x[offset + i]")};
        x[offset + i] = ${f.type.value}(exp(f32input - maxValue) / sum);
      }
    }
  }`};t.compute({name:"AttentionProbsSoftmax",shaderCache:{hint:`${i};${d};${a}`},getShaderSource:p,getRunData:()=>({outputs:[],dispatchGroup:{x:n},programUniforms:l})},{inputs:[e],outputs:[]})},ll=(t,e,n,r,a,i)=>{let s=[a.batchSize,a.numHeads,a.sequenceLength,a.kvSequenceLength+a.pastSequenceLength],o=i.scale===0?1/Math.sqrt(a.headSize):i.scale,l=gt(a.headSize),d=a.headSize/l,p=12,u={x:Math.ceil(a.totalSequenceLength/p),y:Math.ceil(a.sequenceLength/p),z:a.batchSize*a.numHeads},f=Vt(e.dataType),m=[{type:"uint32",data:a.sequenceLength},{type:"uint32",data:d},{type:"uint32",data:a.totalSequenceLength},{type:"uint32",data:a.kvSequenceLength},{type:f,data:o}],_=[e,n],v=b=>{let S=Z("q",e.dataType,e.dims,l),T=Z("key",n.dataType,n.dims,l),E=be("output",e.dataType,s),I=xt(e.dataType),M=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"alpha",type:I}];return`
  const beta: ${I} = 1.0;
  const TILE_SIZE = ${p}u;

  var<workgroup> tileQ: array<${S.type.storage}, ${p*p}>;
  var<workgroup> tileK: array<${S.type.storage}, ${p*p}>;
  ${b.registerUniforms(M).declareVariables(S,T,E)}
  ${b.mainStart([p,p,1])}
    // x holds the N and y holds the M
    let headIdx = workgroup_id.z;
    let m = workgroup_id.y * TILE_SIZE;
    let n = workgroup_id.x * TILE_SIZE;
    let lm = m + local_id.y;
    let ln = n + local_id.x;

    let qOffset = uniforms.M * uniforms.K * headIdx + m * uniforms.K;
    let kOffset = uniforms.kv_sequence_length * uniforms.K * headIdx + n * uniforms.K;

    var value = ${mt(I,l)};
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m + local_id.y < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];
      }
      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {
        tileK[TILE_SIZE * local_id.y + local_id.x] = key[kOffset + local_id.y * uniforms.K + w + local_id.x];
      }
      workgroupBarrier();

      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {
        value += tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k];
      }

      workgroupBarrier();
    }

    let headOffset = headIdx * uniforms.M * uniforms.N;
    if (lm < uniforms.M && ln < uniforms.N) {
      let outputIdx = headOffset + lm * uniforms.N + ln;
      output[outputIdx] = ${Ht("value",l)} * uniforms.alpha;
    }
  }`},$=t.compute({name:"AttentionProbs",shaderCache:{hint:`${l}`,inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:s,dataType:e.dataType,gpuDataType:0}],dispatchGroup:u,programUniforms:m}),getShaderSource:v},{inputs:_,outputs:[-1]})[0];return ol(t,$,a.batchSize*a.numHeads*a.sequenceLength,a.totalSequenceLength),$},ul=(t,e,n,r)=>{let a=[r.batchSize,r.sequenceLength,r.vHiddenSize],i=12,s={x:Math.ceil(r.vHeadSize/i),y:Math.ceil(r.sequenceLength/i),z:r.batchSize*r.numHeads},o=[{type:"uint32",data:r.sequenceLength},{type:"uint32",data:r.totalSequenceLength},{type:"uint32",data:r.vHeadSize},{type:"uint32",data:r.numHeads},{type:"uint32",data:r.vHiddenSize}],l=d=>{let p=Z("probs",e.dataType,e.dims),u=Z("v",n.dataType,n.dims),f=be("output",e.dataType,a),m=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"v_hidden_size",type:"u32"}];return`
  const TILE_SIZE = ${i}u;
  var<workgroup> tileQ: array<${p.type.value}, ${i*i}>;
  var<workgroup> tileK: array<${p.type.value}, ${i*i}>;
  ${d.registerUniforms(m).declareVariables(p,u,f)}
  ${d.mainStart([i,i,1])}
   let headIdx = workgroup_id.z;
   let m = workgroup_id.y * TILE_SIZE + local_id.y;
   let n = workgroup_id.x * TILE_SIZE + local_id.x;

   let offsetA = headIdx * (uniforms.M * uniforms.K) + m * uniforms.K;
   let offsetB = headIdx * (uniforms.N * uniforms.K) + n;

   var value = ${p.type.storage}(0);
   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
     if (m < uniforms.M && w + local_id.x < uniforms.K) {
       tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];
     }
     if (n < uniforms.N && w + local_id.y < uniforms.K) {
       tileK[TILE_SIZE * local_id.y + local_id.x] = v[offsetB + (w + local_id.y) * uniforms.N];
     }
     workgroupBarrier();
     for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {
       value += tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * k + local_id.x];
     }
     workgroupBarrier();
   }

   // we need to transpose output from BNSH_v to BSND_v
   let batchIdx = workgroup_id.z / uniforms.num_heads;
   let currentBatchHeadNumber = workgroup_id.z % uniforms.num_heads;
   let headOffset = (batchIdx * uniforms.M * uniforms.num_heads + currentBatchHeadNumber) * uniforms.N;
   if (m < uniforms.M && n < uniforms.N) {
     let outputIdx = batchIdx * uniforms.M *uniforms.v_hidden_size + m * uniforms.v_hidden_size
       + currentBatchHeadNumber * uniforms.N + n;
     output[outputIdx] = value;
   }
  }`};return t.compute({name:"AttentionScore",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:a,dataType:e.dataType,gpuDataType:0}],dispatchGroup:s,programUniforms:o}),getShaderSource:l},{inputs:[e,n],outputs:[0]})[0]},Ba=(t,e,n,r,a,i,s,o,l,d,p)=>{let u=ll(t,e,n,l,d,p);ul(t,u,r,d)},dl=(t,e)=>{let n=[e.batchSize,e.numHeads,e.sequenceLength,e.headSize],r=e.sequenceLength,a=e.inputHiddenSize,i=e.headSize,s=12,o={x:Math.ceil(e.headSize/s),y:Math.ceil(e.sequenceLength/s),z:e.batchSize*e.numHeads},l=[t.inputs[0],t.inputs[1],t.inputs[2]],d=[{type:"uint32",data:r},{type:"uint32",data:a},{type:"uint32",data:i},{type:"uint32",data:e.numHeads},{type:"uint32",data:e.headSize},{type:"uint32",data:e.hiddenSize},{type:"uint32",data:e.hiddenSize+e.hiddenSize+e.vHiddenSize}],p=u=>{let f=be("output_q",l[0].dataType,n),m=be("output_k",l[0].dataType,n),_=be("output_v",l[0].dataType,n),v=Z("input",l[0].dataType,l[0].dims),$=Z("weight",l[1].dataType,l[1].dims),b=Z("bias",l[2].dataType,l[2].dims),S=v.type.storage,T=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"hidden_size",type:"u32"},{name:"ldb",type:"u32"}];return`
  const TILE_SIZE = ${s}u;
  var<workgroup> tileInput: array<${S}, ${s*s}>;
  var<workgroup> tileWeightQ: array<${S}, ${s*s}>;
  var<workgroup> tileWeightK: array<${S}, ${s*s}>;
  var<workgroup> tileWeightV: array<${S}, ${s*s}>;
  ${u.registerUniforms(T).declareVariables(v,$,b,f,m,_)}
  ${u.mainStart([s,s,1])}
    let batchIndex = workgroup_id.z / uniforms.num_heads;
    let headNumber = workgroup_id.z % uniforms.num_heads;
    let m = workgroup_id.y * TILE_SIZE + local_id.y;
    let n = workgroup_id.x * TILE_SIZE + local_id.x;

    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;
    let biasOffsetQ = headNumber * uniforms.head_size;
    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;
    let biasOffsetV = uniforms.hidden_size + biasOffsetK;

    var valueQ = ${S}(0);
    var valueK = ${S}(0);
    var valueV = ${S}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        let offset = n + (w + local_id.y) * uniforms.ldb;
        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];
        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];
        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];
      }
      workgroupBarrier();
      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {
        let inputTileOffset = TILE_SIZE * local_id.y + k;
        let weightTileOffset = TILE_SIZE * k + local_id.x;
        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];
        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];
        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];
      }

      workgroupBarrier();
    }

    let headOffset = (m * uniforms.N + n) % uniforms.head_size;
    valueQ += bias[headOffset + biasOffsetQ];
    valueK += bias[headOffset + biasOffsetK];
    valueV += bias[headOffset + biasOffsetV];

    let offset = workgroup_id.z * uniforms.M * uniforms.N;
    if (m < uniforms.M && n < uniforms.N) {
      let outputIdx = offset + m * uniforms.N + n;
      output_q[outputIdx] = valueQ;
      output_k[outputIdx] = valueK;
      output_v[outputIdx] = valueV;
    }
  }`};return t.compute({name:"AttentionPrepare",shaderCache:{inputDependencies:["type","type","type"]},getRunData:()=>({outputs:[{dims:n,dataType:t.inputs[0].dataType,gpuDataType:0},{dims:n,dataType:t.inputs[0].dataType,gpuDataType:0},{dims:n,dataType:t.inputs[0].dataType,gpuDataType:0}],dispatchGroup:o,programUniforms:d}),getShaderSource:p},{inputs:l,outputs:[-1,-1,-1]})},Dc=(t,e)=>{let n=sl(t.inputs,e),[r,a,i]=dl(t,n);return Ba(t,r,a,i,t.inputs[4],void 0,void 0,void 0,t.inputs[5],n,e)}}),cl,pl,hl,Lc,Rg=Y(()=>{Dt(),Ie(),it(),Te(),cl=(t,e)=>{if(!t||t.length!==5)throw new Error("BatchNormalization requires 5 inputs");let n=(r,a,i)=>{let s=a.length;if(s!==r.length)throw new Error(`${i}: num dimensions != ${s}`);a.forEach((o,l)=>{if(o!==r[l])throw new Error(`${i}: dim[${l}] do not match`)})};if(t[0].dims.length>1){let r=e.format==="NHWC"?e.spatial?t[0].dims.slice(-1):t[0].dims.slice(-1).concat(t[0].dims.slice(1,t[0].dims.length-1)):t[0].dims.slice(1,e.spatial?2:void 0);n(t[1].dims,r,"Invalid input scale"),n(t[2].dims,r,"Invalid input B"),n(t[3].dims,r,"Invalid input mean"),n(t[4].dims,r,"Invalid input var")}else n(t[1].dims,[1],"Invalid input scale"),n(t[2].dims,[1],"Invalid input B"),n(t[3].dims,[1],"Invalid input mean"),n(t[4].dims,[1],"Invalid input var")},pl=(t,e)=>{let{epsilon:n,spatial:r,format:a}=e,i=t[0].dims,s=r?gt(i[i.length-1]):1,o=a==="NHWC"&&i.length>1?s:1,l=J.size(i)/s,d=at(i.length)&&r,p=d?i.length:i,u=Z("x",t[0].dataType,t[0].dims,s),f=Z("scale",t[1].dataType,t[1].dims,o),m=Z("bias",t[2].dataType,t[2].dims,o),_=Z("inputMean",t[3].dataType,t[3].dims,o),v=Z("inputVar",t[4].dataType,t[4].dims,o),$=be("y",t[0].dataType,p,s),b=()=>{let T="";if(r)T=`let cOffset = ${i.length===1?"0u":a==="NHWC"?`outputIndices[${i.length-1}] / ${s}`:"outputIndices[1]"};`;else if(a==="NCHW")T=`
            ${$.indicesSet("outputIndices","0","0")}
            let cOffset = ${$.indicesToOffset("outputIndices")};`;else{T=`var cIndices = ${f.type.indices}(0);
                       cIndices[0] = outputIndices[${i.length-1}];`;for(let E=1;E<f.rank;E++)T+=`cIndices[${E}] = outputIndices[${E}];`;T+=`let cOffset = ${f.indicesToOffset("cIndices")};`}return T},S=T=>`
  const epsilon = ${n};
  ${T.registerUniform("outputSize","u32").declareVariables(u,f,m,_,v,$)}
  ${T.mainStart()}
  ${T.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
    var outputIndices = ${$.offsetToIndices(`global_idx * ${s}`)};
    ${b()}
    let scale = ${f.getByOffset("cOffset")};
    let bias = ${m.getByOffset("cOffset")};
    let inputMean = ${_.getByOffset("cOffset")};
    let inputVar = ${v.getByOffset("cOffset")};
    let x = ${u.getByOffset("global_idx")};
    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;
    ${$.setByOffset("global_idx","value")}
  }`;return{name:"BatchNormalization",shaderCache:{hint:`${e.epsilon}_${e.format}_${r}_${s}`,inputDependencies:d?["rank","type","type","type","type"]:void 0},getShaderSource:S,getRunData:()=>({outputs:[{dims:t[0].dims,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:d?[{type:"uint32",data:l},...re(i)]:[{type:"uint32",data:l}]})}},hl=t=>qe(t),Lc=(t,e)=>{let{inputs:n,outputCount:r}=t,a=hl({...e,outputCount:r});if(Ne.webgpu.validateInputContent&&cl(n,a),e.trainingMode)throw new Error("BatchNormalization trainingMode is not supported yet.");t.compute(pl(n,a))}}),fl,ml,Fc,Bg=Y(()=>{Ie(),Te(),fl=t=>{if(t[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(t[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(t[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(t[0].dims[2]!==t[1].dims[0])throw new Error("last dimension of input and bias are not the same")},ml=t=>{let e=t[0].dims,n=t[0].dims[2],r=J.size(e)/4,a=t[0].dataType,i=Z("input",a,e,4),s=Z("bias",a,[n],4),o=Z("residual",a,e,4),l=be("output",a,e,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:e,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(r/64)}}),getShaderSource:d=>`
  const channels = ${n}u / 4;
  ${d.declareVariables(i,s,o,l)}

  ${d.mainStart()}
    ${d.guardAgainstOutOfBoundsWorkgroupSizes(r)}
    let value = ${i.getByOffset("global_idx")}
      + ${s.getByOffset("global_idx % channels")} + ${o.getByOffset("global_idx")};
    ${l.setByOffset("global_idx","value")}
  }`}},Fc=t=>{fl(t.inputs),t.compute(ml(t.inputs))}}),gl,Be,Uc,Wc,Vc,Gc,Hc,qc,jc,Kc,Yc,_l,Xc,Qc,Zc,Jc,ka,ep,Ta,tp,np,rp,ap,ip,sp,op,lp,up,dp,cp,pp,hp,fp,mp,gp,_p,wp=Y(()=>{Ye(),Ie(),it(),Te(),gl=(t,e,n,r,a,i)=>{let s=Math.ceil(e/4),o="";typeof a=="string"?o=`${a}(a)`:o=a("a");let l=Z("inputData",n,[s],4),d=be("outputData",r,[s],4);return`
      ${t.registerUniform("vec_size","u32").declareVariables(l,d)}

  ${i??""}

  ${t.mainStart()}
    ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}

    let a = ${l.getByOffset("global_idx")};
    ${d.setByOffset("global_idx",o)}
  }`},Be=(t,e,n,r,a,i=t.dataType)=>({name:e,shaderCache:{hint:a,inputDependencies:["type"]},getShaderSource:s=>gl(s,J.size(t.dims),t.dataType,i,n,r),getRunData:s=>({outputs:[{dims:t.dims,dataType:i}],dispatchGroup:{x:Math.ceil(J.size(s[0].dims)/64/4)},programUniforms:[{type:"uint32",data:Math.ceil(J.size(t.dims)/4)}]})}),Uc=t=>{t.compute(Be(t.inputs[0],"Abs","abs"))},Wc=t=>{t.compute(Be(t.inputs[0],"Acos","acos"))},Vc=t=>{t.compute(Be(t.inputs[0],"Acosh","acosh"))},Gc=t=>{t.compute(Be(t.inputs[0],"Asin","asin"))},Hc=t=>{t.compute(Be(t.inputs[0],"Asinh","asinh"))},qc=t=>{t.compute(Be(t.inputs[0],"Atan","atan"))},jc=t=>{t.compute(Be(t.inputs[0],"Atanh","atanh"))},Kc=t=>qe(t),Yc=(t,e)=>{let n;switch(e.to){case 10:n="vec4<f16>";break;case 1:n="vec4<f32>";break;case 12:n="vec4<u32>";break;case 6:n="vec4<i32>";break;case 9:n="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${e.to}`)}t.compute(Be(t.inputs[0],"Cast",n,void 0,e.cacheKey,e.to))},_l=t=>{let e=t.length>=2&&t[1].data!==0?t[1].getFloat32Array()[0]:$s,n=t.length>=3&&t[2].data!==0?t[2].getFloat32Array()[0]:xs;return qe({min:e,max:n})},Xc=(t,e)=>{let n=t.inputs.length===1?e:_l(t.inputs),r=Qt(t.inputs[0].dataType);t.compute(Be(t.inputs[0],"Clip",a=>`clamp(${a}, clip_min_, clip_max_)`,`
    const clip_min_: vec4<${r}> = vec4(${r}(${n.min}));
    const clip_max_: vec4<${r}> = vec4(${r}(${n.max}));
`,n.cacheKey),{inputs:[0]})},Qc=t=>{t.compute(Be(t.inputs[0],"Ceil","ceil"))},Zc=t=>{t.compute(Be(t.inputs[0],"Cos","cos"))},Jc=t=>{t.compute(Be(t.inputs[0],"Cosh","cosh"))},ka=t=>qe(t),ep=(t,e)=>{let n=Qt(t.inputs[0].dataType);t.compute(Be(t.inputs[0],"Elu",r=>`elu_vf32(${r})`,`
  const elu_alpha_ = ${n}(${e.alpha});

  fn elu_f32(a: ${n}) -> ${n} {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<${n}>) -> vec4<${n}> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,e.cacheKey))},Ta=(t,e="f32")=>`
const r0: ${e} = 0.3275911;
const r1: ${e} = 0.254829592;
const r2: ${e} = -0.284496736;
const r3: ${e} = 1.421413741;
const r4: ${e} = -1.453152027;
const r5: ${e} = 1.061405429;

fn erf_vf32(v: ${t}) -> ${t} {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`,tp=t=>{let e=Qt(t.inputs[0].dataType);t.compute(Be(t.inputs[0],"Erf",n=>`erf_vf32(${n})`,Ta(`vec4<${e}>`,e)))},np=t=>{t.compute(Be(t.inputs[0],"Exp","exp"))},rp=t=>{t.compute(Be(t.inputs[0],"Floor","floor"))},ap=t=>{let e=Qt(t.inputs[0].dataType);t.compute(Be(t.inputs[0],"Gelu",n=>`0.5 * ${n} * (1.0 + erf_vf32(${n} * 0.7071067811865475))`,Ta(`vec4<${e}>`,e)))},ip=(t,e)=>{let n=Qt(t.inputs[0].dataType);t.compute(Be(t.inputs[0],"LeakyRelu",r=>`select(leaky_relu_alpha_ * ${r}, ${r}, ${r} >= vec4<${n}>(0.0))`,`const leaky_relu_alpha_ = ${n}(${e.alpha});`,e.cacheKey))},sp=t=>{t.compute(Be(t.inputs[0],"Not",e=>`!${e}`))},op=t=>{t.compute(Be(t.inputs[0],"Neg",e=>`-${e}`))},lp=t=>{t.compute(Be(t.inputs[0],"Reciprocal",e=>`1.0/${e}`))},up=t=>{let e=Qt(t.inputs[0].dataType);t.compute(Be(t.inputs[0],"Relu",n=>`select(vec4<${e}>(0.0), ${n}, ${n} > vec4<${e}>(0.0))`))},dp=t=>{t.compute(Be(t.inputs[0],"Sigmoid",e=>`(1.0 / (1.0 + exp(-${e})))`))},cp=t=>{t.compute(Be(t.inputs[0],"Sin","sin"))},pp=t=>{t.compute(Be(t.inputs[0],"Sinh","sinh"))},hp=t=>{t.compute(Be(t.inputs[0],"Sqrt","sqrt"))},fp=t=>{t.compute(Be(t.inputs[0],"Tan","tan"))},mp=t=>{t.compute(Be(t.inputs[0],"Tanh","tanh"))},gp=(t,e)=>{let n=Qt(t.inputs[0].dataType);return t.compute(Be(t.inputs[0],"ThresholdedRelu",r=>`select(vec4<${n}>(0.0), ${r}, ${r} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_ = vec4<${n}>(${e.alpha});`,e.cacheKey)),0},_p=t=>{t.compute(Be(t.inputs[0],"Log","log"))}}),wl,yl,yp,Pg=Y(()=>{Ie(),Te(),wp(),wl=t=>{if(t[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(t[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(t[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(t[0].dims[2]!==t[1].dims[0])throw new Error("last dimension of input and bias are not the same")},yl=t=>{let e=t[0].dims.slice();e[2]=e[2]/2;let n=Z("input",t[0].dataType,t[0].dims,4),r=Z("bias",t[0].dataType,[t[0].dims[2]],4),a=be("output",t[0].dataType,e,4),i=J.size(e)/4,s=xt(t[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:e,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)}}),getShaderSource:o=>`
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${t[0].dims[2]/4/2}u;

  ${o.declareVariables(n,r,a)}

  ${Ta(`vec4<${s}>`,s)}

  ${o.mainStart()}
    ${o.guardAgainstOutOfBoundsWorkgroupSizes(i)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${a.setByOffset("global_idx","valueLeft * geluRight")}
  }`}},yp=t=>{wl(t.inputs),t.compute(yl(t.inputs))}}),vl,bl,At,vp,bp,$p,xp,Sp,Ep,kp,Tp,Cp,Ip,Dg=Y(()=>{Ye(),Ie(),Te(),vl=(t,e,n,r,a,i,s,o,l,d,p,u,f)=>{let m,_;typeof o=="string"?m=_=(M,F)=>`${o}((${M}),(${F}))`:typeof o=="function"?m=_=o:(m=o.scalar,_=o.vector);let v=u?e.length:e,$=u?n.length:n,b=u?r.length:r,S=be("outputData",p,b,4),T=Z("aData",l,v,4),E=Z("bData",d,$,4),I;if(a)if(i){let M=J.size(e)===1,F=J.size(n)===1,L=e.length>0&&e[e.length-1]%4===0,W=n.length>0&&n[n.length-1]%4===0;M||F?I=S.setByOffset("global_idx",_(M?`${T.type.value}(${T.getByOffset("0")}.x)`:T.getByOffset("global_idx"),F?`${E.type.value}(${E.getByOffset("0")}.x)`:E.getByOffset("global_idx"))):I=`
            let outputIndices = ${S.offsetToIndices("global_idx * 4u")};
            let offsetA = ${T.broadcastedIndicesToOffset("outputIndices",S)};
            let offsetB = ${E.broadcastedIndicesToOffset("outputIndices",S)};
            ${S.setByOffset("global_idx",_(s||L?T.getByOffset("offsetA / 4u"):`${T.type.value}(${T.getByOffset("offsetA / 4u")}[offsetA % 4u])`,s||W?E.getByOffset("offsetB / 4u"):`${E.type.value}(${E.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}
          `}else I=S.setByOffset("global_idx",_(T.getByOffset("global_idx"),E.getByOffset("global_idx")));else{if(!i)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let M=(F,L,W="")=>{let X=`aData[indexA${L}][componentA${L}]`,A=`bData[indexB${L}][componentB${L}]`;return`
            let outputIndices${L} = ${S.offsetToIndices(`global_idx * 4u + ${L}u`)};
            let offsetA${L} = ${T.broadcastedIndicesToOffset(`outputIndices${L}`,S)};
            let offsetB${L} = ${E.broadcastedIndicesToOffset(`outputIndices${L}`,S)};
            let indexA${L} = offsetA${L} / 4u;
            let indexB${L} = offsetB${L} / 4u;
            let componentA${L} = offsetA${L} % 4u;
            let componentB${L} = offsetB${L} % 4u;
            ${F}[${L}] = ${W}(${m(X,A)});
          `};p===9?I=`
            var data = vec4<u32>(0);
            ${M("data",0,"u32")}
            ${M("data",1,"u32")}
            ${M("data",2,"u32")}
            ${M("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:I=`
            ${M("outputData[global_idx]",0)}
            ${M("outputData[global_idx]",1)}
            ${M("outputData[global_idx]",2)}
            ${M("outputData[global_idx]",3)}
          `}return`
        ${t.registerUniform("vec_size","u32").declareVariables(T,E,S)}

        ${f??""}

        ${t.mainStart()}
        ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${I}
      }`},bl=(t,e,n,r,a,i,s=n.dataType)=>{let o=!J.areEqual(n.dims,r.dims),l=n.dims,d=J.size(n.dims),p=!1,u=!1,f=[o];if(o){let _=Ln.calcShape(n.dims,r.dims,!1);if(!_)throw new Error("Can't perform binary op on the given tensors");l=_,d=J.size(l);let v=J.size(n.dims)===1,$=J.size(r.dims)===1,b=n.dims.length>0&&n.dims[n.dims.length-1]%4===0,S=r.dims.length>0&&r.dims[r.dims.length-1]%4===0;f.push(v),f.push($),f.push(b),f.push(S);let T=1;for(let E=1;E<l.length;E++){let I=n.dims[n.dims.length-E]??1,M=r.dims[r.dims.length-E]??1;if(I===M)T*=I;else break}T%4===0?(u=!0,p=!0):(v||$||b||S)&&(p=!0)}else p=!0;f.push(p);let m=at(n.dims.length)&&at(r.dims.length)&&at(l.length);return{name:t,shaderCache:{hint:e+f.map(_=>_.toString()).join("_"),inputDependencies:m?["rank","rank"]:["dims","dims"]},getShaderSource:_=>vl(_,n.dims,r.dims,l,p,o,u,a,n.dataType,r.dataType,s,m,i),getRunData:()=>({outputs:[{dims:l,dataType:s}],dispatchGroup:{x:Math.ceil(d/64/4)},programUniforms:m?[{type:"uint32",data:Math.ceil(J.size(l)/4)},...re(n.dims),...re(r.dims),...re(l)]:[{type:"uint32",data:Math.ceil(J.size(l)/4)}]})}},At=(t,e,n,r,a,i)=>{t.compute(bl(e,a??"",t.inputs[0],t.inputs[1],n,r,i))},vp=t=>{At(t,"Add",(e,n)=>`${e}+${n}`)},bp=t=>{At(t,"Div",(e,n)=>`${e}/${n}`)},$p=t=>{At(t,"Equal",{scalar:(e,n)=>`u32(${e}==${n})`,vector:(e,n)=>`vec4<u32>(${e}==${n})`},void 0,void 0,9)},xp=t=>{At(t,"Mul",(e,n)=>`${e}*${n}`)},Sp=t=>{let e=Z("input",t.inputs[0].dataType,t.inputs[0].dims).type.value;At(t,"Pow",{scalar:(n,r)=>`pow_custom(${n},${r})`,vector:(n,r)=>`pow_vector_custom(${n},${r})`},`
    fn pow_custom(a : ${e}, b : ${e}) -> ${e} {
      if (b == ${e}(0.0)) {
        return ${e}(1.0);
      } else if (a < ${e}(0.0) && f32(b) != floor(f32(b))) {
        return ${e}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${e}(1.0), round(f32(abs(b) % ${e}(2.0))) != 1.0) * ${e}(${e==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${e}>, b : vec4<${e}>) -> vec4<${e}> {
      // TODO: implement vectorized pow
      return vec4<${e}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `)},Ep=t=>{At(t,"Sub",(e,n)=>`${e}-${n}`)},kp=t=>{At(t,"Greater",{scalar:(e,n)=>`u32(${e}>${n})`,vector:(e,n)=>`vec4<u32>(${e}>${n})`},void 0,void 0,9)},Tp=t=>{At(t,"Less",{scalar:(e,n)=>`u32(${e}<${n})`,vector:(e,n)=>`vec4<u32>(${e}<${n})`},void 0,void 0,9)},Cp=t=>{At(t,"GreaterOrEqual",{scalar:(e,n)=>`u32(${e}>=${n})`,vector:(e,n)=>`vec4<u32>(${e}>=${n})`},void 0,void 0,9)},Ip=t=>{At(t,"LessOrEqual",{scalar:(e,n)=>`u32(${e}<=${n})`,vector:(e,n)=>`vec4<u32>(${e}<=${n})`},void 0,void 0,9)}}),$l,xl,Sl,El,Ap,Mp,Ng=Y(()=>{Ie(),it(),Te(),$l=t=>{if(!t||t.length<1)throw new Error("too few inputs");let e=t[0].dataType,n=t[0].dims.length;for(let r of t){if(r.dataType!==e)throw new Error("input tensors should be one type");if(r.dims.length!==n)throw new Error("input tensors should have the same shape")}},xl=(t,e)=>`
  fn calculateInputIndex(index: u32) -> u32 {
    let sizeInConcatAxis = array<u32, ${t}u>(${e});
    for (var i: u32 = 0u; i < ${t}; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${t}u;
  }`,Sl=(t,e)=>{let n=t.length,r=[];for(let a=0;a<n;++a){let i=e.setByOffset("global_idx",t[a].getByIndices("indices"));n===1?r.push(i):a===0?r.push(`if (inputIndex == ${a}u) { ${i} }`):a===n-1?r.push(`else { ${i} }`):r.push(`else if (inputIndex == ${a}) { ${i} }`)}return r.join(`
`)},El=(t,e)=>{let n=t[0].dims.slice();if(e>=n.length||e<-1*n.length)throw new Error("axis specified for concat doesn't match input dimensionality");let r=e<0?n.length+e:e,a=n.slice(0);for(let E=1;E<t.length;E++){let I=t[E].dims.slice();for(let M=0;M<n.length;M++)if(M===r)a[r]+=I[M];else if(n[M]!==I[M])throw new Error("non concat dimensions must match")}let i=J.size(a),s=new Array(t.length),o=new Array(t.length),l=t[0].dataType,d=0,p=[],u=[],f=[],m=[{type:"uint32",data:i}];for(let E=0;E<t.length;++E)d+=t[E].dims[r],s[E]=d,f.push(at(t[E].dims.length)),u.push(f[E]?t[E].dims.length:t[E].dims),o[E]=Z(`input${E}`,l,u[E]),p.push(f[E]?"rank":"dims"),m.push({type:"uint32",data:s[E]});for(let E=0;E<t.length;++E)f[E]&&m.push(...re(t[E].dims));let _=at(a.length);_&&m.push(...re(a));let v=_?a.length:a,$=be("output",l,v),b=$.indicesGet("indices",r),S=Array.from(Array(s.length).keys()).map(E=>`uniforms.sizeInConcatAxis${E}`).join(","),T=E=>`

  ${(()=>{E.registerUniform("outputSize","u32");for(let I=0;I<t.length;I++)E.registerUniform(`sizeInConcatAxis${I}`,"u32");return E.declareVariables(...o,$)})()}

  ${xl(s.length,S)}

  ${E.mainStart()}
    ${E.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

    var indices = ${$.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${b});
    if (inputIndex != 0u) {
      let sizeInConcatAxis = array<u32, ${s.length}u>(${S});
      ${b} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${Sl(o,$)}
  }`;return{name:"Concat",shaderCache:{hint:`${e}`,inputDependencies:p},getRunData:()=>({outputs:[{dims:a,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:m}),getShaderSource:T}},Ap=(t,e)=>{$l(t.inputs),t.compute(El(t.inputs,e.axis))},Mp=t=>qe({axis:t.axis})}),Vn,ks,Sn=Y(()=>{Ie(),Vn=(t,e)=>{switch(t.activation){case"Relu":return{activationFunction:"",applyActivation:`value = max(value, ${e}(0.0));`};case"Sigmoid":return{activationFunction:"",applyActivation:`value = (${e}(1.0) / (${e}(1.0) + exp(-value)));`};case"Clip":return{activationFunction:`const clip_min_=${e}(${t.clipMin});const clip_max_=${e}(${t.clipMax});`,applyActivation:"value = clamp(value, clip_min_, clip_max_);"};default:return{activationFunction:"",applyActivation:""}}},ks=t=>{let e=t?.activation||"";if(e==="Clip"){let[n,r]=t?.activation_params||[$s,xs];return{activation:e,clipMax:r,clipMin:n,activationCacheKey:`${e}:${n},${r}`}}return{activation:e,activationCacheKey:e}}}),lt,Ts,Cs=Y(()=>{lt=(t,e)=>{switch(t){case 1:return e;case 2:return`vec2<${e}>`;case 3:return`vec3<${e}>`;case 4:return`vec4<${e}>`;default:throw new Error(`${t}-component is not supported.`)}},Ts=t=>`
      ${t?"value = value + getBiasByOutputCoords(coords);":""}
      `}),Is,Op=Y(()=>{Is=t=>`
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    i32(${t}.x), i32(${t}.y), i32(${t}.z), 1));
}
`}),kl,Tl,Pa,_i,Cl,Da,Il,As,Va=Y(()=>{Ie(),Te(),Sn(),Cs(),kl=(t,e)=>t?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${e?", batchIndices":""});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${e?", batchIndices":""});
        `,Tl=(t,e)=>t?`
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${e===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${e===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${e===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`,Pa=(t,e,n="f32",r,a=!1,i=32,s=!1,o=32)=>{let l=e[1]*t[1],d=e[0]*t[0],p=a?l:i,u=a?i:l,f=p/e[0],m=i/e[1];if(!((a&&f===4&&t[1]===4||!a&&(f===3||f===4))&&p%e[0]===0&&i%e[1]===0&&t[0]===4))throw new Error(`If transposeA ${a} is true, innerElementSize ${f} and workPerThread[1] ${t[1]} must be 4.
      Otherwise, innerElementSize ${f} must be 3 or 4.
  tileAWidth ${p} must be divisible by workgroupSize[0]${e[0]}. tileInner ${i} must be divisible by workgroupSize[1] ${e[1]}. colPerThread ${t[0]} must be 4.`);return`
var<workgroup> mm_Asub: array<array<vec${f}<${n}>, ${p/f}>, ${u}>;
var<workgroup> mm_Bsub: array<array<vec4<${n}>, ${d/t[0]}>, ${i}>;

const rowPerThread = ${t[1]};
const colPerThread = ${t[0]};
const innerElementSize = ${f};
const tileInner = ${i};

@compute @workgroup_size(${e[0]}, ${e[1]}, ${e[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${s?"0":"i32(globalId.z)"};
  ${r?`let batchIndices = ${r.offsetToIndices("u32(batch)")};`:""}
  let globalRowStart = i32(workgroupId.y) * ${l};

  let numTiles = ${s?`${Math.ceil(o/i)}`:"(uniforms.dimInner - 1) / tileInner + 1"};
  var kStart = ${s?`i32(globalId.z) * ${o}`:"0"};

  var acc: array<vec4<${n}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${m};
  for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${kl(a,r)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${m}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${r?", batchIndices":""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${f===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${Tl(a,f)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`},_i=(t,e)=>t?`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${e?", batchIndices":""});
            `:`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${e?", batchIndices":""});
            `,Cl=t=>t?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",Da=(t,e,n="f32",r,a=!1,i=32,s=!1,o=32,l=!1)=>{let d=t[1]*e[1],p=t[0]*e[0],u=a?d:i,f=a?i:d;if(!(f%e[1]===0&&u%e[0]===0&&i%e[1]===0))throw new Error(`tileAHight ${f} must be divisible by workgroupSize[1]${e[1]}, tileAWidth ${u} must be divisible by workgroupSize[0]${e[0]}, tileInner ${i} must be divisible by workgroupSize[1]${e[1]}`);let m=f/e[1],_=u/e[0],v=i/e[1],$=l?`
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${d};
    let globalColStart = i32(workgroupId.x) * ${p};

    // Loop over shared dimension.
    for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${f}; inputRow = inputRow + ${e[1]}) {
        for (var inputCol = localCol; inputCol < ${u}; inputCol = inputCol + ${e[0]}) {
          ${_i(a,r)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${i}; inputRow = inputRow + ${e[1]}) {
            for (var inputCol = localCol; inputCol < ${p}; inputCol = inputCol + ${e[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${r?", batchIndices":""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${n}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${e[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${a?`mm_Asub[k][localRow + innerRow * ${e[1]}];`:`mm_Asub[localRow + innerRow * ${e[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${e[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${e[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    `:`
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${d};

let tileRowA = i32(localId.y) * ${m};
let tileColA = i32(localId.x) * ${_};
let tileRowB = i32(localId.y) * ${v};
// Loop over shared dimension.
for (var t = 0; t < numTiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${m}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${_}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${_i(a,r)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${v}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${r?", batchIndices":""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${n}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${Cl(a)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;return`
  var<workgroup> mm_Asub : array<array<${n}, ${u}>, ${f}>;
  var<workgroup> mm_Bsub : array<array<${n}, ${p}>, ${i}>;
  const rowPerThread = ${t[1]};
  const colPerThread = ${t[0]};
  const tileInner = ${i};

@compute @workgroup_size(${e[0]}, ${e[1]}, ${e[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${s?"0":"i32(globalId.z)"};
    ${r?`let batchIndices = ${r.offsetToIndices("u32(batch)")};`:""}
    let numTiles = ${s?`${Math.ceil(o/i)}`:"(uniforms.dimInner - 1) / tileInner + 1"};
    var kStart = ${s?`i32(globalId.z) * ${o}`:"0"};

    var acc : array<array<${n}, colPerThread>, rowPerThread>;

    // Without this initialization strange values show up in acc.
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = 0.0;
      }
    }
    ${$}
  }
`},Il=(t,e,n,r,a,i=!1)=>{let[s,o,l]=a,[d,p,u,f]=r,m=Tr(s,l),_=Tr(o,l),v=xt(r[0].type.tensor),$=()=>{let S=p.rank,T=d.rank,E=`var aIndices: ${p.type.indices};`;for(let I=S-2-1,M=T-1;I>=0;I--,M--)E+=`
aIndices[${I}] = ${T>1?`batchIndices[${M}]`:"batchIndices"};`;return m.forEach(I=>{E+=`
aIndices[${I}] = 0;`}),E+=`
aIndices[${S-2}] = u32(row);
                   aIndices[${S-1}] = u32(colIn);`,E},b=()=>{let S=u.rank,T=d.rank,E=`var bIndices: ${u.type.indices};`;for(let I=S-2-1,M=T-1;I>=0;I--,M--)E+=`
bIndices[${I}] = ${T>1?`batchIndices[${M}]`:"batchIndices"};`;return _.forEach(I=>{E+=`
bIndices[${I}] = 0;`}),E+=`
bIndices[${S-2}] = u32(row);
                   bIndices[${S-1}] = u32(colIn);`,E};return`
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${d.type.indices}) -> ${lt(t,v)} {
      var value = ${lt(t,v)}(0.0);
      let col = colIn * ${t};
      if(row < uniforms.dimAOuter && col < uniforms.dimInner)
      {
        ${$()}
        value = ${p.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${d.type.indices}) -> ${lt(t,v)} {
      var value = ${lt(t,v)}(0.0);
      let col = colIn * ${t};
      if(row < uniforms.dimInner && col < uniforms.dimBOuter)
      {
        ${b()}
        value = ${u.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${lt(t,v)}) {
      let col = colIn * ${t};
      if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${e?`value = value + ${i?"bias[colIn]":`${lt(t,v)}(bias[row])`};`:""}
        ${n}
        ${f.setByIndices("vec3<u32>(coords)","value")}
      }
    }
    `},As=(t,e,n,r,a=!1)=>{let i=t[0].dims,s=t[1].dims,o=i.slice(0,-2),l=s.slice(0,-2),d=r?r.slice(0,-2):n.slice(0,-2),p=at(d.length),u=p?d.length:d,f=Ss("batchDims",t[0].dataType,u,1),m=J.size(d),_=i[i.length-2],v=i[i.length-1],$=s[s.length-1],b=v%4===0&&$%4===0,S=_<=8?[4,1,1]:[4,4,1],T=[8,8,1],E=[Math.ceil($/T[0]/S[0]),Math.ceil(_/T[1]/S[1]),Math.ceil(m/T[2]/S[2])],I=xt(t[0].dataType),M=b?4:1,F=[...o,_,v/M],L=at(F.length),W=L?F.length:F,X=[...l,v,$/M],A=at(X.length),q=A?X.length:X,te=[m,_,$/M],K=Z("a",t[0].dataType,W,M),B=Z("b",t[1].dataType,q,M),U=be("result",t[0].dataType,te.length,M),G=[K,B],ne=[{type:"int32",data:_},{type:"int32",data:$},{type:"int32",data:v}];p&&ne.push(...re(d)),L&&ne.push(...re(F)),A&&ne.push(...re(X));let oe=[];oe.push(L?"rank":"dims"),oe.push(A?"rank":"dims");let ye=t.length>2,{activationFunction:V,applyActivation:ie}=Vn(e,U.type.value),$e=Il(M,ye,ie,[f,K,B,U],[o,l,d],a);if(ye){let Pe=a?M:1;G.push(Z("bias",t[2].dataType,t[2].dims.length,Pe)),ne.push(...re(t[2].dims)),oe.push("rank")}ne.push(...re(te));let Le=Pe=>`
  ${Pe.registerUniform("dimAOuter","i32").registerUniform("dimBOuter","i32").registerUniform("dimInner","i32").registerInternalVariables(f).declareVariables(...G,U)}
  ${V}
  ${$e}
  ${b?Pa(S,T,I,f):Da(S,T,I,f)}
                   `;return{name:"MatMul",shaderCache:{hint:e.activationCacheKey+`${S}${b}${a}`,inputDependencies:oe},getRunData:()=>({outputs:[{dims:n,dataType:t[0].dataType}],dispatchGroup:{x:E[0],y:E[1],z:E[2]},programUniforms:ne}),getShaderSource:Le}}}),Al,zp,Lg=Y(()=>{xn(),Te(),Sn(),Cs(),Op(),Va(),Al=(t,e,n,r,a=!1,i,s=4,o=4,l=4,d="f32")=>{let p=X=>{switch(X){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${d}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${X} is not supported.`)}},u=X=>{switch(X){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw new Error(`innerElementSize ${X} is not supported.`)}},f=t?`
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    `:`
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `,m=t?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,_=t?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",v=t?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",$=t?"row":"col",b=t?"col":"row",S=`
    let inChannels = i32(uniforms.w_shape[2]);
    let outWidth = ${t?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
    let outRow = ${$} / outWidth;
    let outCol = ${$} % outWidth;

    let WRow = ${b} / (filterDims[1] * inChannels);
    let WCol = ${b} / inChannels % filterDims[1];
    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];
    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];
    let xCh = ${b} % inChannels;
    var resData = ${lt(s,d)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${_} && xCol >= 0 && xCol < ${v}) {
      ${f}
      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));
      ${p(s)}
    }
    return resData;`,T=t?e&&r?`
    let col = colIn * ${s};
    ${S}`:`
    let col = colIn * ${s};
    if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
      ${S}
    }
    return ${lt(s,d)}(0.0);`:r&&n?`
    let col = colIn * ${s};
    ${S}`:`
    let col = colIn * ${s};
    if (row < uniforms.dimInner && col < uniforms.dimBOuter) {
      ${S}
    }
    return ${lt(s,d)}(0.0);`,E=`${u(o)}`,I=lt(l,d),M=lt(t?s:o,d),F=lt(t?o:s,d),{activationFunction:L,applyActivation:W}=Vn(i,I);return`
    ${L}
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${M} {
      ${t?T:E}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${F} {
      ${t?E:T}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${I}) {
      let col = colIn * ${l};
      if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)
      {
      var value = valueIn;
      let outWidth = ${t?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      ${m}
      ${Ts(a)}
      ${W}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`},zp=(t,e,n,r,a,i,s,o)=>{let l=e.format==="NHWC",d=l?t[0].dims[3]:t[0].dims[1],p=n[0],u=l?n[2]:n[3],f=l?n[1]:n[2],m=l?n[3]:n[1],_=l&&(d%4===0||d%3===0)&&m%4===0,v=l?m:u*f,$=l?u*f:m,b=[8,8,1],S=r<=8?[4,1,1]:[4,4,1],T=[Math.ceil(v/b[0]/S[0]),Math.ceil($/b[1]/S[1]),Math.ceil(p/b[2]/S[2])];rt("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${T}`);let E=_?l&&d%4!==0?3:4:1,I=b[1]*S[1],M=b[0]*S[0],F=Math.max(b[0]*E,b[1]),L=r%I===0,W=a%M===0,X=i%F===0,A=_?[E,4,4]:[1,1,1],q=xt(t[0].dataType),te=_?4:1,K=[{type:"int32",data:r},{type:"int32",data:a},{type:"int32",data:i}],B=Z("x",t[0].dataType,t[0].dims.length,E===3?1:E),U=Z("w",t[1].dataType,t[1].dims.length,te),G=[B,U];K.push(...re(t[0].dims)),K.push(...re(t[1].dims));let ne=`
      fn setOutputAtIndex(flatIndex : i32, value : ${_?`vec4<${q}>`:q}) {
        result[flatIndex] = ${_?`vec4<${q}>`:q}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${_?`vec4<${q}>`:q}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${_?"/ 4":""}, value);
      }`;if(s){let ye=Z("bias",t[2].dataType,t[2].dims.length,te);G.push(ye),K.push(...re(t[2].dims)),ne+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${_?`vec4<${q}>`:q} {
          return bias[coords.${l?"w":"y"}${_?"/ 4":""}];
        }`}let oe=be("result",t[0].dataType,n.length,te);return K.push(...re(n)),{name:"Conv2DMatMul",shaderCache:{hint:e.cacheKey},getRunData:()=>({outputs:[{dims:n,dataType:t[0].dataType}],dispatchGroup:{x:T[0],y:T[1],z:T[2]},programUniforms:K}),getShaderSource:ye=>`
        ${Is("uniforms.result_strides")}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${ye.registerUniform("dimAOuter","i32").registerUniform("dimBOuter","i32").registerUniform("dimInner","i32").declareVariables(...G,oe)}
        const filterDims : vec2<i32> = vec2<i32>(${e.kernelShape[0]}, ${e.kernelShape[1]});
        const pad : vec2<i32> = vec2<i32>(${e.pads[0]}, ${e.pads[1]});
        const stride : vec2<i32> = vec2<i32>(${e.strides[0]}, ${e.strides[1]});
        const dilation : vec2<i32> = vec2<i32>(${e.dilations[0]}, ${e.dilations[1]});
        ${ne}
        ${Al(l,L,W,X,s,e,A[0],A[1],A[2],q)}
            ${_?Pa(S,b,q,void 0,!l,F):Da(S,b,q,void 0,!l,F,!1,void 0,o)}`}}}),Xi,Fg=Y(()=>{Ie(),Te(),Pp(),Sn(),Xi=(t,e,n)=>{let r=t.length>2,a=r?"value += b[output_channel];":"",i=t[0].dims,s=t[1].dims,o=s[0]/e.group,l=e.format==="NHWC",d=Zi(i,s,e.dilations,e.pads,e.strides,l),p=J.size(d),u=be("output",t[0].dataType,d),{activationFunction:f,applyActivation:m}=Vn(e,u.type.value),_=Z("x",t[0].dataType,i),v=Z("w",t[1].dataType,s),$=[_,v];r&&$.push(Z("b",t[2].dataType,t[2].dims));let b=S=>`
  const strides: vec2<u32> = vec2(${e.strides[0]}u, ${e.strides[1]}u);
  const pads: vec2<u32> = vec2(${e.pads[0]}u, ${e.pads[1]}u);

  ${S.declareVariables(...$,u)}

  ${f}

  ${S.mainStart()}
    ${S.guardAgainstOutOfBoundsWorkgroupSizes(p)}

    let outputIndices = ${u.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${l?3:1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${l?1:2}], outputIndices[${l?2:3}]) * strides - pads;
    let group_id: u32 = output_channel / ${o}u;

    var value: ${u.type.value} = ${u.type.value}(0);
    for (var wInChannel: u32 = 0u; wInChannel < ${s[1]}u; wInChannel++) {
      let input_channel = group_id * ${s[1]}u + wInChannel;
      for (var wHeight: u32 = 0u; wHeight < ${s[2]}u; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * ${e.dilations[0]}u;

        if (xHeight < 0u || xHeight >= ${i[l?1:2]}u) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < ${s[3]}u; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * ${e.dilations[1]}u;
          if (xWidth < 0u || xWidth >= ${i[l?2:3]}u) {
            continue;
          }

          let xVal = ${l?_.get("batch","xHeight","xWidth","input_channel"):_.get("batch","input_channel","xHeight","xWidth")};
          let wVal = ${v.get("output_channel","wInChannel","wHeight","wWidth")};
          value += xVal*wVal;
        }
      }
    }
    ${a}
    ${m}
    ${u.setByOffset("global_idx","value")}
  }`;return{name:"GroupedConv",shaderCache:{hint:e.cacheKey},getRunData:()=>({outputs:[{dims:n?n(d):d,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)}}),getShaderSource:b}}}),Qi,Ml,Rp,Bp=Y(()=>{Ie(),Va(),Te(),Sn(),Qi=(t,e,n,r,a=!1)=>{let i=t[0].dims,s=t[1].dims,o=i[i.length-2],l=s[s.length-1],d=i[i.length-1],p=gt(l),u=gt(d),f=gt(o),m=J.size(n)/p/f,_=t.length>2,v=r?r.slice(0,-2):n.slice(0,-2),$=[J.size(v),o,l],b=[{type:"uint32",data:m},{type:"uint32",data:o},{type:"uint32",data:l},{type:"uint32",data:d},...re(v),...re(i),...re(s)];_&&b.push(...re(t[2].dims)),b.push(...re($));let S=T=>{let E=Ss("batch_dims",t[0].dataType,v.length),I=Z("a",t[0].dataType,i.length,u),M=Z("b",t[1].dataType,s.length,p),F=be("output",t[0].dataType,$.length,p),{activationFunction:L,applyActivation:W}=Vn(e,F.type.value),X=[I,M],A="";if(_){let ne=a?p:1;X.push(Z("bias",t[2].dataType,t[2].dims.length,ne)),A=`${a?`value += bias[col / ${ne}];`:`value += ${F.type.value}(bias[row + i]);`}`}let q=i.slice(0,-2),te=s.slice(0,-2),K=Tr(q,v),B=Tr(te,v),U=(ne,oe)=>{let ye=ne.rank,V=ne.name;if(ye===2)return`var ${V}_indices = ${ne.type.indices}(0u, 0u);`;let ie=E.rank,$e=`var ${V}_indices: ${ne.type.indices};`;for(let Le=ye-2-1,Pe=ie-1;Le>=0;Le--,Pe--)$e+=`
${V}_indices[${Le}] = ${ie>1?`batch_indices[${Pe}]`:"batch_indices"};`;return oe.forEach(Le=>{$e+=`
${V}_indices[${Le}] = 0;`}),$e+=`${V}_indices[${ye-2}] = 0u;
                     ${V}_indices[${ye-1}] = 0u;`,$e},G=()=>{let ne=`var a_data: ${I.type.value};`;for(let oe=0;oe<u;oe++)ne+=`
              let b_data${oe} = b[(b_offset + (k + ${oe}) * uniforms.N + col) / ${p}];`;for(let oe=0;oe<f;oe++){ne+=`a_data = a[(a_offset + (row + ${oe}) * uniforms.K + k) / ${u}];`;for(let ye=0;ye<u;ye++)ne+=`
            values[${oe}] = fma(${M.type.value}(a_data${u===1?"":`[${ye}]`}), b_data${ye}, values[${oe}]);
`}return ne};return`
  ${T.registerUniform("outputSize","u32").registerUniform("M","u32").registerUniform("N","u32").registerUniform("K","u32").registerInternalVariables(E).declareVariables(...X,F)}
  ${L}
  ${T.mainStart()}
    ${T.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
    let col = (global_idx % (uniforms.N / ${p})) * ${p};
    var index1 = global_idx / (uniforms.N / ${p});
    let stride1 = uniforms.M / ${f};
    let row = (index1 % stride1) * ${f};
    let batch = index1 / stride1;

    ${n.length===2?"":`let batch_indices = ${E.offsetToIndices("batch")};`}
    ${U(I,K)}
    let a_offset = ${I.indicesToOffset("a_indices")};
    ${U(M,B)}
    let b_offset = ${M.indicesToOffset("b_indices")};
    var values: array<${F.type.value}, ${f}>;
    for (var k: u32 = 0u; k < uniforms.K; k = k + ${u}) {
      ${G()}
    }
    for (var i = 0u; i < ${f}u; i++) {
      var value = values[i];
      ${A}
      ${W}
      let cur_indices = ${F.type.indices}(batch, row + i, col);
      let offset = ${F.indicesToOffset("cur_indices")};
      ${F.setByOffset(`offset / ${p}`,"value")};
    }
  }
  `};return{name:"MatMulNaive",shaderCache:{hint:`${e.activationCacheKey}_${p}_${u}_${f}_${a}`,inputDependencies:_?["rank","rank","rank"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:n,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(m/64)},programUniforms:b}),getShaderSource:S}},Ml=t=>{if(!t||t.length!==2)throw new Error("MatMul requires 2 inputs.");if(t[0].dims[t[0].dims.length-1]!==t[1].dims[t[1].dims.length-2])throw new Error("shared dimension does not match.")},Rp=t=>{Ml(t.inputs);let e=Ln.calcShape(t.inputs[0].dims,t.inputs[1].dims,!0);if(!e)throw new Error("Can't use matmul on the given tensors");let n=e[e.length-1],r=t.inputs[0].dims[t.inputs[0].dims.length-1];n<8&&r<8?t.compute(Qi(t.inputs,{activation:"",activationCacheKey:""},e)):t.compute(As(t.inputs,{activation:"",activationCacheKey:""},e))}}),Zi,wi,Ol,yi,Ji,zl,Rl,es,Pp=Y(()=>{Ie(),it(),Lg(),Va(),Fg(),Sn(),Bp(),Or(),Zi=(t,e,n,r,a,i)=>{let s=t[0],o=t.slice(i?1:2,i?3:4),l=o.length,d=e[0],p=e.slice(2).map((f,m)=>f+(f-1)*(n[m]-1)),u=o.map((f,m)=>f+r[m]+r[m+l]).map((f,m)=>Math.floor((f-p[m]+a[m])/a[m]));return u.splice(0,0,s),u.splice(i?3:1,0,d),u},wi=[2,3,1,0],Ol=(t,e)=>{if(!t||t.length!==2&&t.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(t[0].dims.length!==4&&t[0].dims.length!==3)throw new Error("currently only support conv 1D and 2D");if(t[0].dims.length!==t[1].dims.length)throw new Error("filter does not have same dimension as input");let n=t[0].dims[e.format==="NHWC"?t[0].dims.length-1:1],r=t[1].dims[1]*e.group;if(n!==r)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(t.length===3&&(t[2].dims.length!==1||t[1].dims[0]!==t[2].dims[0]))throw new Error("invalid bias");let a=t[0].dims.length-2;if(e.dilations.length!==a)throw new Error(`dilations should be ${a}D`);if(e.strides.length!==a)throw new Error(`strides should be ${a}D`);if(e.pads.length!==a*2)throw new Error(`pads should be ${a*2}D`);if(e.kernelShape.length!==0&&e.kernelShape.length!==t[1].dims.length-2)throw new Error("invalid kernel shape")},yi=(t,e)=>{let n=t.kernelShape.slice();for(let i=2;i<e[1].dims.length;++i)n[i-2]===0&&(n[i-2]=e[1].dims[i]);let r=t.pads.slice();za.adjustPadsBasedOnAutoPad(e[0].dims,t.strides,t.dilations,n,r,t.format==="NHWC",t.autoPad);let a=Object.assign({},t);return Object.assign(a,{kernelShape:n,pads:r,cacheKey:t.cacheKey}),a},Ji=t=>{let e=ks(t),n=t.format,r=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][t.auto_pad],a=t.dilations,i=t.group,s=t.kernel_shape,o=t.pads,l=t.strides,d=t.w_is_const();return qe({autoPad:r,format:n,dilations:a,group:i,kernelShape:s,pads:o,strides:l,wIsConst:d,...e})},zl=(t,e,n)=>{let r=yi(n,e),a=n.format==="NHWC";if(n.group!==1){t.compute(Xi(e,r));return}let i=e.length===3,s=e[0].dims[a?1:2],o=e[0].dims[a?2:3],l=e[0].dims[a?3:1],d=e[1].dims[2],p=e[1].dims[3],u=Zi(e[0].dims,e[1].dims,n.dilations,r.pads,n.strides,a),f=u[a?1:2],m=u[a?2:3],_=u[a?3:1],v=a&&d===s&&p===o&&n.pads[0]===0&&n.pads[1]===0;if(v||d===1&&p===1&&n.dilations[0]===1&&n.dilations[1]===1&&n.strides[0]===1&&n.strides[1]===1&&n.pads[0]===0&&n.pads[1]===0){let M=u[0],F,L,W,X=[];if(a){let te=t.kernelCustomData.wT??t.compute(cn(e[1],wi),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];if(n.wIsConst&&!t.kernelCustomData.wT&&(t.kernelCustomData.wT=te),v){let K=s*o*l;F=e[0].reshape([1,M,K]),L=te.reshape([1,K,_]),W=[1,M,_]}else F=e[0].reshape([M,s*o,l]),L=te.reshape([1,l,_]),W=[M,f*m,_];X.push(F),X.push(L)}else F=e[0].reshape([M,l,s*o]),L=e[1].reshape([1,_,l]),W=[M,_,f*m],X.push(L),X.push(F);i&&X.push(e[2]);let A=W[2],q=X[0].dims[X[0].dims.length-1];A<8&&q<8?t.compute(Qi(X,r,u,W,a),{inputs:X}):t.compute(As(X,r,u,W,a),{inputs:X});return}let $=!0,b=t.kernelCustomData.wT??t.compute(cn(e[1],wi),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!t.kernelCustomData.wT&&(t.kernelCustomData.wT=b);let S=[e[0],b];i&&S.push(e[2]);let T=a?f*m:_,E=a?_:f*m,I=d*p*l;t.compute(zp(S,r,u,T,E,I,i,$),{inputs:S})},Rl=(t,e)=>{let n=e.format==="NHWC",r=[t.inputs[0].reshape(n?[t.inputs[0].dims[0],1,t.inputs[0].dims[1],t.inputs[0].dims[2]]:[t.inputs[0].dims[0],t.inputs[0].dims[1],1,t.inputs[0].dims[2]]),t.inputs[1].reshape([t.inputs[1].dims[0],t.inputs[1].dims[1],1,t.inputs[1].dims[2]])];t.inputs.length===3&&r.push(t.inputs[2]);let a=[0,e.pads[0],0,e.pads[1]],i=[1].concat(e.strides),s=[1].concat(e.dilations),o=[1].concat(e.kernelShape),l=yi({...e,pads:a,strides:i,dilations:s,kernelShape:o},r);t.compute(Xi(r,l,d=>n?[d[0],d[2],d[3]]:[]))},es=(t,e)=>{Ol(t.inputs,e),t.inputs[0].dims.length===3?Rl(t,e):zl(t,t.inputs,e)}}),Bl,Dp,Ug=Y(()=>{xn(),Te(),Sn(),Cs(),Op(),Va(),Bl=(t,e=!1,n,r=4)=>{let a=lt(r,"f32"),i=b=>{switch(b){case 1:return"return w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];
            let v1 = w[getIndexFromCoords4D(coord1, vec4<i32>(uniforms.w_shape))];
            let v2 = w[getIndexFromCoords4D(coord2, vec4<i32>(uniforms.w_shape))];
            let v3 = w[getIndexFromCoords4D(coord3, vec4<i32>(uniforms.w_shape))];
            return vec4<f32>(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${b} is not supported.`)}},s=t?`
      let coord = vec4<i32>(batch, iXR, iXC, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, iXR, iXC);
      `,o=t?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,l=t?"outBackprop[1]":"outBackprop[2]",d=t?"outBackprop[2]":"outBackprop[3]",p=t?"row":"col",u=t?"col":"row",f=`
      let inChannels = ${t?"outBackprop[3]":"outBackprop[1]"};
      let outWidth = ${t?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      let outRow = ${p} / outWidth;
      let outCol = ${p} % outWidth;

      let WRow = ${u} / (filterDims[1] * inChannels);
      let WCol = ${u} / inChannels % filterDims[1];
      let xR = f32(outRow - pads[0] + dilation[0] * WRow) / f32(strides[0]);
      let xC = f32(outCol - pads[1] + dilation[1] * WCol) / f32(strides[1]);
      if (xR < 0.0 || xR >= f32(${l}) || fract(xR) > 0.0) {
        return ${a}(0.0);
      }
      if (xC < 0.0 || xC >= f32(${d}) || fract(xC) > 0.0) {
        return ${a}(0.0);
      }
      let iXR = i32(xR);
      let iXC = i32(xC);
      let xCh = ${u} % inChannels;
      ${s}
      return x[getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape))/${r}];`,m=t?`
      let col = colIn * ${r};
      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${f}
      }
      return ${a}(0.0);`:`
      let col = colIn * ${r};
      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {
        ${f}
      }
      return ${a}(0.0);`,_=`
      let col = colIn * ${r};
      let inChannels = ${t?"outBackprop[3]":"outBackprop[1]"};
      let coordX = filterDims.x - 1 - row / (filterDims[1] * inChannels);
      let coordY = filterDims.y - 1 - (row / inChannels) % filterDims[1];
      if (${t?"row < uniforms.dimInner && col < uniforms.dimBOuter":"row < uniforms.dimInner && col < uniforms.dimAOuter"}  && coordX >= 0 && coordY >= 0) {
        let rowInner = row % inChannels;
        let coord = vec4<i32>(coordX, coordY, col, rowInner);
        ${i(r)}
      }
      return ${a}(0.0);
      `,{activationFunction:v,applyActivation:$}=Vn(n,a);return`
      ${v}
  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${a} {
    ${t?m:_}
  }

  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${a} {
    ${t?_:m}
  }

  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${a}) {
    let col = colIn * ${r};
    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
      var value = valueInput;
      let outWidth = ${t?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      ${o}
      ${Ts(e)}
      ${$}
      result[getIndexFromCoords4D(coords, vec4<i32>(uniforms.result_shape))/${r}] = value;
    }
  }`},Dp=(t,e,n,r,a,i,s,o)=>{let l=e.format==="NHWC",d=l?t[0].dims[3]:t[0].dims[1],p=n[0],u=l?n[2]:n[3],f=l?n[1]:n[2],m=l?n[3]:n[1],_=l?d%4===0&&m%4===0:u%4===0&&m%4===0,v=l?m:u*f,$=l?u*f:m,b=_?[8,8,1]:[v<=4||$<=4?4:16,v>4&&$<=4?4:16,1],S=_?[4,4,1]:[v<=4?1:4,v>4&&$<=4?1:4,1],T=[Math.ceil(v/b[0]/S[0]),Math.ceil($/b[1]/S[1]),Math.ceil(p/b[2]/S[2])];rt("verbose",()=>`[conv_backprop_mm_webgpu] dispatch = ${T}`);let E=_?4:1,I=Math.max(b[0]*E,b[1]),M=_?4:1,F=[{type:"int32",data:r},{type:"int32",data:a},{type:"int32",data:i}],L=Z("x",t[0].dataType,t[0].dims.length,M),W=Z("w",t[1].dataType,t[1].dims.length,1),X=be("result",t[0].dataType,n.length,M),A=[L,W];F.push(...re(t[0].dims)),F.push(...re(t[1].dims));let q="";if(s){let te=Z("bias",t[2].dataType,t[2].dims.length,M);A.push(te),F.push(...re(t[2].dims)),q+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${_?"vec4<f32>":"f32"} {
          return bias[coords.${l?"w":"y"}${_?"/ 4":""}];
        }`}return F.push(...re(n)),{name:"Conv2DTransposeMatMul",shaderCache:{hint:e.cacheKey},getRunData:()=>({outputs:[{dims:n,dataType:t[0].dataType}],dispatchGroup:{x:T[0],y:T[1],z:T[2]},programUniforms:F}),getShaderSource:te=>`
        ${Is("uniforms.result_strides")}
        ${te.registerUniform("dimAOuter","i32").registerUniform("dimBOuter","i32").registerUniform("dimInner","i32").declareVariables(...A,X)};
        const outBackprop : vec4<i32> = vec4<i32>(${t[0].dims.join(",")});
        const filterDims : vec2<i32> = vec2<i32>(${e.kernelShape[l?1:2]}, ${e.kernelShape[l?2:3]});
        const effectiveFilterDims : vec2<i32> = filterDims + vec2<i32>(
              ${e.dilations[0]<=1?0:(e.kernelShape[l?1:2]-1)*(e.dilations[0]-1)},
              ${e.dilations[1]<=1?0:(e.kernelShape[l?2:3]-1)*(e.dilations[1]-1)});
        const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${e.pads[0]+e.pads[2]})/2,
                                         i32(effectiveFilterDims[1]) - 1 - (${e.pads[1]+e.pads[3]})/2);
        const strides : vec2<i32> = vec2<i32>(${e.strides[0]}, ${e.strides[1]});
        const dilation : vec2<i32> = vec2<i32>(${e.dilations[0]}, ${e.dilations[1]});
        const dimAOuter : i32 = ${r};
        const dimBOuter : i32 = ${a};
        const dimInner : i32 = ${i};
        ${q}
        ${Bl(l,s,e,E)}
        ${_?Pa(S,b,"f32",void 0,!l,I):Da(S,b,"f32",void 0,!l,I,!1,void 0,o)}`}}}),Pl,ts,Wg=Y(()=>{xn(),Ie(),Te(),Pl=(t,e,n,r,a,i,s=!1,o)=>{let l=n.format==="NHWC",d=l?1:2,p=l?2:3,u=l?3:1,f=J.size(r),m=s?2:1,_=n.group,v=e[1].dims,$=v[0]/_,b=v[1],S=`
  fn setOutputAtIndex(flatIndex : u32, value : ${s?`vec4<${o}>`:o}) {
    result[flatIndex] = ${s?`vec4<${o}>`:o}(value);
  }`;a&&(S+=`
    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${s?`vec4<${o}>`:o} {
      return bias[coords.${l?"w":"y"}${s?"/ 4":""}];
    }`);let T=s?4:1,E=Z("W",e[1].dataType,e[1].dims,T),I=Z("Dy",e[0].dataType,e[0].dims,T),M=[I,E];a&&M.push(Z("bias",e[2].dataType,[r[u]],T));let F=be("result",e[0].dataType,r,T),L=`{
        let batch: u32 = ${i?"global_id.z":"workgroup_id.z"} / outShape[1];
        let r = ${i?"global_id.z":"workgroup_id.z"} % outShape[1];
        let c = ${i?"global_id.y":"workgroup_id.y"} * ${m};
        let d1: u32 = ${i?"global_id.x":"workgroup_id.x"} * 4;

        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(pads);

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd: array<vec4<${o}>, ${m}>;
        for (var i = 0; i < ${m}; i++) {
          dotProd[i] = vec4<${o}>(0.0);
        }
        for (var wR: u32 = 0; wR < filterDims[0]; wR = wR + 1) {
          var dyR = (${o}(dyCorner.x) + ${o}(wR)) / ${o}(strides.x);
          let wRPerm = filterDims[0] - 1 - wR;
          if (dyR < 0.0 || dyR >= ${o}(outBackprop[1]) ||
              fract(dyR) > 0.0 || wRPerm < 0) {
            continue;
          }
          let idyR: u32 = u32(dyR);

          for (var wC: u32 = 0; wC < filterDims[1]; wC = wC + 1) {
            let dyC = (${o}(dyCorner.y) + ${o}(wC)) / ${o}(strides.y);
            let dyC2 = (${o}(dyCorner.y) + 1.0 + ${o}(wC)) / ${o}(strides.y);
            let wCPerm = filterDims[1] - 1 - wC;
            if (wCPerm < 0) {
              continue;
            }
            var bDyCVal = true;
            var bDyCVal2 = true;
            if (dyC < 0.0 || dyC >= ${o}(outBackprop[2]) ||
                fract(dyC) > 0.0) {
              bDyCVal = false;
            }
            if (dyC2 < 0.0 || dyC2 >= ${o}(outBackprop[2]) ||
                fract(dyC2) > 0.0) {
              bDyCVal2 = false;
            }

            let idyC: u32 = u32(dyC);
            let idyC2: u32 = u32(dyC2);
            if (bDyCVal && bDyCVal2) {
              let d2Length = outBackprop[3];
              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${E.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${E.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${E.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${E.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${I.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<${o}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;

                xValue =  ${I.get("batch","idyR","idyC2","d2")};

                dotProd[1] = dotProd[1] + vec4<${o}>(dot(xValue, wValue0),
                                                    dot(xValue, wValue1),
                                                    dot(xValue, wValue2),
                                                    dot(xValue, wValue3));
              }
            } else if (bDyCVal) {
              let d2Length = outBackprop[${u}];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${E.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${E.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${E.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${E.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${I.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<${o}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;
              }
            } else if (bDyCVal2) {
              let d2Length = outBackprop[3];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${E.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${E.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${E.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${E.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${I.get("batch","idyR","idyC2","d2")};
                let tmpval = vec4<${o}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[1] = dotProd[1] + tmpval;
              }
            }
          }
        }

        for (var i: u32 = 0; i < ${m}; i = i + 1) {
          let value = dotProd[i] + ${a?"bias[c+i]":`vec4<${o}>(0.0)`};
          ${F.set("batch","r","c + i","d1","value")};
        }
      }`,W=`
          let outputIndices = ${F.offsetToIndices("global_idx")};
          let batch = ${F.indicesGet("outputIndices",0)};
          let d1 = ${F.indicesGet("outputIndices",u)};
          let r = ${F.indicesGet("outputIndices",d)};
          let c = ${F.indicesGet("outputIndices",p)};
          let dyCorner = vec2<i32>(i32(r), i32(c)) - pads;
          let dyRCorner = dyCorner.x;
          let dyCCorner = dyCorner.y;
          let groupId = d1 / ${b};
          let wOutChannel = d1 - groupId * ${b};
          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
          // ? = to be determined. : = across all values in that axis.
          var dotProd = ${o}(0.0);
          for (var wR: u32 = 0; wR < effectiveFilterDims.x; wR = wR + 1) {
            if (wR % dilations.x != 0) {
              continue;
            }
            let dyR = (${o}(dyRCorner) + ${o}(wR)) / ${o}(strides[0]);
            let wRPerm = filterDims.x - 1 - wR / dilations.x;
            if (dyR < 0.0 || dyR >= ${o}(outBackprop[${d}]) || fract(dyR) > 0.0 ||
                wRPerm < 0) {
              continue;
            }
            let idyR: u32 = u32(dyR);

            for (var wC: u32 = 0; wC < effectiveFilterDims.y; wC = wC + 1) {
              if (wC % dilations.y != 0) {
                continue;
              }
              let dyC = (${o}(dyCCorner) + ${o}(wC)) / ${o}(strides.y);
              let wCPerm = filterDims.y - 1 - wC / dilations.y;
              if (dyC < 0.0 || dyC >= ${o}(outBackprop[${p}]) ||
                  fract(dyC) > 0.0 || wCPerm < 0) {
                continue;
              }
              let idyC: u32 = u32(dyC);
              var inputChannel = groupId * ${$};
              for (var d2: u32 = 0; d2 < ${$}; d2 = d2 + 1) {
                let xValue = ${l?I.get("batch","idyR","idyC","inputChannel"):I.get("batch","inputChannel","idyR","idyC")};
                let wValue = ${E.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};
                dotProd = dotProd + xValue * wValue;
                inputChannel = inputChannel + 1;
              }
            }
          }
          let value = dotProd + ${a?"bias[d1]":`${o}(0.0)`};
          ${F.setByOffset("global_idx","value")};
        `;return`
  ${t.declareVariables(...M,F)}
  ${S}
  const outShape : vec4<u32> = vec4<u32>(${r.join(",")});
  const outBackprop : vec4<u32> = vec4<u32>(${e[0].dims.join(",")});
  const strides : vec2<u32> = vec2<u32>(${n.strides[0]}, ${n.strides[1]});
  const filterDims : vec2<u32> = vec2<u32>(${n.kernelShape[l?1:2]}, ${n.kernelShape[l?2:3]});
  const dilations : vec2<u32> = vec2<u32>(${n.dilations[0]}, ${n.dilations[1]});
  const effectiveFilterDims : vec2<u32> = filterDims + vec2<u32>(
          ${n.dilations[0]<=1?0:(n.kernelShape[l?1:2]-1)*(n.dilations[0]-1)},
          ${n.dilations[1]<=1?0:(n.kernelShape[l?2:3]-1)*(n.dilations[1]-1)});
  const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${n.pads[0]+n.pads[2]})/2,
                                     i32(effectiveFilterDims[1]) - 1 - (${n.pads[1]+n.pads[3]})/2);
    ${t.mainStart()}
    ${t.guardAgainstOutOfBoundsWorkgroupSizes(f)};
  ${s?L:W}}`},ts=(t,e,n)=>{let r=t.length>2,a=e.outputShape,i=J.size(a),s=[Math.ceil(i/64),1,1];rt("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${s}`);let o=xt(t[0].dataType);return{name:"ConvTranspose2D",shaderCache:{hint:e.cacheKey},getRunData:()=>({dispatchGroup:{x:s[0],y:s[1],z:s[2]},outputs:[{dims:n?n(a):a,dataType:t[0].dataType}]}),getShaderSource:l=>Pl(l,t,e,a,r,s[1]===1&&s[2]===1,!1,o)}}}),Dl,Nl,Ll,vi,Np,Fl,Ul,Wl,Vl,Lp,Vg=Y(()=>{it(),Ug(),Wg(),Sn(),Or(),Dl=(t,e,n,r,a,i)=>(t-1)*e+n+(r-1)*a+1-i,Nl=(t,e,n,r,a)=>{let i=Math.floor(t/2);e==="SAME_UPPER"?(n[r]=i,n[a]=t-i):e==="SAME_LOWER"&&(n[r]=t-i,n[a]=i)},Ll=(t,e,n,r,a,i,s,o,l,d)=>{let p=t.length-2,u=d.length===0;if(l.length===0)for(let _=0;_<p;++_)l.push(0);let f=t[0],m=e[o?3:1]*a;for(let _=0,v=t.length-p-(o?1:0);_<p;++_,++v){let $=t[v],b=u?$*s[_]:d[_],S=Dl($,s[_],i[_],e[v],n[_],b);Nl(S,r,i,_,_+p),u&&d.push(s[_]*($-1)+l[_]+(e[v]-1)*n[_]+1-i[_]-i[_+p])}d.splice(0,0,f),d.splice(o?3:1,0,m)},vi=(t,e)=>{let n=t.kernelShape.slice();if(t.kernelShape.length===0||t.kernelShape.reduce((f,m)=>f*m,1)===0){n.length=0;for(let f=2;f<e[1].dims.length;++f)n.push(e[1].dims[f])}let r=t.format==="NHWC";n.splice(0,0,e[1].dims[0]),n.splice(r?3:1,0,e[1].dims[1]);let a=t.pads.slice(),i=t.outputShape.slice(),s=t.outputPadding.slice(),o=e[0].dims,l=t.dilations.slice();if(l.reduce((f,m)=>f+m,0)===0){let f=e[0].dims.length-2;l=new Array(f).fill(1)}let d=t.strides.slice();if(d.reduce((f,m)=>f+m,0)===0){let f=e[0].dims.length-2;d=new Array(f).fill(1)}Ll(o,n,l,t.autoPad,t.group,a,d,r,s,i);let p=Object.assign({},t),u=t.cacheKey+[n.join("n,"),a.join(","),d.join(","),s.join(","),i.join(","),l.join(",")].join("_");return Object.assign(p,{kernelShape:n,pads:a,outputPadding:s,outputShape:i,dilations:l,strides:d,cacheKey:u}),p},Np=t=>{let e=ks(t),n=t.format,r=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof t.autoPad>"u"?0:t.autoPad],a=t.dilations,i=t.group,s=t.kernelShape,o=t.pads,l=t.strides,d=t.wIsConst(),p=t.outputPadding,u=t.outputShape;return qe({autoPad:r,format:n,dilations:a,group:i,kernelShape:s,outputPadding:p,outputShape:u,pads:o,strides:l,wIsConst:d,...e})},Fl=(t,e)=>{if(!t||t.length!==2&&t.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(t[0].dims.length!==4&&t[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(t[0].dims.length!==t[1].dims.length)throw new Error("filter does not have same dimension as input");let n=t[0].dims[e.format==="NHWC"?t[0].dims.length-1:1],r=t[1].dims[0];if(n!==r)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let a=t[1].dims[1]*e.group;if(t.length===3&&(t[2].dims.length!==1||t[2].dims[0]!==a))throw new Error("invalid bias");let i=t[0].dims.length-2;if(e.dilations.reduce((s,o)=>s+o,0)>0&&e.dilations.length!==i)throw new Error(`dilations should be ${i}D`);if(e.strides.reduce((s,o)=>s+o,0)>0&&e.strides.length!==i)throw new Error(`strides should be ${i}D`);if(e.pads.reduce((s,o)=>s+o,0)>0&&e.pads.length!==i*2)throw new Error(`pads should be ${i*2}D`);if(e.outputPadding.length!==i&&e.outputPadding.length!==0)throw new Error(`output_padding should be ${i}D`);if(e.kernelShape.reduce((s,o)=>s+o,0)>0&&e.kernelShape.length!==0&&e.kernelShape.length!==t[1].dims.length-2)throw new Error("invalid kernel shape");if(e.outputShape.length!==0&&e.outputShape.length!==t[0].dims.length-2)throw new Error("invalid output shape")},Ul=[2,3,1,0],Wl=(t,e,n)=>{let r=vi(n,e),a=n.format==="NHWC",i=r.outputShape,s=i[a?3:1],o=e[0].dims[a?3:1];if(r.group!==1||s===1&&o===1){t.compute(ts(e,r));return}let l=i[a?1:2],d=i[a?2:3],p=e[1].dims[2],u=e[1].dims[3],f=a?l*d:s,m=a?s:l*d,_=p*u*o,v=!0,$=t.kernelCustomData.wT??t.compute(cn(e[1],Ul),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!t.kernelCustomData.wT&&(t.kernelCustomData.wT=$);let b=[e[0],$],S=e.length===3;S&&(!a&&e[2].dims.length===1?b.push(e[2].reshape([e[2].dims[0],1,1])):b.push(e[2])),t.compute(Dp(b,r,i,f,m,_,S,v),{inputs:b})},Vl=(t,e)=>{let n=e.format==="NHWC",r=[t.inputs[0].reshape(n?[t.inputs[0].dims[0],1,t.inputs[0].dims[1],t.inputs[0].dims[2]]:[t.inputs[0].dims[0],t.inputs[0].dims[1],1,t.inputs[0].dims[2]]),t.inputs[1].reshape([t.inputs[1].dims[0],t.inputs[1].dims[1],1,t.inputs[1].dims[2]])];r.length===3&&r.push(t.inputs[2]);let a=e.kernelShape;(a.length===0||a[0]===0)&&(a=[t.inputs[1].dims[2]]);let i=e.dilations;(i.length===0||i[0]===0)&&(i=[1]);let s=e.strides;(s.length===0||s[0]===0)&&(s=[1]);let o=e.pads;o.length===0&&(o=[0,0]),o=[0,o[0],0,o[1]],s=[1].concat(s),i=[1].concat(i),a=[1].concat(a);let l=vi({...e,pads:o,strides:s,dilations:i,kernelShape:a},r);t.compute(ts(r,l,d=>n?[d[0],d[2],d[3]]:[d[0],d[1],d[3]]))},Lp=(t,e)=>{Fl(t.inputs,e),t.inputs[0].dims.length===3?Vl(t,e):Wl(t,t.inputs,e)}}),Gl,Fp,Up,Gg=Y(()=>{Ye(),Ie(),it(),Te(),Gl=(t,e,n,r)=>{let a=J.size(e),i=e.length,s=Z("input",t,i),o=be("output",t,i),l=n.dataType===6?n.getInt32Array()[0]:Number(n.getBigInt64Array()[0]),d=J.normalizeAxis(l,i),p=u=>{let f=` i32(${s.indicesGet("inputIndices","uniforms.axis")}) `,m=xe("uniforms.input_shape","uniforms.axis",i),_=r.reverse?f+(r.exclusive?" + 1":""):"0",v=r.reverse?m:f+(r.exclusive?"":" + 1");return`
                ${u.registerUniform("outputSize","u32").registerUniform("axis","u32").declareVariables(s,o)}
                ${u.mainStart()}
                  ${u.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
                  var inputIndices = ${o.offsetToIndices("global_idx")};
                  var sum = ${o.type.value}(0);
                  let first : i32 = ${_};
                  let last : i32 = ${v};
                  for (var i : i32 = first; i < last; i++) {
                    ${s.indicesSet("inputIndices","uniforms.axis","u32(i)")};
                    sum = sum + ${s.getByIndices("inputIndices")};
                  }
                  ${o.setByOffset("global_idx","sum")};
                }`};return{name:"CumSum",shaderCache:{hint:r.cacheKey,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:e,dataType:t}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:[{type:"uint32",data:a},{type:"int32",data:d},...re(e),...re(e)]}),getShaderSource:p}},Fp=(t,e)=>{let n=t.inputs[0].dims,r=t.inputs[0].dataType,a=t.inputs[1];t.compute(Gl(r,n,a,e),{inputs:[0]})},Up=t=>{let e=t.exclusive===1,n=t.reverse===1;return qe({exclusive:e,reverse:n})}}),_a,pr,bi,Hl,ql,jl,Kl,$i,Yl,Wp,Vp,Hg=Y(()=>{Ie(),it(),Te(),_a="[a-zA-Z]|\\.\\.\\.",pr="("+_a+")+",bi="^"+pr+"$",Hl="("+pr+",)*"+pr,ql="^"+Hl+"$",jl=class{constructor(t=-1){this.symbolToIndices=new Map,this.inputIndex=t}addSymbol(t,e){let n=this.symbolToIndices.get(t);n===void 0?n=[e]:n.push(e),this.symbolToIndices.set(t,n)}},Kl=class{constructor(t,e){this.equation=e,this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[n,r]=e.includes("->")?e.split("->",2):[e,""];if(!n.match(RegExp(ql)))throw new Error("Invalid LHS term");if(n.split(",").forEach((a,i)=>{let s=t[i].dims.slice();if(!a.match(RegExp(bi)))throw new Error("Invalid LHS term");let o=this.processTerm(a,!0,s,i);this.lhs.push(o)}),r==="")r+=[...this.symbolToInfo.entries()].filter(([a,i])=>i.count===1||a==="...").map(([a])=>a).join("");else if(!r.match(RegExp(pr)))throw new Error("Invalid RHS");r.match(RegExp(_a,"g"))?.forEach(a=>{if(a==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let i=this.symbolToInfo.get(a);if(i===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(i.dimValue)}}),this.rhs=this.processTerm(r,!1,this.outputDims)}addSymbol(t,e,n){let r=this.symbolToInfo.get(t);if(r!==void 0){if(r.dimValue!==e&&r.count!==1)throw new Error("Dimension mismatch");r.count++,r.inputIndices.push(n)}else r={count:1,dimValue:e,inputIndices:[n]};this.symbolToInfo.set(t,r)}processTerm(t,e,n,r=-1){let a=n.length,i=!1,s=[],o=0;if(!t.match(RegExp(bi))&&!e&&t!=="")throw new Error("Invalid LHS term");let l=t.match(RegExp(_a,"g")),d=new jl(r);return l?.forEach((p,u)=>{if(p==="..."){if(i)throw new Error("Only one ellipsis is allowed per input term");i=!0;let f=a-l.length+1;if(f<0)throw new Error("Ellipsis out of bounds");if(s=n.slice(o,o+f),this.hasEllipsis){if(this.ellipsisDims.length!==s.length||this.ellipsisDims.toString()!==s.toString())throw new Error("Ellipsis dimensions mismatch")}else if(e)this.hasEllipsis=!0,this.ellipsisDims=s;else throw new Error("Ellipsis must be specified in the LHS");for(let m=0;m<s.length;m++){let _=String.fromCharCode(48+m);d.addSymbol(_,u+m),this.addSymbol(_,n[o++],r)}}else d.addSymbol(p,u+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(p,n[o++],r)}),d}},$i=t=>t+"_max",Yl=(t,e,n,r,a)=>{let i=e.map((f,m)=>t[m]?f.length:f).map((f,m)=>Z(`input${m}`,n,f)),s=J.size(a),o=at(a.length),l=o?a.length:a,d=be("output",n,l),p=[...r.symbolToInfo.keys()].filter(f=>!r.rhs.symbolToIndices.has(f)),u=f=>{let m=[],_="var prod = 1.0;",v="var sum = 0.0;",$="sum += prod;",b=[],S=[],T=[],E=[],I=r.symbolToInfo.size===r.rhs.symbolToIndices.size;r.symbolToInfo.forEach((F,L)=>{if(r.rhs.symbolToIndices.has(L)){let W=r.rhs.symbolToIndices.get(L)?.[0];W!==void 0&&r.lhs.forEach((X,A)=>{if(F.inputIndices.includes(A)){let q=X.symbolToIndices.get(L);if(q===void 0)throw new Error("Invalid symbol error");q.forEach(te=>{m.push(`${i[A].indicesSet(`input${A}Indices`,te,d.indicesGet("outputIndices",W))}`)})}})}else r.lhs.forEach((W,X)=>{if(F.inputIndices.includes(X)){let A=W.symbolToIndices.get(L);if(A===void 0)throw new Error("Invalid symbol error");A.forEach(q=>{b.push(`${i[X].indicesSet(`input${X}Indices`,q,`${L}`)}`)}),E.push(`prod *= ${i[X].getByIndices(`input${X}Indices`)};`)}}),S.push(`for(var ${L}: u32 = 0; ${L} < uniforms.${$i(L)}; ${L}++) {`),T.push("}")});let M=I?[...m,`let sum = ${i.map((F,L)=>F.getByIndices(`input${L}Indices`)).join(" * ")};`]:[...m,v,...S,...b,_,...E,$,...T];return`
            ${f.registerUniforms(p.map(F=>({name:`${$i(F)}`,type:"u32"}))).registerUniform("outputSize","u32").declareVariables(...i,d)}

            ${f.mainStart()}
            ${f.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
            var outputIndices = ${d.offsetToIndices("global_idx")};
            ${i.map((F,L)=>`var input${L}Indices: ${i[L].type.indices};`).join(`
`)}
            ${M.join(`
`)};
            ${d.setByOffset("global_idx","sum")};
          }`};return{name:"Einsum",shaderCache:{hint:r.equation,inputDependencies:t.map(f=>f?"rank":"dims")},getRunData:()=>{let f=p.filter(_=>r.symbolToInfo.has(_)).map(_=>({type:"uint32",data:r.symbolToInfo.get(_)?.dimValue||0}));f.push({type:"uint32",data:s});let m=e.filter((_,v)=>t[v]).map((_,v)=>[...re(_)]).reduce((_,v)=>_.concat(v),f);return o&&m.push(...re(a)),{outputs:[{dims:a,dataType:n}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:m}},getShaderSource:u}},Wp=(t,e)=>{let n=new Kl(t.inputs,e.equation),r=t.inputs.map((s,o)=>at(s.dims.length)),a=n.outputDims,i=t.inputs.map((s,o)=>s.dims);t.compute(Yl(r,i,t.inputs[0].dataType,n,a))},Vp=t=>{let e=t.equation.replace(/\s+/g,"");return qe({equation:e})}}),Xl,xi,Ql,Zl,Gp,qg=Y(()=>{Ye(),Ie(),Te(),Xl=t=>{if(!t||t.length!==2)throw new Error("Expand requires 2 input.");let e=t[0].dims,n=Array.from(t[1].getBigInt64Array(),Number),r=n.length<e.length?0:n.length-e.length,a=e.length<n.length?0:e.length-n.length;for(;r<n.length&&a<e.length;++r,++a)if(n[r]!==e[a]&&n[r]!==1&&e[a]!==1)throw new Error("Expand requires shape to be broadcastable to input")},xi=(t,e)=>{let n=t.length-e.length,r=[];for(let a=0;a<n;++a)r.push(t[a]);for(let a=0;a<e.length;++a)r.push(e[a]===1?t[a+n]:e[a]);return r},Ql=(t,e)=>t.length>e.length?xi(t,e):xi(e,t),Zl=t=>{let e=t[0].dims,n=Array.from(t[1].getBigInt64Array(),Number),r=Ql(e,n),a=t[0].dataType,i=a===9?4:1,s=Math.ceil(J.size(r)/i),o=at(e.length),l=at(r.length),d=u=>{let f=o?e.length:e,m=l?r.length:r,_=Z("input",a,f,i),v=be("output",a,m,i),$;if(a===9){let b=(S,T,E="")=>`
          let outputIndices${T} = ${v.offsetToIndices(`outputOffset + ${T}u`)};
          let offset${T} = ${_.broadcastedIndicesToOffset(`outputIndices${T}`,v)};
          let index${T} = offset${T} / 4u;
          let component${T} = offset${T} % 4u;
          ${S}[${T}] = ${E}(${_.getByOffset(`index${T}`)}[component${T}]);
        `;$=`
        let outputOffset = global_idx * ${i};
        var data = vec4<u32>(0);
        ${b("data",0,"u32")}
        ${b("data",1,"u32")}
        ${b("data",2,"u32")}
        ${b("data",3,"u32")}
        ${v.setByOffset("global_idx","data")}
      }`}else $=`
        let outputIndices = ${v.offsetToIndices("global_idx")};
        let inputOffset = ${_.broadcastedIndicesToOffset("outputIndices",v)};
        ${v.setByOffset("global_idx",_.getByOffset("inputOffset"))}
      }`;return`
    ${u.registerUniform("vec_size","u32").declareVariables(_,v)}
    ${u.mainStart()}
    ${u.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
    ${$}`},p=[{type:"uint32",data:s}];return o&&p.push(...re(e)),l&&p.push(...re(r)),{name:"Expand",shaderCache:{hint:`${r.length}`,inputDependencies:[o?"rank":"dims"]},getShaderSource:d,getRunData:()=>({outputs:[{dims:r,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:p})}},Gp=t=>{Xl(t.inputs),t.compute(Zl(t.inputs),{inputs:[0]})}}),Jl,eu,Hp,qp,jg=Y(()=>{Ye(),Ie(),it(),Te(),Jl=t=>{if(!t||t.length!==2)throw new Error("Gather requires 2 inputs.")},eu=(t,e)=>{let n=t[0].dims,r=t[1].dims,a=n.length,i=J.normalizeAxis(e.axis,a),s=n.slice(0);s.splice(i,1,...r);let o=n[i],l=t[0].dataType===9?4:1,d=Math.ceil(J.size(s)/l),p=at(t[0].dims.length),u=p?t[0].dims.length:t[0].dims,f=at(t[1].dims.length),m=f?t[1].dims.length:t[1].dims,_=at(s.length),v=_?s.length:s,$=[{type:"uint32",data:d},{type:"int32",data:o},{type:"uint32",data:i}];p&&$.push(...re(t[0].dims)),f&&$.push(...re(t[1].dims)),_&&$.push(...re(s));let b=[];b.push(p?"rank":"dims"),b.push(f?"rank":"dims");let S=T=>{let E=Z("data",t[0].dataType,u,l),I=Z("inputIndices",t[1].dataType,m),M=be("output",t[0].dataType,v,l),F=W=>{let X=r.length,A=`var indicesIndices${W}  = ${I.type.indices}(0);`;for(let q=0;q<X;q++)A+=`${X>1?`indicesIndices${W}[${q}]`:`indicesIndices${W}`} = ${s.length>1?`outputIndices${W}[uniforms.axis + ${q}]`:`outputIndices${W}`};`;A+=`
          var idx${W} = ${I.getByIndices(`indicesIndices${W}`)};
          if (idx${W} < 0) {
            idx${W} = idx${W} + uniforms.axisDimLimit;
          }
          var dataIndices${W} = ${E.type.indices}(0);
        `;for(let q=0,te=0;q<a;q++)q===i?(A+=`${a>1?`dataIndices${W}[${q}]`:`dataIndices${W}`} = u32(idx${W});`,te+=X):(A+=`${a>1?`dataIndices${W}[${q}]`:`dataIndices${W}`} = ${s.length>1?`outputIndices${W}[${te}]`:`outputIndices${W}`};`,te++);return A},L;if(t[0].dataType===9){let W=(X,A,q="")=>`
          let outputIndices${A} = ${M.offsetToIndices(`outputOffset + ${A}u`)};
          ${F(A)};
          let offset${A} = ${E.indicesToOffset(`dataIndices${A}`)};
          let index${A} = offset${A} / 4u;
          let component${A} = offset${A} % 4u;
          ${X}[${A}] = ${q}(${E.getByOffset(`index${A}`)}[component${A}]);
        `;L=`
        let outputOffset = global_idx * ${l};
        var value = vec4<u32>(0);
        ${W("value",0,"u32")}
        ${W("value",1,"u32")}
        ${W("value",2,"u32")}
        ${W("value",3,"u32")}
        ${M.setByOffset("global_idx","value")}
      `}else L=`
      let outputIndices = ${M.offsetToIndices("global_idx")};
      ${F("")};
      let value = ${E.getByIndices("dataIndices")};
      ${M.setByOffset("global_idx","value")};
      `;return`
      ${T.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(E,I,M)}
      ${T.mainStart()}
        ${T.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        ${L}
      }`};return{name:"Gather",shaderCache:{hint:e.cacheKey,inputDependencies:b},getRunData:()=>({outputs:[{dims:s,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:$}),getShaderSource:S}},Hp=t=>qe({axis:t.axis}),qp=(t,e)=>{let n=t.inputs;Jl(n),t.compute(eu(t.inputs,e))}}),tu,nu,jp,Kp,Kg=Y(()=>{Ie(),it(),Te(),tu=t=>{if(!t||t.length!==2)throw new Error("GatherElements requires 2 inputs.");if(t[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(t[0].dims.length!==t[1].dims.length)throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`)},nu=(t,e)=>{let n=t[0].dims,r=t[0].dataType,a=n.length,i=t[1].dims,s=t[1].dataType,o=J.normalizeAxis(e.axis,a),l=n[o],d=i.slice(0),p=J.size(d),u=Z("input",r,a),f=Z("indicesInput",s,i.length),m=be("output",r,d.length),_=[{type:"uint32",data:p},{type:"int32",data:l},{type:"uint32",data:o}];return _.push(...re(n)),_.push(...re(i)),_.push(...re(d)),{name:"GatherElements",shaderCache:{inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:d,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:_}),getShaderSource:v=>`
      ${v.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(u,f,m)}
      ${v.mainStart()}
      ${v.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

      let outputIndices = ${m.offsetToIndices("global_idx")};

      var idx = ${f.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + uniforms.axisDimLimit;
      }
      var inputIndices = ${u.type.indices}(outputIndices);
      ${u.indicesSet("inputIndices","uniforms.axis","u32(idx)")};
      let value = ${u.getByIndices("inputIndices")};

      ${m.setByOffset("global_idx","value")};
  }`}},jp=t=>qe({axis:t.axis}),Kp=(t,e)=>{let n=t.inputs;tu(n),t.compute(nu(t.inputs,e))}}),ru,au,Yp,Xp,Yg=Y(()=>{Ie(),Te(),ru=t=>{if(!t)throw new Error("Input is missing");if(t.length<2||t.length>3)throw new Error("Invaid input number.");if(t.length===3&&t[2].dims.length>2)throw new Error("Invalid input shape of C");if(t[0].dataType!==t[1].dataType||t.length===3&&t[0].dataType!==t[2].dataType)throw new Error("Input types are mismatched")},au=(t,e)=>{let n=t[0].dims.slice(),r=t[1].dims.slice(),[a,i,s]=cc.getShapeOfGemmResult(n,e.transA,r,e.transB,t.length===3?t[2].dims:void 0),o=[a,i];if(!o)throw new Error("Can't use gemm on the given tensors");let l=J.size(o),d=[{type:"uint32",data:l},{type:"uint32",data:a},{type:"uint32",data:i},{type:"uint32",data:s},{type:"float32",data:e.alpha},{type:"float32",data:e.beta}],p=["type","type"];t.length===3&&(d.push(...re(t[2].dims)),p.push("rank")),d.push(...re(o));let u=f=>{let m="";e.transA&&e.transB?m="value += a[k * uniforms.M + m] * b[n * uniforms.K + k];":e.transA&&!e.transB?m="value += a[k * uniforms.M + m] * b[k * uniforms.N + n];":!e.transA&&e.transB?m="value += a[m * uniforms.K + k] * b[n * uniforms.K + k];":!e.transA&&!e.transB&&(m="value += a[m * uniforms.K + k] * b[k * uniforms.N + n];");let _=e.alpha===1?"":"value *= uniforms.alpha;",v=Z("a",t[0].dataType,t[0].dims),$=Z("b",t[1].dataType,t[1].dims),b=v.type.value,S=null,T=[v,$];t.length===3&&(S=Z("c",t[2].dataType,t[2].dims.length),T.push(S));let E=be("output",t[0].dataType,o.length);T.push(E);let I=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}];return`
  ${f.registerUniforms(I).declareVariables(...T)}

  ${f.mainStart()}
    ${f.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let m = global_idx / uniforms.N;
    let n = global_idx % uniforms.N;

    var value = ${b}(0);
    for (var k: u32 = 0u; k < uniforms.K; k++) {
      ${m}
    }

    ${_}
    ${S!=null?`let cOffset = ${S.broadcastedIndicesToOffset("vec2(m, n)",E)}; value += ${b}(uniforms.beta) * ${S.getByOffset("cOffset")};`:""}
    output[global_idx] = value;
  }`};return{name:"Gemm",shaderCache:{hint:`${e.cacheKey}`,inputDependencies:p},getRunData:()=>({outputs:[{dims:o,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:d}),getShaderSource:u}},Yp=t=>{let e=t.transA,n=t.transB,r=t.alpha,a=t.beta;return{transA:e,transB:n,alpha:r,beta:a,cacheKey:`${t.transA};${t.transB};${t.alpha===1}`}},Xp=(t,e)=>{ru(t.inputs),t.compute(au(t.inputs,e))}}),iu,su,ou,Qp,Xg=Y(()=>{Ye(),Ie(),Te(),iu=(t,e)=>{let n=t[0].dims,r=n,a=2,i=J.sizeToDimension(n,a),s=J.sizeFromDimension(n,a),o=gt(s),l=s/o,d=[n[0],n[1],l],p=["rank","type","type"],u=[{type:"uint32",data:s},{type:"uint32",data:l}];u.push(...re(d),...re(d));let f=m=>{let _=Z("x",t[0].dataType,d.length,o),v=Z("scale",t[1].dataType,t[1].dims),$=Z("bias",t[2].dataType,t[2].dims),b=be("output",t[0].dataType,d.length,o),S=[_,v,$,b],T=_.type.value,E=o===1?"f32":`vec${o}<f32>`,I=64,M=[{name:"normSize",type:"u32"},{name:"normPackedSize",type:"u32"}];return`
  var<workgroup> meanShared : f32;
  var<workgroup> squaredNormShared : f32;
  var<workgroup> workgroupShared : array<${E}, ${I}>;
  const workgroupSize = ${I}u;
  ${m.registerUniforms(M).declareVariables(...S)}
  ${m.mainStart(I)}
    let norm = global_idx / workgroupSize;
    let batch = norm / uniforms.x_shape[1];
    let channel = norm % uniforms.x_shape[1];
    let localIndex = local_id.x;

    // initialize workgroup memory
    var initial = ${E}(0);
    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {
      initial = initial + ${E}(${_.get("batch","channel","h")});
    }
    workgroupShared[localIndex] = initial;
    workgroupBarrier();

    // Calculate the mean of current channel data.
    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (localIndex < currSize) {
        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];
      }
      workgroupBarrier();
    }
    if (localIndex == 0) {
      meanShared = ${Ht("workgroupShared[0]",o)} / f32(uniforms.normSize);
    }
    workgroupBarrier();

    // reinitialize workgroup memory.
    initial = ${E}(0);
    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {
      let deviation =  ${E}(${_.get("batch","channel","h")}) - ${E}(meanShared);
      initial = initial + deviation * deviation;
    }
    workgroupShared[localIndex] = initial;
    workgroupBarrier();

    // Calculate the sum of square of deviation of current channel data.
    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (localIndex < currSize) {
        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];
      }
      workgroupBarrier();
    }
    if (localIndex == 0) {
      squaredNormShared = ${Ht("workgroupShared[0]",o)};
    }
    workgroupBarrier();

    let invStdDev = inverseSqrt(squaredNormShared / f32(uniforms.normSize) + f32(${e.epsilon}));
    let channelScale = invStdDev * f32(${v.getByOffset("channel")});
    let channelShift = f32(${$.getByOffset("channel")}) - meanShared * channelScale;
    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {
      let value = ${_.get("batch","channel","h")} * ${T}(${E}(channelScale)) + ${T}(${E}(channelShift));
      ${b.set("batch","channel","h","value")};
    }
  }`};return{name:"InstanceNormalization",shaderCache:{hint:`${e.epsilon};${o}`,inputDependencies:p},getRunData:()=>({outputs:[{dims:r,dataType:t[0].dataType}],dispatchGroup:{x:i},programUniforms:u}),getShaderSource:f}},su=(t,e,n,r,a,i,s,o)=>{let l=gt(s),d=64,p=l===1?"vec2f":`mat2x${l}f`,u=l===1?"f32":`vec${l}f`,f=(M,F)=>`${p}(${M}, ${F})`,m=a*s/l,_=Math.ceil(i/d),v=["type"],$=[{type:"uint32",data:_},{type:"uint32",data:i},{type:"uint32",data:Math.floor(s/l)},{type:"uint32",data:Math.floor(i*s/l)}],b=M=>{let F=Z("input",e.dataType,e.dims,l);return`
  ${M.declareVariables(F)}
  @group(0) @binding(1) var<storage, read_write> output : array<${p}>;
  struct Uniforms {wg_size:u32, H:u32, C:u32, image_size:u32};
  @group(0) @binding(2) var<uniform> uniforms: Uniforms;

  ${M.mainStart(d)}
    let currentImageNumber = global_idx / ${d} / uniforms.C;
    let currentChannelNumber = (global_idx / ${d}) % uniforms.C;
    let wgId = global_idx % ${d};
    let wgOffset = wgId * uniforms.wg_size;
    if (wgOffset >= uniforms.H) {
        return;
    }
    let wgMax = min(wgOffset + uniforms.wg_size, uniforms.H);

    let offset = currentImageNumber * uniforms.image_size + currentChannelNumber;
    var sum = ${mt("f32",l)};
    var squaredSum = ${mt("f32",l)};
    for (var i: u32 = wgOffset; i < wgMax; i++) {
        let value = ${u}(input[offset + i * uniforms.C]);
        sum += value;
        squaredSum += value * value;
    }
    output[global_idx] = ${f("sum","squaredSum")};
  }`},S=t.compute({name:"InstanceNormComputeMean",shaderCache:{hint:`${l}`,inputDependencies:v},getRunData:()=>({outputs:[{dims:[a,s,d,2],dataType:1}],dispatchGroup:{x:a*s/l},programUniforms:$}),getShaderSource:b},{inputs:[e],outputs:[-1]})[0],T=[{type:"uint32",data:m},{type:"uint32",data:i},{type:"uint32",data:Math.floor(s/l)},{type:"uint32",data:Math.floor(d*s/l)}],E=["type","type","type"],I=M=>{let F=Z("scale",n.dataType,n.dims,l),L=Z("bias",r.dataType,r.dims,l);return`
  @group(0) @binding(0) var<storage, read> input : array<${p}>;
  @group(0) @binding(1) var<storage, read> scale : array<${F.type.storage}>;
  @group(0) @binding(2) var<storage, read> bias : array<${L.type.storage}>;
  @group(0) @binding(3) var<storage, read_write> output : array<${p}>;
  struct Uniforms {units_of_work : u32, H: u32, C : u32, image_size : u32};
  @group(0) @binding(4) var<uniform> uniforms: Uniforms;

  ${M.mainStart()}
    ${M.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.units_of_work")}
    let currentImageNumber = global_idx / uniforms.C;
    let currentChannelNumber = global_idx % uniforms.C;

    let offset = currentImageNumber * uniforms.image_size;
    var sum = ${mt("f32",l)};
    var squaredSum = ${mt("f32",l)};
    for (var i: u32 = 0; i < ${d}; i++) {
        let value = input[offset + i + currentChannelNumber * ${d}];
        sum += value[0];
        squaredSum += value[1];
    }
    sum = sum / f32(uniforms.H);
    squaredSum = squaredSum / f32(uniforms.H);
    let invStdDev = inverseSqrt(squaredSum - sum * sum + f32(${o}));
    let channelScale = invStdDev * ${u}(scale[currentChannelNumber]);
    let channelShift = ${u}(bias[currentChannelNumber]) - sum * channelScale;

    output[global_idx] = ${f("channelScale","channelShift")};
  }`};return t.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:`${l};${o}`,inputDependencies:E},getRunData:()=>({outputs:[{dims:[a,s,2],dataType:1}],dispatchGroup:{x:Math.ceil(m/64)},programUniforms:T}),getShaderSource:I},{inputs:[S,n,r],outputs:[-1]})[0]},ou=(t,e,n)=>{let r=e[0].dims,a=r,i=r[0],s=r[r.length-1],o=J.sizeFromDimension(r,1)/s,l=gt(s),d=J.size(a)/l,p=[{type:"uint32",data:o},{type:"uint32",data:Math.floor(s/l)}],u=["type","type"],f=su(t,e[0],e[1],e[2],i,o,s,n.epsilon),m=_=>{let v=xt(e[0].dataType),$=l===1?"vec2f":`mat2x${l}f`,b=l===1?v:`vec${l}<${v}>`,S=Z("input",e[0].dataType,e[0].dims,l),T=be("output",e[0].dataType,a,l);return`
  @group(0) @binding(0) var<storage, read> input : array<${S.type.storage}>;
  @group(0) @binding(1) var<storage, read> scaleInput : array<${$}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${T.type.storage}>;
  struct Uniforms {H: u32, C : u32};
  @group(0) @binding(3) var<uniform> uniforms: Uniforms;

  ${_.mainStart()}
    let currentImageNumber = global_idx / (uniforms.C * uniforms.H);
    let currentChannelNumber = global_idx % uniforms.C;

    let scaleOffset = currentImageNumber * uniforms.C + currentChannelNumber;
    let scale = scaleInput[scaleOffset];
    output[global_idx] = fma(input[global_idx], ${b}(scale[0]), ${b}(scale[1]));
  }`};t.compute({name:"InstanceNormalizationNHWC",shaderCache:{hint:`${l}`,inputDependencies:u},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:p}),getShaderSource:m},{inputs:[e[0],f]})},Qp=(t,e)=>{e.format==="NHWC"?ou(t,t.inputs,e):t.compute(iu(t.inputs,e))}}),lu,uu,Zp,Qg=Y(()=>{Ye(),Ie(),Te(),lu=t=>{if(!t||t.length<2)throw new Error("layerNorm requires at least 2 inputs.")},uu=(t,e,n)=>{let r=t[0].dims,a=t[1],i=t[2],s=r,o=J.normalizeAxis(e.axis,r.length),l=J.sizeToDimension(r,o),d=J.sizeFromDimension(r,o),p=J.size(a.dims),u=i?J.size(i.dims):0;if(p!==d||i&&u!==d)throw new Error(`Size of X.shape()[axis:] == ${d}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${p} and bias size of ${u}`);let f=[];for(let E=0;E<r.length;++E)E<o?f.push(r[E]):f.push(1);let m=gt(d),_=["type","type"],v=[{type:"uint32",data:l},{type:"float32",data:d},{type:"uint32",data:Math.floor(d/m)},{type:"float32",data:e.epsilon}];i&&_.push("type");let $=n>1,b=n>2,S=E=>{let I=xt(t[0].dataType),M=[Z("x",t[0].dataType,t[0].dims,m),Z("scale",a.dataType,a.dims,m)];i&&M.push(Z("bias",i.dataType,i.dims,m)),M.push(be("output",t[0].dataType,s,m)),$&&M.push(be("mean_data_output",1,f)),b&&M.push(be("inv_std_output",1,f));let F=[{name:"norm_count",type:"u32"},{name:"norm_size",type:"f32"},{name:"norm_size_vectorized",type:"u32"},{name:"epsilon",type:"f32"}];return`
  ${E.registerUniforms(F).declareVariables(...M)}
  ${E.mainStart()}
    ${E.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}
    let offset = global_idx * uniforms.norm_size_vectorized;
    var meanVector = ${mt("f32",m)};
    var meanSquareVector = ${mt("f32",m)};

    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {
      let value = ${Zt(I,m,"x[h + offset]")};
      meanVector += value;
      meanSquareVector += value * value;
    }
    let mean = ${Ht("meanVector",m)} / uniforms.norm_size;
    let invStdDev =
        inverseSqrt(${Ht("meanSquareVector",m)} / uniforms.norm_size - mean * mean + uniforms.epsilon);

    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {
      let f32input = ${Zt(I,m,"x[j + offset]")};
      let f32scale = ${Zt(I,m,"scale[j]")};
      output[j + offset] = ${M[0].type.value}((f32input - mean) * invStdDev * f32scale
        ${i?`+ ${Zt(I,m,"bias[j]")}`:""}
      );
    }

    ${$?"mean_data_output[global_idx] = mean":""};
    ${b?"inv_std_output[global_idx] = invStdDev":""};
  }`},T=[{dims:s,dataType:t[0].dataType}];return $&&T.push({dims:f,dataType:1}),b&&T.push({dims:f,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${m};${n}`,inputDependencies:_},getRunData:()=>({outputs:T,dispatchGroup:{x:Math.ceil(l/64)},programUniforms:v}),getShaderSource:S}},Zp=(t,e)=>{lu(t.inputs),t.compute(uu(t.inputs,e,t.outputCount))}}),du,Jp,Si,cu,wa,eh,Zg=Y(()=>{Ie(),it(),bs(),Nc(),Te(),Or(),du=(t,e)=>{let n=t[0],r=t[1],a=t[2],i=t[3],s=t[4],o=t[5],l=t[6],d=t[7];if(n.dims.length!==3&&n.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let p=!1,u=n.dims[0],f=n.dims[1],m=n.dims.length===3?p?n.dims[2]/3:n.dims[2]:e.numHeads*n.dims[4],_=f,v=0,$=0,b=Math.floor(m/e.numHeads);if(l&&d){if(l.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(d.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');v=l.dims[2],$=l.dims[2]}else if(l||d)throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let S;if(r){if(n.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(r.dims.length<3||r.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(n.dims[0]!==r.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(r.dims.length===3){if(r.dims[2]!==n.dims[2])throw new Error('Input "query" and "key" shall have same dim 2 (hidden_size)');S=2,_=r.dims[1]}else if(r.dims.length===5){if(r.dims[2]!==e.numHeads||r.dims[3]!==2||r.dims[4]!==b)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(a)throw new Error('Expect "value" be none when "key" has packed kv format.');S=5,_=r.dims[1]}else{if(r.dims[1]!==e.numHeads||r.dims[3]!==b)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');S=0,_=r.dims[2]}}else{if(n.dims.length!==3&&n.dims.length!==5)throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');if(n.dims.length===5&&(n.dims[2]!==e.numHeads||n.dims[3]!==3))throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');S=3}if(i){if(i.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimension');if(a&&n.dims.length===5&&n.dims[3]===2)throw new Error("bias is not allowed for packed kv.")}let T=0;if(s){T=8;let L=s.dims;throw L.length===1?L[0]===u?T=1:L[0]===3*u+2&&(T=3):L.length===2&&L[0]===u&&L[1]===_&&(T=5),T===8?new Error('Input "key_padding_mask" shape shall be (batch_size) or (batch_size, kv_sequence_length)'):new Error("Mask not supported")}let E=!1,I=m;if(a){if(a.dims.length!==3&&a.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(n.dims[0]!==a.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(a.dims.length===3){if(_!==a.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');I=a.dims[2]}else{if(_!==a.dims[2])throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');I=a.dims[1]*a.dims[3],E=!0}}let M=v+_,F=!1;if(s)throw new Error("Key padding mask is not supported");if(o)throw new Error("extraAddQk is not supported");if(l)throw new Error("pastKey is not supported");if(d)throw new Error("pastValue is not supported");return{batchSize:u,sequenceLength:f,pastSequenceLength:v,kvSequenceLength:_,totalSequenceLength:M,maxSequenceLength:$,inputHiddenSize:0,hiddenSize:m,vHiddenSize:I,headSize:b,vHeadSize:Math.floor(I/e.numHeads),numHeads:e.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:e.maskFilterValue,maskType:T,scale:e.scale,broadcastResPosBias:F,passPastInKv:E,qkvFormat:S}},Jp=t=>qe({...t}),Si=qe({perm:[0,2,1,3]}),cu=(t,e,n,r,a,i,s)=>{let o=[r,a,i],l=J.size(o),d=[{type:"uint32",data:l},{type:"uint32",data:s},{type:"uint32",data:i}],p=u=>{let f=be("qkv_with_bias",e.dataType,o),m=Z("qkv",e.dataType,o),_=Z("bias",n.dataType,o),v=[{name:"output_size",type:"u32"},{name:"bias_offset",type:"u32"},{name:"hidden_size",type:"u32"}];return`
  ${u.registerUniforms(v).declareVariables(m,_,f)}
  ${u.mainStart()}
    ${u.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;

    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];
  }`};return t.compute({name:"MultiHeadAttentionAddBias",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:o,dataType:e.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:d}),getShaderSource:p},{inputs:[e,n],outputs:[-1]})[0]},wa=(t,e,n,r,a,i,s,o)=>{let l=i;if(s){if(r===1)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return l=cu(t,i,s,e,r,n*a,o),l=l.reshape([e,r,n,a]),t.compute(cn(l,Si.perm),{inputs:[l],outputs:[-1]})[0]}else return i.dims.length===3&&(l=i.reshape([e,r,n,a])),t.compute(cn(l,Si.perm),{inputs:[l],outputs:[-1]})[0]},eh=(t,e)=>{let n=du(t.inputs,e);if(t.inputs[0].dims.length===5)throw new Error("Packed QKV is not implemented");if(t.inputs[1]?.dims.length===5)throw new Error("Packed KV is not implemented");let r=t.inputs[1]&&t.inputs[2]&&t.inputs[1].dims.length===4&&t.inputs[2].dims.length===4,a=wa(t,n.batchSize,n.numHeads,n.sequenceLength,n.headSize,t.inputs[0],t.inputs[3],0);if(r)return Ba(t,a,t.inputs[1],t.inputs[2],t.inputs[4],void 0,void 0,void 0,t.inputs[5],n,e);let i=wa(t,n.batchSize,n.numHeads,n.kvSequenceLength,n.headSize,t.inputs[1],t.inputs[3],n.hiddenSize),s=wa(t,n.batchSize,n.numHeads,n.kvSequenceLength,n.vHeadSize,t.inputs[2],t.inputs[3],2*n.hiddenSize);Ba(t,a,i,s,t.inputs[4],void 0,t.inputs[6],t.inputs[7],t.inputs[5],n,e)}}),pu,hu,fu,mu,gu,_u,wu,yu,th,Jg=Y(()=>{Ye(),Ie(),Te(),pu=t=>{if(!t||t.length<1)throw new Error("Too few inputs");if(t[0].dataType!==1)throw new Error("Input type must be float.");if(t.length>=2){let e=t[0].dims.length*2===t[1].dims[0];if(t.length===4&&(e=t[3].dims[0]*2===t[1].dims[0]),!e)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},hu=(t,e,n)=>{let r="";for(let a=e-1;a>=0;--a)r+=`
            k = i32(${t.indicesGet("indices",a)}) - ${xe("uniforms.pads",a,n)};
            if (k < 0) {
              break;
            }
            if (k >= i32(${xe("uniforms.x_shape",a,e)})) {
              break;
            }
            offset += k * i32(${xe("uniforms.x_strides",a,e)});
        `;return`
          value = ${t.type.value}(uniforms.constant_value);
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${r}
            value = x[offset];
          }
      `},fu=(t,e,n)=>{let r="";for(let a=e-1;a>=0;--a)r+=`
                k = i32(${t.indicesGet("indices",a)}) - ${xe("uniforms.pads",a,n)};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = 2 * (i32(${xe("uniforms.x_shape",a,e)}) - 1);
                  k = k % _2n_1;
                  if(k >= i32(${xe("uniforms.x_shape",a,e)})) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * i32(${xe("uniforms.x_strides",a,e)});
            `;return`
              var offset = 0;
              var k = 0;
              ${r}
              value = x[offset];
          `},mu=(t,e,n)=>{let r="";for(let a=e-1;a>=0;--a)r+=`
                k = i32(${t.indicesGet("indices",a)}) - ${xe("uniforms.pads",a,n)};
                if (k < 0) {
                  k = 0;
                }
                if (k >= i32(${xe("uniforms.x_shape",a,e)})) {
                  k = i32(${xe("uniforms.x_shape",a,e)}) - 1;
                }
                offset += k * i32(${xe("uniforms.x_strides",a,e)});
            `;return`
              var offset = 0;
              var k = 0;
              ${r}
              value = x[offset];
          `},gu=(t,e,n)=>{let r="";for(let a=e-1;a>=0;--a)r+=`
                k = i32(${t.indicesGet("indices",a)}) - ${xe("uniforms.pads",a,n)};
                if (k < 0)  {
                  k += i32(${xe("uniforms.x_shape",a,e)}]);
                }
                if (k >= i32(${xe("uniforms.x_shape",a,e)})) {
                  k -= i32(${xe("uniforms.x_shape",a,e)});
                }
                offset += k * i32(${xe("uniforms.x_strides",a,e)});
            `;return`
              var offset = 0;
              var k = 0;
              ${r}
              value = x[offset];
          `},_u=(t,e,n)=>{switch(n.mode){case 0:return hu(t,e,n.pads.length);case 1:return fu(t,e,n.pads.length);case 2:return mu(t,e,n.pads.length);case 3:return gu(t,e,n.pads.length);default:throw new Error("Invalid mode")}},wu=(t,e)=>{let n=J.padShape(t[0].dims.slice(),e.pads),r=t[0].dims,a=[{type:"uint32",data:J.size(n)},{type:"uint32",data:e.pads}];if(e.mode===0){let o=Vt(t[0].dataType);a.push({type:o,data:e.value})}a.push(...re(t[0].dims),...re(n));let i=["rank"],s=o=>{let l=be("output",t[0].dataType,n.length),d=Z("x",t[0].dataType,r.length),p=d.type.value,u=_u(l,r.length,e),f=[{name:"output_size",type:"u32"},{name:"pads",type:"i32",length:e.pads.length}];return e.mode===0&&f.push({name:"constant_value",type:p}),`
            ${o.registerUniforms(f).declareVariables(d,l)}
            ${o.mainStart()}
            ${o.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

            let indices = ${l.offsetToIndices("global_idx")};

            var value = ${p}(0);
            ${u}
            output[global_idx] = value;
        }`};return{name:"Pad",shaderCache:{hint:`${e.mode}`,inputDependencies:i},getRunData:()=>({outputs:[{dims:n,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(J.size(n)/64)},programUniforms:a}),getShaderSource:s}},yu=(t,e)=>{if(t.length>1){let n=t[1].getBigInt64Array(),r=t.length>=3&&t[2].data?t[2].getFloat32Array()[0]:0,a=t[0].dims.length,i=new Int32Array(2*a).fill(0);if(t.length>=4){let o=t[3].getBigInt64Array();for(let l=0;l<o.length;l++)i[Number(o[l])]=Number(n[l]),i[Number(o[l])+a]=Number(n[l+o.length])}else n.forEach((o,l)=>i[Number(l)]=Number(o));let s=[];return i.forEach(o=>s.push(o)),{mode:e.mode,value:r,pads:s}}else return e},th=(t,e)=>{pu(t.inputs);let n=yu(t.inputs,e);t.compute(wu(t.inputs,n),{inputs:[0]})}}),hr,Ei,ki,Ti,Ci,vu,bu,Ii,Ai,nh,rh,Mi,ah,ih,Oi,sh,oh,lh,uh,e0=Y(()=>{Dt(),Ie(),Te(),hr=t=>{if(Ne.webgpu.validateInputContent&&(!t||t.length!==1))throw new Error("Pool ops requires 1 input.")},Ei=(t,e,n)=>{let r=e.format==="NHWC",a=t.dims.slice();r&&a.splice(1,0,a.pop());let i=Object.hasOwnProperty.call(e,"dilations"),s=e.kernelShape.slice(),o=e.strides.slice(),l=i?e.dilations.slice():[],d=e.pads.slice();za.adjustPoolAttributes(n,a,s,o,l,d);let p=za.computePoolOutputShape(n,a,o,l,s,d,e.autoPad),u=Object.assign({},e);i?Object.assign(u,{kernelShape:s,strides:o,pads:d,dilations:l,cacheKey:e.cacheKey}):Object.assign(u,{kernelShape:s,strides:o,pads:d,cacheKey:e.cacheKey});let f=p.slice();return f.push(f.splice(1,1)[0]),[u,r?f:p]},ki=(t,e)=>{let n=e.format==="NHWC",r=J.size(t),a=J.size(e.kernelShape),i=[{type:"uint32",data:r},{type:"uint32",data:a}],s=[{name:"outputSize",type:"u32"},{name:"kernelSize",type:"u32"}];if(e.kernelShape.length<=2){let o=e.kernelShape[e.kernelShape.length-1],l=e.strides[e.strides.length-1],d=e.pads[e.pads.length/2-1],p=e.pads[e.pads.length-1],u=!!(d+p);i.push({type:"uint32",data:o},{type:"uint32",data:l},{type:"uint32",data:d},{type:"uint32",data:p}),s.push({name:"kw",type:"u32"},{name:"sw",type:"u32"},{name:"pwStart",type:"u32"},{name:"pwEnd",type:"u32"});let f=!1;if(e.kernelShape.length===2){let m=e.kernelShape[e.kernelShape.length-2],_=e.strides[e.strides.length-2],v=e.pads[e.pads.length/2-2],$=e.pads[e.pads.length-2];f=!!(v+$),i.push({type:"uint32",data:m},{type:"uint32",data:_},{type:"uint32",data:v},{type:"uint32",data:$}),s.push({name:"kh",type:"u32"},{name:"sh",type:"u32"},{name:"phStart",type:"u32"},{name:"phEnd",type:"u32"})}return[i,s,!0,u,f]}else{if(n)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let o=J.computeStrides(e.kernelShape);i.push({type:"uint32",data:o},{type:"uint32",data:e.pads},{type:"uint32",data:e.strides}),s.push({name:"kernelStrides",type:"u32",length:o.length},{name:"pads",type:"u32",length:e.pads.length},{name:"strides",type:"u32",length:e.strides.length});let l=e.pads.reduce((d,p)=>d+p);return[i,s,!!l,!1,!1]}},Ti=(t,e,n,r,a,i,s,o,l,d,p,u)=>{let f=a.format==="NHWC",m=e.type.value,_=be("output",e.type.tensor,r);if(a.kernelShape.length<=2){let v="",$="",b="",S=n-(f?2:1);if(p?v=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${S}] = indices[${S}] * uniforms.sw - uniforms.pwStart + i;
                  if (xIndices[${S}] < 0 || xIndices[${S}]
                      >= uniforms.x_shape[${S}]) {
                    pad++;
                    continue;
                  }
                  let x_val = x[${e.indicesToOffset("xIndices")}];
                  ${i}
                }`:v=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${S}] = indices[${S}] * uniforms.sw - uniforms.pwStart + i;
                  let x_val = x[${e.indicesToOffset("xIndices")}];
                  ${i}
                }`,a.kernelShape.length===2){let T=n-(f?3:2);u?$=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${T}] = indices[${T}] * uniforms.sh - uniforms.phStart + j;
                  if (xIndices[${T}] < 0 || xIndices[${T}] >= uniforms.x_shape[${T}]) {
                    pad += i32(uniforms.kw);
                    continue;
                  }
              `:$=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${T}] = indices[${T}] * uniforms.sh - uniforms.phStart + j;
                `,b=`
              }
            `}return`
            ${t.registerUniforms(l).declareVariables(e,_)}

            ${t.mainStart()}
              ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

              let indices = ${_.offsetToIndices("global_idx")};
              var xIndices = ${_.offsetToIndices("global_idx")};

              var value = ${m}(${o});
              var pad = 0;
              ${$}
              ${v}
              ${b}
              ${s}

              output[global_idx] = value;
            }`}else{if(f)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let v=a.kernelShape.length,$=a.pads.length,b="";return d?b=`
                if (xIndices[j] >= uniforms.x_shape[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${e.indicesToOffset("xIndices")}];
                ${i}
              }`:b=`
              }
              let x_val = x[${e.indicesToOffset("xIndices")}];
              ${i}
            `,`
            ${t.registerUniforms(l).declareVariables(e,_)}

            ${t.mainStart()}
              ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
              let indices = ${_.offsetToIndices("global_idx")};
              var xIndices = ${_.offsetToIndices("global_idx")};

              var offsets: array<u32, ${v}>;

              var value = ${m}(${o});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {
                var offset = i;
                for (var j = 0u; j < ${v-1}u; j++) {
                  offsets[j] = offset / ${xe("uniforms.kernelStrides","j",v)};
                  offset -= offsets[j] * ${xe("uniforms.kernelStrides","j",v)};
                }
                offsets[${v-1}] = offset;

                isPad = false;
                for (var j = ${n-v}u; j < ${n}u; j++) {
                  xIndices[j] = indices[j] * ${xe("uniforms.strides",`j - ${n-v}u`,v)}
                    + offsets[j - ${n-v}u] - ${xe("uniforms.pads","j - 2u",$)};
                  ${b}
              }
              ${s}

              output[global_idx] = value;
            }`}},Ci=t=>`${t.format};${t.ceilMode};${t.autoPad};${t.kernelShape.length}`,vu=t=>`${Ci(t)};${t.countIncludePad}`,bu=t=>`${Ci(t)};${t.storageOrder};${t.dilations}`,Ii=t=>({format:t.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][t.auto_pad],ceilMode:t.ceil_mode,kernelShape:t.kernel_shape,strides:t.strides,pads:t.pads}),Ai=(t,e,n,r)=>{let[a,i]=Ei(e,r,n),s=Z("x",e.dataType,e.dims.length),o=s.type.value,l="value += x_val;",d="";a.countIncludePad?d+=`value /= ${o}(uniforms.kernelSize);`:d+=`value /= ${o}(i32(uniforms.kernelSize) - pad);`;let[p,u,f,m,_]=ki(i,a);p.push(...re(e.dims),...re(i));let v=["rank"];return{name:t,shaderCache:{hint:`${r.cacheKey};${f};${m};${_}`,inputDependencies:v},getRunData:()=>({outputs:[{dims:i,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(J.size(i)/64)},programUniforms:p}),getShaderSource:$=>Ti($,s,e.dims.length,i.length,a,l,d,0,u,f,m,_)}},nh=t=>{let e=t.count_include_pad!==0,n=Ii(t);if(n.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");let r={countIncludePad:e,...n,cacheKey:""};return{...r,cacheKey:vu(r)}},rh=(t,e)=>{hr(t.inputs),t.compute(Ai("AveragePool",t.inputs[0],!1,e))},Mi={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},ah=t=>{let e=t.format;return{format:e,...Mi,cacheKey:e}},ih=(t,e)=>{hr(t.inputs),t.compute(Ai("GlobalAveragePool",t.inputs[0],!0,e))},Oi=(t,e,n,r)=>{let[a,i]=Ei(e,r,n),s=`
      value = max(x_val, value);
    `,o="",l=Z("x",e.dataType,e.dims.length),d=["rank"],[p,u,f,m,_]=ki(i,a);return p.push(...re(e.dims),...re(i)),{name:t,shaderCache:{hint:`${r.cacheKey};${f};${m};${_}`,inputDependencies:d},getRunData:()=>({outputs:[{dims:i,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(J.size(i)/64)},programUniforms:p}),getShaderSource:v=>Ti(v,l,e.dims.length,i.length,a,s,o,-1e5,u,f,m,_)}},sh=(t,e)=>{hr(t.inputs),t.compute(Oi("MaxPool",t.inputs[0],!1,e))},oh=t=>{let e=t.storage_order,n=t.dilations,r=Ii(t);if(e!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(r.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");let a={storageOrder:e,dilations:n,...r,cacheKey:""};return{...a,cacheKey:bu(a)}},lh=t=>{let e=t.format;return{format:e,...Mi,cacheKey:e}},uh=(t,e)=>{hr(t.inputs),t.compute(Oi("GlobalMaxPool",t.inputs[0],!0,e))}}),$u,xu,dh,t0=Y(()=>{Dt(),Ye(),Te(),$u=(t,e,n)=>{let r=t===e,a=t<e&&n<0,i=t>e&&n>0;if(r||a||i)throw new Error("Range these inputs' contents are invalid.")},xu=(t,e,n,r)=>{let a=Math.abs(Math.ceil((e-t)/n)),i=[a],s=a,o=Vt(r),l=[{type:"uint32",data:s},{type:o,data:t},{type:o,data:n},...re(i)],d=p=>{let u=be("output",r,i.length),f=u.type.value,m=[{name:"outputSize",type:"u32"},{name:"start",type:f},{name:"delta",type:f}];return`
        ${p.registerUniforms(m).declareVariables(u)}
        ${p.mainStart()}
        ${p.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        output[global_idx] = uniforms.start + ${f}(global_idx) * uniforms.delta;
      }`};return{name:"Range",shaderCache:{hint:`${r}`},getShaderSource:d,getRunData:()=>({outputs:[{dims:i,dataType:r}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:l})}},dh=t=>{let e=0,n=0,r=0;t.inputs[0].dataType===6?(e=t.inputs[0].getInt32Array()[0],n=t.inputs[1].getInt32Array()[0],r=t.inputs[2].getInt32Array()[0]):t.inputs[0].dataType===1&&(e=t.inputs[0].getFloat32Array()[0],n=t.inputs[1].getFloat32Array()[0],r=t.inputs[2].getFloat32Array()[0]),Ne.webgpu.validateInputContent&&$u(e,n,r),t.compute(xu(e,n,r,t.inputs[0].dataType),{inputs:[]})}}),Su,Eu,ku,Tu,Cu,Iu,Au,Mu,Ou,zu,Ru,zi,Bu,Pu,Du,Nu,Lu,ch,ph,n0=Y(()=>{Ie(),it(),Te(),Su=(t,e)=>{if(t.every(n=>n>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),t.length>0){if(e.mode==="linear"){if(!(t.length===2||t.length===3||t.length===4&&t[0]===1&&t[1]===1||t.length===4&&t[0]===1&&t[3]===1||t.length===5&&t[0]===1&&t[1]===1))throw new Error(`For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and
            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`)}else if(e.mode==="cubic"&&!(t.length===2||t.length===4&&t[0]===1&&t[1]===1||t.length===4&&t[0]===1&&t[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},Eu=(t,e,n)=>{e.every(a=>a>=0&&a<n||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let r=new Array(n).fill(1);return e.forEach((a,i)=>r[a]=t[i]),r},ku=(t,e,n,r,a,i)=>{let[s,o,l]=n>10?[1,2,3]:[-1,t.length>1?1:-1,-1],d=t[0].dims.length;if(s>0&&t.length>s&&t[s].dims.length>0)t[s].getFloat32Array().forEach(p=>i.push(p));else if(e.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(o>0&&t.length>o&&t[o].dims.length>0){if(t[o].getFloat32Array().forEach(p=>r.push(p)),r.length!==0&&r.length!==d&&n>=18&&r.length!==e.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");Su(r,e),e.axes.length>0&&Eu(r,e.axes,d).forEach((p,u)=>r[u]=p)}if(l>0&&t.length>l&&(t[l].getBigInt64Array().forEach(p=>a.push(Number(p))),a.length!==d||n>=18&&a.length===e.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(e.axes.length>0){if(r.length!==e.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(a.length!==e.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(typeof r<"u"&&typeof a<"u"&&r.length>0&&a.length>d)throw new Error("Resize requires only of scales or sizes to be specified")},Tu=(t,e)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,
     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${e} { `+(()=>{switch(t){case"asymmetric":return`return ${e}(xResized) / ${e}(xScale);`;case"pytorch_half_pixel":return`if (lengthResized > 1) {
                    return (${e}(xResized) + 0.5) / ${e}(xScale) - 0.5;
                  } else {
                    return 0.0;
                  }`;case"tf_half_pixel_for_nn":return`return (${e}(xResized) + 0.5) / ${e}(xScale);`;case"align_corners":return`if (lengthResized == 1) {
                    return 0.0;
                  } else {
                    // The whole part and the fractional part are calculated separately due to inaccuracy of floating
                    // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an
                    // offset-by-one error later in floor().
                    let whole = ${e}(xResized * (lengthOriginal - 1) / (lengthResized - 1));
                    let fract =
                        ${e}(xResized * (lengthOriginal - 1) % (lengthResized - 1)) / ${e}(lengthResized - 1);
                    return whole + fract;
                  }`;case"tf_crop_and_resize":return`if (lengthResized > 1) {
                    return ${e}(roiStart) * ${e}(lengthOriginal - 1) +
                        (${e}(xResized) * ${e}(roiEnd - roiStart) * ${e}(lengthOriginal - 1)) /
                        ${e}(lengthResized - 1);
                  } else {
                    return 0.5 * ${e}(roiStart + roiEnd) * ${e}(lengthOriginal - 1);
                  }`;case"half_pixel_symmetric":return`const outputWidth = ${e}xScale * ${e}(lengthResized);
                  const adjustment = ${e}(lengthResized) / outputWidth;
                  const center = ${e}(lengthOriginal) / 2;
                  const offset = center * (1 - adjustment);
                  return offset + ((${e}(xResized) + 0.5) / ${e}(xScale)) - 0.5;`;case"half_pixel":return`return ((${e}(xResized) + 0.5) / ${e}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${t} is not supported`)}})()+"}",Cu=(t,e,n)=>`fn getNearestPixelFromOriginal(xOriginal: ${n}, isDownSample: bool) -> ${n} {`+(()=>{switch(t){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(e<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${t} is not supported`)}})()+"}",Iu=(t,e,n)=>{let r=new Array(n).fill(0).concat(new Array(n).fill(1)),a=t.length===0?r:t.slice();return e.length>0?(e.forEach((i,s)=>{r[i]=a[s],r[s+n]=a[e.length+s]}),r):a},Au=(t,e,n,r)=>{let a=[];if(n.length>0)if(r.length>0){if(t.forEach(i=>a.push(i)),Math.max(...r)>t.length)throw new Error("axes is out of bound");r.forEach((i,s)=>a[i]=n[s])}else n.forEach(i=>a.push(i));else{if(e.length===0)throw new Error("Resize requires either scales or sizes.");a=t.map((i,s)=>Math.round(i*e[s]))}return a},Mu=(t,e,n)=>{let r=(()=>{switch(n.keepAspectRatioPolicy){case"not_larger":return n.axes.length>0?Math.min(...n.axes.map(i=>e[i]),Number.MAX_VALUE):Math.min(...e,Number.MAX_VALUE);case"not_smaller":return n.axes.length>0?Math.max(...n.axes.map(i=>e[i]),Number.MIN_VALUE):Math.max(...e,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${n.keepAspectRatioPolicy} is not supported`)}})();e.fill(1,0,e.length);let a=t.slice();return n.axes.length>0?(n.axes.forEach(i=>e[i]=r),n.axes.forEach(i=>a[i]=Math.round(t[i]*e[i]))):(e.fill(r,0,e.length),a.forEach((i,s)=>a[s]=Math.round(i*e[s]))),a},Ou=(t,e,n,r,a)=>`
    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${t.type.indices}) -> array<${t.type.value}, ${n.length}> {
      var original_indices: array<${t.type.value}, ${n.length}>;
      for (var i:u32 = 0; i < ${n.length}; i++) {
        var output_index = ${t.indicesGet("output_indices","i")};
        var scale = ${xe("uniforms.scales","i",r)};
        var roi_low = ${xe("uniforms.roi","i",a)};
        var roi_hi = ${xe("uniforms.roi",`i + ${e.length}`,a)};
        if (scale == 1.0) {
          original_indices[i] = ${t.type.value}(output_index);
        } else {
          var input_shape_i = ${xe("uniforms.input_shape","i",e.length)};
          var output_shape_i = ${xe("uniforms.output_shape","i",n.length)};
          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                           input_shape_i, roi_low, roi_hi);
        }
      }
      return original_indices;
    }`,zu=(t,e,n,r,a,i,s)=>`
    fn calculateInputIndicesFromOutputIndices(output_indices: ${e.type.indices}) -> ${t.type.indices} {
      var input_indices: ${t.type.indices};
      for (var i:u32 = 0; i < ${r.length}; i++) {
        var output_index = ${e.indicesGet("output_indices","i")};
        var input_index: u32;
        var scale = ${xe("uniforms.scales","i",a)};
        if (scale == 1.0) {
          input_index = output_index;
        } else {
          var roi_low = ${xe("uniforms.roi","i",i)};
          var roi_hi = ${xe("uniforms.roi",`i + ${n.length}`,i)};
          var input_shape_i = ${xe("uniforms.input_shape","i",n.length)};
          var output_shape_i = ${xe("uniforms.output_shape","i",r.length)};
          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                        input_shape_i, roi_low, roi_hi);
          if (!${s} || (original_idx >= 0 && original_idx < ${e.type.value}(input_shape_i))) {
            if (original_idx < 0) {
              input_index = 0;
            } else if (original_idx > ${e.type.value}(input_shape_i - 1)) {
              input_index = input_shape_i - 1;
            } else {
              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));
            }
          } else {
            input_index = u32(original_idx);
          }
        }
        ${t.indicesSet("input_indices","i"," input_index")}
      }
      return input_indices;
    }`,Ru=(t,e)=>`
    fn checkInputIndices(input_indices: ${t.type.indices}) -> bool {
      for (var i:u32 = 0; i < ${e.length}; i++) {
        var input_index = ${t.indicesGet("input_indices","i")};
        if (input_index < 0 || input_index >= ${xe("uniforms.input_shape","i",e.length)}) {
          return false;
        }
      }
      return true;
    }`,zi=(t,e,n,r)=>t.rank>r?`
    ${t.indicesSet("input_indices",e,"channel")};
    ${t.indicesSet("input_indices",n,"batch")};
`:"",Bu=(t,e,n,r,a)=>{let[i,s,o,l]=n.length===2?[-1,0,1,-1]:[0,2,3,1],d=t.type.value;return`
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${d} {
      var input_indices: ${t.type.indices};
      ${t.indicesSet("input_indices",s,`max(0, min(row, ${n[s]} - 1))`)};
      ${t.indicesSet("input_indices",o,`max(0, min(col, ${n[o]} - 1))`)};
      ${zi(t,l,i,2)}
      return ${t.getByIndices("input_indices")};
    }

    fn bilinearInterpolation(output_indices: ${e.type.indices}) -> ${d} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var row:${d} = originalIndices[${s}];
      var col:${d} = originalIndices[${o}];
      ${r?`if (row < 0 || row > (${n[s]} - 1) || col < 0 || col > (${n[o]} - 1)) {
        return ${a};
      }`:""};
      row = max(0, min(row, ${n[s]} - 1));
      col = max(0, min(col, ${n[o]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = ${n.length>2?`u32(originalIndices[${l}])`:"0"};
      var batch: u32 =  ${n.length>2?`u32(originalIndices[${i}])`:"0"};
      var x11: ${d} = getInputValue(batch, channel, row1, col1);
      var x12: ${d} = getInputValue(batch, channel, row1, col2);
      var x21: ${d} = getInputValue(batch, channel, row2, col1);
      var x22: ${d} = getInputValue(batch, channel, row2, col2);
      var dx1: ${d} = abs(row - ${d}(row1));
      var dx2: ${d} = abs(${d}(row2) - row);
      var dy1: ${d} = abs(col - ${d}(col1));
      var dy2: ${d} = abs(${d}(col2) - col);
      if (row1 == row2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (col1 == col2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`},Pu=(t,e,n,r,a,i,s,o,l,d)=>{let p=n.length===2,[u,f]=p?[0,1]:[2,3],m=t.type.value,_=v=>{let $=v===u?"row":"col";return`
      fn ${$}CubicInterpolation(input_indices: ${t.type.indices}, output_indices: ${e.type.indices}) -> ${m} {
        var output_index = ${e.indicesGet("output_indices",v)};
        var originalIdx: ${m} = getOriginalCoordinateFromResizedCoordinate(output_index, ${a[v]},
        ${r[v]}, ${n[v]}, ${i[v]}, ${i[v]} + ${n.length});
        var fractOriginalIdx: ${m} = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${o} && (originalIdx < 0 || originalIdx > (${n[v]} - 1))) {
          return ${l};
        }
        var data: array<${m}, 4> = array<${m}, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${$}: ${m} = originalIdx + ${m}(i);
          if (${$} < 0 || ${$} >= ${n[v]}) {
            ${d?`coefs[i + 1] = 0.0;
                        continue;`:o?`return ${l};`:`${$} = max(0, min(${$}, ${n[v]} - 1));`};
          }
        var input_indices_copy: ${t.type.indices} = input_indices;
          ${t.indicesSet("input_indices_copy",v,`u32(${$})`)};
          data[i + 1] = ${v===u?t.getByIndices("input_indices_copy"):"rowCubicInterpolation(input_indices_copy, output_indices)"};
        }
        return cubicInterpolation1D(data, coefs);
      }`};return`
    ${_(u)};
    ${_(f)};
  fn getCubicInterpolationCoefs(s: ${m}) -> array<${m}, 4> {
    var absS = abs(s);
    var coeffs: array<${m}, 4> = array<${m}, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: ${m} = 1.0 - absS;
    var twoMinusAbsS: ${m} = 2.0 - absS;
    var onePlusAbsS: ${m} = 1.0 + absS;
    coeffs[0] = ((${s} * onePlusAbsS - 5 * ${s}) * onePlusAbsS + 8 * ${s}) * onePlusAbsS - 4 * ${s};
    coeffs[1] = ((${s} + 2) * absS - (${s} + 3)) * absS * absS + 1;
    coeffs[2] = ((${s} + 2) * oneMinusAbsS - (${s} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${s} * twoMinusAbsS - 5 * ${s}) * twoMinusAbsS + 8 * ${s}) * twoMinusAbsS - 4 * ${s};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<${m}, 4>, coefs: array<${m}, 4>) -> ${m} {
    var coefsSum: ${m} = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(output_indices: ${e.type.indices}) -> ${m} {
    var input_indices: ${t.type.indices} = output_indices;
    return colCubicInterpolation(input_indices, output_indices);
  }
    `},Du=(t,e,n,r,a)=>{let[i,s,o,l,d]=n.length===3?[-1,0,1,2,-1]:[0,2,3,4,1],p=t.type.value;return`
    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${p} {
      var input_indices: ${t.type.indices};
      ${t.indicesSet("input_indices",s,`max(0, min(depth, ${n[s]} - 1))`)};
      ${t.indicesSet("input_indices",o,`max(0, min(height, ${n[o]} - 1))`)};
      ${t.indicesSet("input_indices",l,`max(0, min(width, ${n[l]} - 1))`)};
      ${zi(t,d,i,3)}
      return ${t.getByIndices("input_indices")};
    }

    fn trilinearInterpolation(output_indices: ${e.type.indices}) -> ${p} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var depth:${p} = originalIndices[${s}];
      var height:${p} = originalIndices[${o}];
      var width:${p} = originalIndices[${l}];
      ${r?`if (depth < 0 || depth > (${n[s]} - 1) || height < 0 || height > (${n[o]} - 1) || width < 0 || (width > ${n[l]} - 1)) {
      return ${a};
        }`:""};

    depth = max(0, min(depth, ${n[s]} - 1));
      height = max(0, min(height, ${n[o]} - 1));
      width = max(0, min(width, ${n[l]} - 1));
      var depth1: u32 = u32(depth);
      var height1: u32 = u32(height);
      var width1: u32 = u32(width);
      var depth2: u32 = u32(depth + 1);
      var height2: u32 = u32(height + 1);
      var width2: u32 = u32(width + 1);
      var channel: u32 = ${n.length>3?`u32(originalIndices[${d}])`:"0"};
      var batch: u32 =  ${n.length>3?`u32(originalIndices[${i}])`:"0"};

      var x111: ${p} = getInputValue(batch, channel, depth1, height1, width1);
      var x112: ${p} = getInputValue(batch, channel, depth1, height1, width2);
      var x121: ${p} = getInputValue(batch, channel, depth1, height2, width1);
      var x122: ${p} = getInputValue(batch, channel, depth1, height2, width2);
      var x211: ${p} = getInputValue(batch, channel, depth2, height1, width1);
      var x212: ${p} = getInputValue(batch, channel, depth2, height1, width2);
      var x221: ${p} = getInputValue(batch, channel, depth2, height2, width1);
      var x222: ${p} = getInputValue(batch, channel, depth2, height2, width2);
      var dx1: ${p} = abs(depth - ${p}(depth1));
      var dx2: ${p} = abs(${p}(depth2) - depth);
      var dy1: ${p} = abs(height - ${p}(height1));
      var dy2: ${p} = abs(${p}(height2) - height);
      var dz1: ${p} = abs(width - ${p}(width1));
      var dz2: ${p} = abs(${p}(width2) - width);
      if (depth1 == depth2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (height1 == height2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      if (width1 == width2) {
        dz1 = 0.5;
        dz2 = 0.5;
      }
      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +
              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);
    }`},Nu=(t,e,n,r,a,i)=>{let s=t.dims,o=Iu(i,e.axes,s.length),l=Au(s,r,a,e.axes),d=r.slice();r.length===0&&(d=s.map((S,T)=>S===0?1:l[T]/S),e.keepAspectRatioPolicy!=="stretch"&&(l=Mu(s,d,e)));let p=be("output",t.dataType,l.length),u=Z("input",t.dataType,s.length),f=J.size(l),m=s.length===l.length&&s.every((S,T)=>S===l[T]),_=e.coordinateTransformMode==="tf_crop_and_resize",v=e.extrapolationValue,$=u.type.value,b=S=>`
      ${m?"":`
      ${Tu(e.coordinateTransformMode,$)};
      ${(()=>{switch(e.mode){case"nearest":return`
              ${Ru(u,s)};
              ${Cu(e.nearestMode,n,$)};
              ${zu(u,p,s,l,d.length,o.length,_)};
              `;case"linear":return`
              ${Ou(p,s,l,d.length,o.length)};
              ${(()=>{if(s.length===2||s.length===4)return`${Bu(u,p,s,_,v)}`;if(s.length===3||s.length===5)return`${Du(u,p,s,_,v)}`;throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.")})()};
            `;case"cubic":return`
            ${(()=>{if(s.length===2||s.length===4)return`${Pu(u,p,s,l,d,o,e.cubicCoeffA,_,e.extrapolationValue,e.excludeOutside)}`;throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.")})()};
            `;default:throw Error("Invalid resize mode")}})()};
      `}
      ${S.registerUniform("output_size","u32").registerUniform("scales","f32",d.length).registerUniform("roi","f32",o.length).declareVariables(u,p)}
      ${S.mainStart()}
        ${S.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
        ${m?"output[global_idx] = input[global_idx];":`
        let output_indices = ${p.offsetToIndices("global_idx")};
        var input_indices: ${u.type.indices};
        ${(()=>{switch(e.mode){case"nearest":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);
                if (checkInputIndices(input_indices)) {
                  output[global_idx] = ${u.getByIndices("input_indices")};
                } else {
                  output[global_idx] = ${e.extrapolationValue};
                }`;case"linear":return`output[global_idx] = ${s.length===2||s.length===4?"bilinearInterpolation":"trilinearInterpolation"}(output_indices);`;case"cubic":return"output[global_idx] = bicubicInterpolation(output_indices);";default:throw Error(`Unsupported resize mode: ${e.mode}`)}})()};
`}
      }`;return{name:"Resize",shaderCache:{hint:`${e.cacheKey}|${n}|${d.length>0?d:""}|${a.length>0?a:""}|${o.length>0?o:""}|${m}|${s}`,inputDependencies:["rank"]},getShaderSource:b,getRunData:()=>({outputs:[{dims:l,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:[{type:"uint32",data:f},{type:"float32",data:d},{type:"float32",data:o},...re(s),...re(l)]})}},Lu=t=>{let e=t.customDataBuffer;return new Uint32Array(e,e.byteOffset,1)[0]},ch=(t,e)=>{let n=[],r=[],a=[],i=Lu(t);if(e.antialias!==0)throw Error("Only default value (0) for Antialias attribute is supported");ku(t.inputs,e,i,n,r,a),t.compute(Nu(t.inputs[0],e,i,n,r,a),{inputs:[0]})},ph=t=>{let e=t.antialias,n=t.axes,r=t.coordinateTransformMode,a=t.cubicCoeffA,i=t.excludeOutside!==0,s=t.extrapolationValue,o=t.keepAspectRatioPolicy,l=t.mode,d=t.nearestMode===""?"simple":t.nearestMode;return qe({antialias:e,axes:n,coordinateTransformMode:r,cubicCoeffA:a,excludeOutside:i,extrapolationValue:s,keepAspectRatioPolicy:o,mode:l,nearestMode:d})}}),Fu,Uu,hh,fh,r0=Y(()=>{Ye(),Ie(),it(),Te(),Fu=t=>{if(!t||t.length<3)throw new Error("layerNorm requires at least 3 inputs.");let e=t[0],n=t[1],r=t[2];if(e.dataType!==n.dataType||e.dataType!==r.dataType)throw new Error("All inputs must have the same data type");if(e.dims.length!==3&&e.dims.length!==2)throw new Error("Input must be 2D or 3D");if(n.dims.length!==3&&n.dims.length!==2)throw new Error("Skip must be 2D or 3D");let a=e.dims[e.dims.length-1],i=e.dims[e.dims.length-2];if(n.dims[n.dims.length-1]!==a)throw new Error("Skip must have the same hidden size as input");if(n.dims[n.dims.length-2]!==i)throw new Error("Skip must have the same sequence length as input");if(r.dims.length!==1)throw new Error("Gamma must be 1D");if(r.dims[r.dims.length-1]!==a)throw new Error("Gamma must have the same hidden size as input");if(t.length>3){let s=t[3];if(s.dims.length!==1)throw new Error("Beta must be 1D");if(s.dims[s.dims.length-1]!==a)throw new Error("Beta must have the same hidden size as input")}if(t.length>4){let s=t[4];if(s.dims.length!==1)throw new Error("Bias must be 1D");if(s.dims[s.dims.length-1]!==a)throw new Error("Bias must have the same hidden size as input")}},Uu=(t,e,n,r)=>{let a=t[0].dims,i=J.size(a),s=a,o=i,l=a.slice(-1)[0],d=r?a.slice(0,-1).concat(1):[],p=t.length>3,u=t.length>4,f=r&&n>1,m=r&&n>2,_=n>3,v=gt(l),$=[Z("x",t[0].dataType,t[0].dims,v),Z("skip",t[1].dataType,t[1].dims,v),Z("gamma",t[2].dataType,t[2].dims,v)];p&&$.push(Z("beta",t[3].dataType,t[3].dims,v)),u&&$.push(Z("bias",t[4].dataType,t[4].dims,v)),$.push(be("output",t[0].dataType,s,v)),f&&$.push(be("meanOutput",1,d)),m&&$.push(be("invStdOutput",1,d)),_&&$.push(be("inputSkipBiasSum",t[0].dataType,s,v));let b=xt(t[0].dataType),S=E=>`
      const hiddenSize: f32 = ${l};
      const hiddenSizeVectorized: u32 = ${l/v};
      const epsilon: f32 = ${e.epsilon};

      ${E.declareVariables(...$)}

      ${E.mainStart()}
        ${E.guardAgainstOutOfBoundsWorkgroupSizes(o/l)}
        let offset = global_idx * hiddenSizeVectorized;
        var sum = ${mt("f32",v)};
        var squareSum = ${mt("f32",v)};
        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {
          let skipValue = skip[offset + i];
          let biasValue = ${u?"bias[i]":"0.0"};
          let inputValue = x[offset + i];
          let value = inputValue + skipValue + biasValue;
          ${_?"inputSkipBiasSum[offset + i] = value;":""}
          output[offset + i] = value;
          let f32Value = ${Zt(b,v,"value")};
          sum += f32Value;
          squareSum += f32Value * f32Value;
        }
        let mean = ${Ht("sum",v)} / hiddenSize;
        let invStdDev = inverseSqrt(${Ht("squareSum",v)} / hiddenSize - mean * mean + epsilon);
        ${f?"meanOutput[global_idx] = mean;":""}
        ${m?"invStdOutput[global_idx] = invStdDev;":""}
        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {
          output[offset + i] = (output[offset + i] - ${b}(mean)) * ${b}(invStdDev) * gamma[i]
           + ${p?"beta[i]":"0.0"};
        }
      }`,T=[{dims:s,dataType:t[0].dataType}];return n>1&&T.push({dims:d,dataType:1}),n>2&&T.push({dims:d,dataType:1}),n>3&&T.push({dims:a,dataType:t[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:e.cacheKey},getShaderSource:S,getRunData:()=>({outputs:T,dispatchGroup:{x:Math.ceil(o/l/64)}})}},hh=(t,e)=>{Fu(t.inputs);let n=[0];t.outputCount>1&&n.push(-3),t.outputCount>2&&n.push(-3),t.outputCount>3&&n.push(3),t.compute(Uu(t.inputs,e,t.outputCount,!1),{outputs:n})},fh=t=>{let e=t.epsilon;return qe({epsilon:e})}}),Wu,fr,Vu,Ri,Gu,Hu,mh,gh,a0=Y(()=>{Ye(),Ie(),it(),Te(),Wu=(t,e)=>{if(!t||t.length<1)throw new Error("too few inputs");if(e.axes.length!==0){if(e.axes.length!==e.starts.length||e.axes.length!==e.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(e.starts.length!==e.ends.length)throw new Error("starts and ends must have the same length");t.slice(1).forEach((n,r)=>{if(t[r+1].dataType!==6&&t[r+1].dataType!==7)throw new Error(`Input ${r} must be an array of int32 or int64`)})},fr=(t,e)=>{let n=[];if(t.length>e)if(t[e].dataType===7)t[e].getBigInt64Array().forEach(r=>n.push(Number(r)));else if(t[e].dataType===6)t[e].getInt32Array().forEach(r=>n.push(Number(r)));else throw new Error(`Input ${e} must be an array of int32 or int64`);return n},Vu=(t,e)=>{if(t.length>1){let n=fr(t,1),r=fr(t,2),a=fr(t,3);return a.length===0&&(a=[...Array(t[0].dims.length).keys()]),qe({starts:n,ends:r,axes:a})}else return e},Ri=(t,e,n,r,a)=>{let i=t;return t<0&&(i+=n[r[e]]),a[e]<0?Math.max(0,Math.min(i,n[r[e]]-1)):Math.max(0,Math.min(i,n[r[e]]))},Gu=(t,e,n)=>`fn calculateInputIndices(output_indices: ${e.type.indices}) -> ${t.type.indices} {
          var input_indices: ${t.type.indices};
          var carry = 0u;
          for (var i = ${n.length}; i >= 0; i--) {
            let input_shape_i = ${xe("uniforms.input_shape","i",n.length)};
            let steps_i = ${xe("uniforms.steps","i",n.length)};
            let signs_i = ${xe("uniforms.signs","i",n.length)};
            let starts_i = ${xe("uniforms.starts","i",n.length)};
            var output_index = ${e.indicesGet("output_indices","i")};
            var input_index = output_index * steps_i + starts_i + carry;
            carry = input_index / input_shape_i;
            input_index = input_index % input_shape_i;
            if (signs_i < 0) {
              input_index = input_shape_i - input_index - 1u + starts_i;
            }
            ${t.indicesSet("input_indices","i","input_index")};
          }
          return input_indices;
      }`,Hu=(t,e)=>{let n=t[0].dims,r=J.size(n),a=e.axes.length>0?J.normalizeAxes(e.axes,n.length):[...Array(n.length).keys()],i=fr(t,4);i.forEach(b=>b!==0||(()=>{throw new Error("step cannot be 0")})),i.length===0&&(i=Array(a.length).fill(1));let s=e.starts.map((b,S)=>Ri(b,S,n,a,i)),o=e.ends.map((b,S)=>Ri(b,S,n,a,i));if(a.length!==s.length||a.length!==o.length)throw new Error("start, ends and axes should have the same number of elements");if(a.length!==n.length)for(let b=0;b<n.length;++b)a.includes(b)||(s.splice(b,0,0),o.splice(b,0,n[b]),i.splice(b,0,1));let l=i.map(b=>Math.sign(b));i.forEach((b,S,T)=>{if(b<0){let E=(o[S]-s[S])/b,I=s[S],M=I+E*i[S];s[S]=M,o[S]=I,T[S]=-b}});let d=n.slice(0);a.forEach((b,S)=>{d[b]=Math.ceil((o[b]-s[b])/i[b])});let p={dims:d,dataType:t[0].dataType},u=be("output",t[0].dataType,d.length),f=Z("input",t[0].dataType,t[0].dims.length),m=J.size(d),_=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:s.length},{name:"signs",type:"i32",length:l.length},{name:"steps",type:"u32",length:i.length}],v=[{type:"uint32",data:m},{type:"uint32",data:s},{type:"int32",data:l},{type:"uint32",data:i},...re(t[0].dims),...re(d)],$=b=>`
      ${b.registerUniforms(_).declareVariables(f,u)}
        ${Gu(f,u,n)}
        ${b.mainStart()}
          ${b.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
          let output_indices = ${u.offsetToIndices("global_idx")};
          let input_indices = calculateInputIndices(output_indices);
          ${u.setByOffset("global_idx",f.getByIndices("input_indices"))}
      }`;return{name:"Slice",shaderCache:{hint:`${l.length}_${s.length}_${i.length}`,inputDependencies:["rank"]},getShaderSource:$,getRunData:()=>({outputs:[p],dispatchGroup:{x:Math.ceil(r/64)},programUniforms:v})}},mh=(t,e)=>{Wu(t.inputs,e);let n=Vu(t.inputs,e);t.compute(Hu(t.inputs,n),{inputs:[0]})},gh=t=>{let e=t.starts,n=t.ends,r=t.axes;return qe({starts:e,ends:n,axes:r})}}),qu,ju,_h,wh,i0=Y(()=>{Ie(),it(),Te(),qu=t=>{if(!t||t.length!==1)throw new Error("Softmax op requires 1 input.")},ju=(t,e)=>{let n=t.dims,r=J.size(n),a=64,i=e.axis;if(i<0&&(i=n.length+i),i<n.length-1)throw new Error("softmax only supports last axis for now.");let s=n[i],o=r/s,l=gt(s),d=s/l,p=($,b)=>b===4?`max(max(${$}.x, ${$}.y), max(${$}.z, ${$}.w))`:b===2?`max(${$}.x, ${$}.y)`:b===3?`max(max(${$}.x, ${$}.y), ${$}.z)`:$,u=Z("x",t.dataType,t.dims,l),f=be("result",t.dataType,t.dims,l),m=u.type.value,_=xt(t.dataType)==="f32"?`var threadMax = ${m}(-3.402823e+38f);`:`var threadMax = ${m}(-65504.0h);`,v=$=>`
      var<workgroup> rowMaxShared : ${m};
      var<workgroup> rowSumShared : ${m};
      var<workgroup> threadShared : array<${m}, ${a}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${m} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${m}) {
        let index = row * row_stride + col;
        result[index] = value;
      }
      ${$.registerUniform("packedCols","i32").declareVariables(u,f)}
      ${$.mainStart()}
        let gindex = i32(global_idx);
        let lindex = i32(local_idx);
        const wg = ${a};
        let row = gindex / wg;
        let cols = uniforms.packedCols;
        let row_stride : i32 = uniforms.packedCols;

        // find the rows max
        ${_}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = ${m}(${p("threadShared[0]",l)});
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum = ${m}(0.0);
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = ${m}(${Ht("threadShared[0]",l)});
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          setValue(row, col, row_stride, value);
        }
      }`;return{name:"Softmax",shaderCache:{hint:`${l}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:n,dataType:t.dataType}],dispatchGroup:{x:o},programUniforms:[{type:"uint32",data:d}]}),getShaderSource:v}},_h=(t,e)=>{qu(t.inputs),t.compute(ju(t.inputs[0],e))},wh=t=>qe({axis:t.axis})}),Ku,Yu,Xu,Qu,Zu,yh,vh,s0=Y(()=>{Ie(),it(),Te(),Ku=t=>{if(!t||t.length<1)throw new Error("too few inputs")},Yu=(t,e)=>{let n=[],r=e.numOutputs;return t[1].dims[0]>0&&(t[1].getBigInt64Array().forEach(a=>n.push(Number(a))),r=n.length),qe({numOutputs:r,axis:e.axis,splitSizes:n})},Xu=t=>`
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${t}u; i += 1u ) {
    if (index < ${xe("uniforms.size_in_split_axis","i",t)}) {
        return i;
    }
    }
    return ${t}u;
}`,Qu=t=>{let e=t.length,n=[];for(let r=0;r<e;++r){let a=t[r].setByIndices("indices","input[global_idx]");e===1?n.push(a):r===0?n.push(`if (output_number == ${r}u) { ${a} }`):r===e-1?n.push(`else { ${a} }`):n.push(`else if (output_number == ${r}) { ${a} }`)}return`
      fn writeBufferData(output_number: u32, indices: ${t[0].type.indices}, global_idx: u32) {
        ${n.join(`
`)}
      }`},Zu=(t,e)=>{let n=t[0].dims,r=J.size(n),a=t[0].dataType,i=J.normalizeAxis(e.axis,n.length),s=new Array(e.numOutputs),o=Z("input",a,n),l=new Array(e.numOutputs),d=[],p=[],u=0,f=[{type:"uint32",data:r}];for(let _=0;_<e.numOutputs;_++){u+=e.splitSizes[_],l[_]=u;let v=n.slice();v[e.axis]=e.splitSizes[_],p.push(v),s[_]=be(`output${_}`,a,v),d.push({dims:p[_],dataType:t[0].dataType})}f.push({type:"uint32",data:l}),f.push(...re(n)),p.forEach(_=>f.push(...re(_)));let m=_=>`
  ${_.registerUniform("input_size","u32").registerUniform("size_in_split_axis","u32",l.length).declareVariables(o,...s)}
  ${Xu(l.length)}
  ${Qu(s)}

  ${_.mainStart()}
    ${_.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}

    var indices = ${o.offsetToIndices("global_idx")};
    var index = ${o.indicesGet("indices",i)};
    let output_number = calculateOutputIndex(index);
    if (output_number != 0) {
      index -= ${xe("uniforms.size_in_split_axis","output_number - 1u",l.length)};
      ${o.indicesSet("indices",i,"index")};
    }
    writeBufferData(output_number, indices, global_idx);
  }`;return{name:"Split",shaderCache:{hint:e.cacheKey,inputDependencies:["rank"]},getShaderSource:m,getRunData:()=>({outputs:d,dispatchGroup:{x:Math.ceil(r/64)},programUniforms:f})}},yh=(t,e)=>{Ku(t.inputs);let n=t.inputs.length===1?e:Yu(t.inputs,e);t.compute(Zu(t.inputs,n),{inputs:[0]})},vh=t=>{let e=t.axis,n=t.splitSizes,r=t.numOutputs<0?n.length:t.numOutputs;if(r!==n.length)throw new Error("numOutputs and splitSizes lengh must be equal");return qe({axis:e,numOutputs:r,splitSizes:n})}}),Bi,Ju,ed,td,bh,o0=Y(()=>{Ye(),Ie(),Te(),Bi=t=>Array.from(t.getBigInt64Array(),Number),Ju=t=>{if(!t||t.length!==2)throw new Error("Tile requires 2 inputs.");if(t[0].dataType!==1&&t[0].dataType!==6&&t[0].dataType!==12)throw new Error("Tile only support float, int32, and uint32 data types");if(t[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(t[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(Bi(t[1]).length!==t[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},ed=(t,e)=>{let n=[];for(let r=0;r<t.length;++r)n.push(t[r]*e[r]);return n},td=t=>{let e=t[0].dims,n=Bi(t[1]),r=ed(e,n),a=J.size(r),i=t[0].dataType,s=Z("input",i,e.length),o=be("output",i,r.length),l=d=>`
      const inputShape = ${s.indices(...e)};
      ${d.registerUniform("output_size","u32").declareVariables(s,o)}
      ${d.mainStart()}
      ${d.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let output_indices = ${o.offsetToIndices("global_idx")};
      var input_indices: ${s.type.indices};
      for (var i = 0; i < ${e.length}; i++) {
        let input_dim_i = ${s.indicesGet("uniforms.input_shape","i")};
        let input_dim_value = ${o.indicesGet("output_indices","i")}  % input_dim_i;

        ${s.indicesSet("input_indices","i","input_dim_value")}
      }
      ${o.setByOffset("global_idx",s.getByIndices("input_indices"))}
    }`;return{name:"Tile",shaderCache:{hint:`${n}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:r,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:[{type:"uint32",data:a},...re(t[0].dims),...re(r)]}),getShaderSource:l}},bh=t=>{Ju(t.inputs),t.compute(td(t.inputs),{inputs:[0]})}}),nd,rd,$h,l0=Y(()=>{Ye(),Ie(),Te(),nd=(t,e,n,r,a)=>{let i=be("output_data",a,n.length,4),s=Z("a_data",e[1].dataType,e[1].dims.length,4),o=Z("b_data",e[2].dataType,e[2].dims.length,4),l=Z("c_data",e[0].dataType,e[0].dims.length,4),d,p=(u,f,m)=>`select(${f}, ${u}, ${m})`;if(!r)d=i.setByOffset("global_idx",p(s.getByOffset("global_idx"),o.getByOffset("global_idx"),l.getByOffset("global_idx")));else{let u=(f,m,_="")=>{let v=`a_data[index_a${m}][component_a${m}]`,$=`b_data[index_b${m}][component_b${m}]`,b=`bool(c_data[index_c${m}] & ${4278190080>>>(3-m)*8}u)`;return`
            let output_indices${m} = ${i.offsetToIndices(`global_idx * 4u + ${m}u`)};
            let offset_a${m} = ${s.broadcastedIndicesToOffset(`output_indices${m}`,i)};
            let offset_b${m} = ${o.broadcastedIndicesToOffset(`output_indices${m}`,i)};
            let offset_c${m} = ${l.broadcastedIndicesToOffset(`output_indices${m}`,i)};
            let index_a${m} = offset_a${m} / 4u;
            let index_b${m} = offset_b${m} / 4u;
            let index_c${m} = offset_c${m} / 4u;
            let component_a${m} = offset_a${m} % 4u;
            let component_b${m} = offset_b${m} % 4u;
            ${f}[${m}] = ${_}(${p(v,$,b)});
          `};a===9?d=`
            var data = vec4<u32>(0);
            ${u("data",0,"u32")}
            ${u("data",1,"u32")}
            ${u("data",2,"u32")}
            ${u("data",3,"u32")}
            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:d=`
            ${u("output_data[global_idx]",0)}
            ${u("output_data[global_idx]",1)}
            ${u("output_data[global_idx]",2)}
            ${u("output_data[global_idx]",3)}
          `}return`
        ${t.registerUniform("vec_size","u32").declareVariables(l,s,o,i)}
        ${t.mainStart()}
        ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${d}
      }`},rd=t=>{let e=t[1].dims,n=t[2].dims,r=t[0].dims,a=t[1].dataType,i=!(J.areEqual(e,n)&&J.areEqual(n,r)),s=e,o=J.size(e);if(i){let d=Ln.calcShape(Ln.calcShape(e,n,!1),r,!1);if(!d)throw new Error("Can't perform where op on the given tensors");s=d,o=J.size(s)}let l=Math.ceil(o/4);return{name:"Where",shaderCache:{inputDependencies:["rank","rank","rank"]},getShaderSource:d=>nd(d,t,s,i,a),getRunData:()=>({outputs:[{dims:s,dataType:a}],dispatchGroup:{x:Math.ceil(o/64/4)},programUniforms:[{type:"uint32",data:l},...re(r),...re(e),...re(n),...re(s)]})}},$h=t=>{t.compute(rd(t.inputs))}}),xh,u0=Y(()=>{zg(),Nc(),Rg(),Bg(),Pg(),Dg(),Ng(),Pp(),Vg(),Gg(),Hg(),qg(),jg(),Kg(),Yg(),Xg(),Qg(),Bp(),Zg(),Jg(),e0(),t0(),Es(),n0(),r0(),a0(),i0(),s0(),o0(),Or(),wp(),l0(),xh=new Map([["Abs",[Uc]],["Acos",[Wc]],["Acosh",[Vc]],["Add",[vp]],["ArgMax",[Pc,Yi]],["ArgMin",[Bc,Yi]],["Asin",[Gc]],["Asinh",[Hc]],["Atan",[qc]],["Atanh",[jc]],["Attention",[Dc]],["AveragePool",[rh,nh]],["BatchNormalization",[Lc]],["BiasAdd",[Fc]],["BiasSplitGelu",[yp]],["Cast",[Yc,Kc]],["Ceil",[Qc]],["Clip",[Xc]],["Concat",[Ap,Mp]],["Conv",[es,Ji]],["ConvTranspose",[Lp,Np]],["Cos",[Zc]],["Cosh",[Jc]],["CumSum",[Fp,Up]],["Div",[bp]],["Einsum",[Wp,Vp]],["Elu",[ep,ka]],["Equal",[$p]],["Erf",[tp]],["Exp",[np]],["Expand",[Gp]],["Floor",[rp]],["FusedConv",[es,Ji]],["Gather",[qp,Hp]],["GatherElements",[Kp,jp]],["Gelu",[ap]],["Gemm",[Xp,Yp]],["GlobalAveragePool",[ih,ah]],["GlobalMaxPool",[uh,lh]],["Greater",[kp]],["GreaterOrEqual",[Cp]],["InstanceNormalization",[Qp]],["LayerNormalization",[Zp]],["LeakyRelu",[ip,ka]],["Less",[Tp]],["LessOrEqual",[Ip]],["Log",[_p]],["MatMul",[Rp]],["MaxPool",[sh,oh]],["Mul",[xp]],["MultiHeadAttention",[eh,Jp]],["Neg",[op]],["Not",[sp]],["Pad",[th]],["Pow",[Sp]],["Range",[dh]],["Reciprocal",[lp]],["ReduceMin",[Ac]],["ReduceMean",[Ec]],["ReduceMax",[Ic]],["ReduceSum",[Oc]],["ReduceProd",[Mc]],["ReduceL1",[kc]],["ReduceL2",[Tc]],["ReduceLogSum",[Rc]],["ReduceLogSumExp",[Cc]],["ReduceSumSquare",[zc]],["Relu",[up]],["Resize",[ch,ph]],["Sigmoid",[dp]],["Sin",[cp]],["Sinh",[pp]],["Slice",[mh,gh]],["SkipLayerNormalization",[hh,fh]],["Split",[yh,vh]],["Sqrt",[hp]],["Softmax",[_h,wh]],["Sub",[Ep]],["Tan",[fp]],["Tanh",[mp]],["ThresholdedRelu",[gp,ka]],["Tile",[bh]],["Transpose",[hc,fc]],["Where",[$h]]])}),Sh,d0=Y(()=>{Dt(),xn(),Te(),Sh=class{constructor(t){this.backend=t,this.repo=new Map,this.attributesBound=!1}getArtifact(t){return this.repo.get(t)}setArtifact(t,e){this.repo.set(t,e)}run(t,e,n,r,a){Bt(t.programInfo.name);let i=this.backend.device,s=this.backend.getComputePassEncoder();this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2),s.setPipeline(t.computePipeline);let o=[];for(let d of e)o.push({binding:o.length,resource:{buffer:d.buffer}});for(let d of n)o.push({binding:o.length,resource:{buffer:d.buffer}});a&&o.push({binding:o.length,resource:a});let l=i.createBindGroup({layout:t.computePipeline.getBindGroupLayout(0),entries:o,label:t.programInfo.name});s.setBindGroup(0,l),s.dispatchWorkgroups(...r),this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||this.backend.queryType==="at-passes")&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),Pt(t.programInfo.name)}dispose(){}build(t,e){Bt(t.name);let n=this.backend.device,r=[];n.features.has("shader-f16")&&r.push("enable f16;");let a=pc(e),i=t.getShaderSource(a),s=`${r.join(`
`)}
${a.additionalImplementations}
${i}`,o=n.createShaderModule({code:s,label:t.name});rt("verbose",()=>`[WebGPU] ${t.name} shader code: ${s}`);let l=n.createComputePipeline({compute:{module:o,entryPoint:"main"},layout:"auto",label:t.name});return Pt(t.name),{programInfo:t,computePipeline:l}}normalizeDispatchGroupSize(t){let e=typeof t=="number"?t:t.x,n=typeof t=="number"?1:t.y||1,r=typeof t=="number"?1:t.z||1,a=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(e<=a&&n<=a&&r<=a)return[e,n,r];let i=e*n*r,s=Math.ceil(Math.sqrt(i));if(s>a){if(s=Math.ceil(Math.cbrt(i)),s>a)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[s,s,s]}else return[s,s,1]}}}),ad,id,Eh,c0=Y(()=>{Dt(),Ye(),xn(),Ag(),Mg(),u0(),d0(),ad=(t,e)=>{if(e.length!==t.length)throw new Error(`inputDependencies length ${e.length} is not equal to inputTensors length ${t.length}.`);let n=[];for(let r=0;r<t.length;++r){let a=t[r].dataType;switch(e[r]){case"none":{n.push("");break}case"type":{n.push(`${a}`);break}case"rank":{let i=t[r].dims.length;n.push(`${a};${i}`);break}case"dims":{let i=t[r].dims.join(",");n.push(`${a};${i}`);break}default:throw new Error(`unsupported input dependency: ${e[r]}`)}}return n.join("|")},id=(t,e,n)=>{let r=t.name;return t.shaderCache?.hint&&(r+="["+t.shaderCache.hint+"]"),r+=":"+n+`:${ad(e,t.shaderCache?.inputDependencies??new Array(e.length).fill("dims"))}`,r},Eh=class{constructor(){this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.maxDispatchNumber=16,this.pendingDispatchNumber=0,this.pendingKernels=[],this.pendingQueries=new Map,this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let t=this.kernelCustomData.get(this.currentKernelId);return t||(t={},this.kernelCustomData.set(this.currentKernelId,t)),t}async initialize(t,e){this.env=t;let n=[],r={requiredLimits:{maxComputeWorkgroupStorageSize:e.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:e.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:e.limits.maxStorageBufferBindingSize,maxBufferSize:e.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:e.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:e.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:e.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:e.limits.maxComputeWorkgroupSizeZ},requiredFeatures:n};e.features.has("chromium-experimental-timestamp-query-inside-passes")?n.push("chromium-experimental-timestamp-query-inside-passes"):e.features.has("timestamp-query")&&n.push("timestamp-query"),e.features.has("shader-f16")&&n.push("shader-f16"),this.device=await e.requestDevice(r),this.gpuDataManager=dc(this),this.programManager=new Sh(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,lc(t.logLevel,!!t.debug),this.device.onuncapturederror=a=>{a.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${a.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device}),this.setQueryType()}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder(),this.setQueryType(),this.queryType!=="none"&&typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.maxDispatchNumber*2}),this.queryResolveBuffer=this.device.createBuffer({size:this.maxDispatchNumber*2*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE}))),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let t={};this.queryType==="at-passes"&&(t.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:this.pendingDispatchNumber*2,endOfPassWriteIndex:this.pendingDispatchNumber*2+1}),this.computePassEncoder=this.getCommandEncoder().beginComputePass(t)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;Bt(),this.endComputePass();let t;this.queryType!=="none"&&(this.commandEncoder.resolveQuerySet(this.querySet,0,this.pendingDispatchNumber*2,this.queryResolveBuffer,0),t=this.device.createBuffer({size:this.pendingDispatchNumber*2*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(t,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,t,0,this.pendingDispatchNumber*2*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,this.queryType!=="none"&&t.mapAsync(GPUMapMode.READ).then(()=>{let e=new BigUint64Array(t.getMappedRange()),n=this.pendingQueries.get(t);for(let r=0;r<e.length/2;r++){let a=n[r],i=a.kernelId,s=this.kernels.get(i),o=s.kernelType,l=s.kernelName,d=a.programName,p=a.inputTensorViews,u=a.outputTensorViews,f=e[r*2],m=e[r*2+1];typeof this.queryTimeBase>"u"&&(this.queryTimeBase=f);let _=Number(f-this.queryTimeBase),v=Number(m-this.queryTimeBase);if(!Number.isSafeInteger(_)||!Number.isSafeInteger(v))throw new RangeError("incorrect timestamp range");if(this.env.webgpu.profiling?.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:p.map($=>({dims:$.dims,dataType:Vt($.dataType)})),outputsMetadata:u.map($=>({dims:$.dims,dataType:Vt($.dataType)})),kernelId:i,kernelType:o,kernelName:l,programName:d,startTime:_,endTime:v});else{let $="";p.forEach((S,T)=>{$+=`input[${T}]: [${S.dims}] | ${Vt(S.dataType)}, `});let b="";u.forEach((S,T)=>{b+=`output[${T}]: [${S.dims}] | ${Vt(S.dataType)}, `}),console.log(`[profiling] kernel "${i}|${o}|${l}|${d}" ${$}${b}execution time: ${v-_} ns`)}kr("GPU",`${d}::${f}::${m}`)}t.unmap(),this.pendingQueries.delete(t)}),Pt()}run(t,e,n,r,a){Bt(t.name);let i=[];for(let b=0;b<e.length;++b){let S=this.gpuDataManager.get(e[b].data);if(!S)throw new Error(`no GPU data for input: ${e[b].data}`);i[b]=S}let{outputs:s,dispatchGroup:o,programUniforms:l}=t.getRunData(e),d=n.length===0?s.map((b,S)=>S):n;if(d.length!==s.length)throw new Error(`Output size ${d.length} must be equal to ${s.length}.`);let p=[],u=[];for(let b=0;b<s.length;++b){if(!Number.isInteger(d[b])||d[b]<-3||d[b]>=s.length)throw new Error(`Invalid output index: ${d[b]}`);if(d[b]===-3)continue;let S=d[b]===-1,T=d[b]===-2,E=S||T?a(s[b].dataType,s[b].dims):r(d[b],s[b].dataType,s[b].dims),I=this.gpuDataManager.get(E.data);if(!I)throw new Error(`no GPU data for output: ${E.data}`);if(S&&this.temporaryData.push(I),T){let M=this.kernelPersistentData.get(this.currentKernelId);M||(M=[],this.kernelPersistentData.set(this.currentKernelId,M)),M.push(I)}p.push(E),u.push(I)}let f;if(l){let b=0,S=[];l.forEach(M=>{let F=typeof M.data=="number"?[M.data]:M.data;if(F.length===0)return;let L=F.length<=2?F.length*4:16;b=Math.ceil(b/L)*L,S.push(b),b+=F.length>4?Math.ceil(F.length/4)*16:F.length*4});let T=16;b=Math.ceil(b/T)*T;let E=new ArrayBuffer(b);l.forEach((M,F)=>{let L=S[F],W=typeof M.data=="number"?[M.data]:M.data;M.type==="int32"?new Int32Array(E,L,W.length).set(W):M.type==="uint32"?new Uint32Array(E,L,W.length).set(W):new Float32Array(E,L,W.length).set(W)});let I=this.gpuDataManager.create(b,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(I.buffer,0,E,0,b),this.gpuDataManager.release(I.id),f={offset:0,size:b,buffer:I.buffer}}let m=this.programManager.normalizeDispatchGroupSize(o),_=m[1]===1&&m[2]===1,v=id(t,e,_),$=this.programManager.getArtifact(v);if($||($=this.programManager.build(t,m),this.programManager.setArtifact(v,$),rt("info",()=>`[artifact] key: ${v}, programName: ${t.name}`)),rt("info",()=>`[ProgramManager] run "${t.name}" (key=${v}) with ${m[0]}x${m[1]}x${m[2]}`),this.queryType!=="none"){let b={kernelId:this.currentKernelId,programName:$.programInfo.name,inputTensorViews:e,outputTensorViews:p};this.pendingKernels.push(b)}return this.programManager.run($,i,u,m,f),Pt(t.name),p}upload(t,e){this.gpuDataManager.upload(t,e)}memcpy(t,e){this.gpuDataManager.memcpy(t,e)}async download(t,e){await this.gpuDataManager.download(t,e)}alloc(t){return this.gpuDataManager.create(t).id}free(t){return this.gpuDataManager.release(t)}createKernel(t,e,n,r){let a=xh.get(t);if(!a)throw new Error(`kernel not implemented: ${t}`);let i={kernelType:t,kernelName:r,kernelEntry:a[0],attributes:[a[1],n]};this.kernels.set(e,i)}releaseKernel(t){let e=this.kernelPersistentData.get(t);if(e){for(let n of e)this.gpuDataManager.release(n.id);this.kernelPersistentData.delete(t)}this.kernelCustomData.delete(t),this.kernels.delete(t)}computeKernel(t,e,n){let r=this.kernels.get(t);if(!r)throw new Error(`kernel not created: ${t}`);let a=r.kernelType,i=r.kernelName,s=r.kernelEntry,o=r.attributes;if(this.currentKernelId!==null)throw new Error(`kernel "[${a}] ${i}" is not allowed to be called recursively`);this.currentKernelId=t,o[0]&&(o[1]=o[0](o[1]),o[0]=void 0),rt("info",()=>`[WebGPU] Start to run kernel "[${a}] ${i}"...`);let l=this.env.debug;this.temporaryData=[];try{return l&&this.device.pushErrorScope("validation"),s(e,o[1]),0}catch(d){return n.push(Promise.resolve(`[WebGPU] Kernel "[${a}] ${i}" failed. ${d}`)),1}finally{l&&n.push(this.device.popErrorScope().then(d=>d?`GPU validation error for kernel "[${a}] ${i}": ${d.message}`:null));for(let d of this.temporaryData)this.gpuDataManager.release(d.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(t,e,n,r){let a=this.sessionExternalDataMapping.get(t);a||(a=new Map,this.sessionExternalDataMapping.set(t,a));let i=a.get(e),s=this.gpuDataManager.registerExternalBuffer(n,r,i?.[1]);return a.set(e,[s,n]),s}unregisterBuffers(t){let e=this.sessionExternalDataMapping.get(t);e&&(e.forEach(n=>this.gpuDataManager.unregisterExternalBuffer(n[1])),this.sessionExternalDataMapping.delete(t))}getBuffer(t){let e=this.gpuDataManager.get(t);if(!e)throw new Error(`no GPU data for buffer: ${t}`);return e.buffer}createDownloader(t,e,n){return async()=>{let r=await ji(this,t,e);return uc(r.buffer,n)}}writeTimestamp(t){this.queryType==="inside-passes"&&this.computePassEncoder.writeTimestamp(this.querySet,t)}setQueryType(){this.queryType="none",(this.env.webgpu.profiling?.mode==="default"||this.env.wasm.trace)&&(this.device.features.has("chromium-experimental-timestamp-query-inside-passes")?this.queryType="inside-passes":this.device.features.has("timestamp-query")&&(this.queryType="at-passes"))}}}),kh={};Wn(kh,{init:()=>Th});var ya,sd,Th,p0=Y(()=>{Ye(),c0(),xn(),Ie(),ya=class Ch{constructor(e,n,r,a){this.module=e,this.dataType=n,this.data=r,this.dims=a}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let e=J.size(this.dims);return e===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,e)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let e=J.size(this.dims);return e===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,e)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let e=J.size(this.dims);return e===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,e)}reshape(e){if(J.size(e)!==J.size(this.dims))throw new Error("Invalid new shape");return new Ch(this.module,this.dataType,this.data,e)}},sd=class{constructor(t,e,n){this.module=t,this.backend=e,this.customDataOffset=0,this.customDataSize=0;let r=t.HEAPU32,a=n>>>2;this.opKernelContext=r[a++];let i=r[a++];this.outputCount=r[a++],this.customDataOffset=r[a++],this.customDataSize=r[a++];let s=[];for(let o=0;o<i;o++){let l=r[a++],d=r[a++],p=r[a++],u=[];for(let f=0;f<p;f++)u.push(r[a++]);s.push(new ya(t,l,d,u))}this.inputs=s}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(t,e){let n=e?.inputs?.map(s=>typeof s=="number"?this.inputs[s]:s)??this.inputs,r=e?.outputs??[],a=(s,o,l)=>new ya(this.module,o,this.output(s,l),l),i=(s,o)=>{let l=Aa(s);if(!l)throw new Error(`Unsupported data type: ${s}`);let d=l*J.size(o);return new ya(this.module,s,this.backend.gpuDataManager.create(d).id,o)};return this.backend.run(t,n,r,a,i)}output(t,e){let n=this.module.stackSave();try{let r=this.module.stackAlloc((1+e.length)*4),a=r>>2;this.module.HEAPU32[a++]=e.length;for(let i=0;i<e.length;i++)this.module.HEAPU32[a++]=e[i];return this.module._JsepOutput(this.opKernelContext,t,r)}catch(r){throw new Error(`Failed to generate kernel's output[${t}] with dims [${e}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${r}`)}finally{this.module.stackRestore(n)}}},Th=async(t,e,n)=>{let r=t.jsepInit;if(!r)throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");let a=new Eh;await a.initialize(e,n),r(a,i=>a.alloc(i),i=>a.free(i),(i,s,o,l=!1)=>{if(l)rt("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${i}, dst=${s}, size=${o}`),a.memcpy(i,s);else{rt("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${i}, gpuDataId=${s}, size=${o}`);let d=t.HEAPU8.subarray(i>>>0,(i>>>0)+o);a.upload(s,d)}},async(i,s,o)=>{rt("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${i}, dataOffset=${s}, size=${o}`),await a.download(i,()=>t.HEAPU8.subarray(s>>>0,(s>>>0)+o))},(i,s,o)=>a.createKernel(i,s,o,t.UTF8ToString(t._JsepGetNodeName(s))),i=>a.releaseKernel(i),(i,s,o,l)=>{rt("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${o}, kernel=${i}, contextDataOffset=${s}`);let d=new sd(t,a,s);return a.computeKernel(i,d,l)})}}),od,Ih,Ah,zn,ld,ns,Mh,Oh,Pi,zh,Rh,Bh,h0=Y(()=>{Cg(),Ig(),Ye(),Mr(),ws(),oc(),od=(t,e)=>{et()._OrtInit(t,e)!==0&&He("Can't initialize onnxruntime.")},Ih=async t=>{od(t.wasm.numThreads,Ma(t.logLevel))},Ah=async(t,e)=>{if(e==="webgpu"){if(typeof navigator>"u"||!navigator.gpu)throw new Error("WebGPU is not supported in current environment");let n=await navigator.gpu.requestAdapter();if(!n)throw new Error('Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.');if(!t.wasm.simd)throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using `webgpu` EP");let r=(p0(),$n(kh)).init;await r(et(),t,n)}},zn=new Map,ld=t=>{let e=et(),n=e.stackSave();try{let r=e.stackAlloc(8);return e._OrtGetInputOutputCount(t,r,r+4)!==0&&He("Can't get session input/output count."),[e.HEAP32[r/4],e.HEAP32[r/4+1]]}finally{e.stackRestore(n)}},ns=t=>{let e=et(),n=e._malloc(t.byteLength);if(n===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${t.byteLength}.`);return e.HEAPU8.set(t,n),[n,t.byteLength]},Mh=async(t,e)=>{let n,r,a=et();Array.isArray(t)?[n,r]=t:t.buffer===a.HEAPU8.buffer?[n,r]=[t.byteOffset,t.byteLength]:[n,r]=ns(t);let i=0,s=0,o=0,l=[],d=[],p=[];try{if([s,l]=sc(e),e?.externalData&&a.mountExternalData){let b=[];for(let S of e.externalData){let T=typeof S=="string"?S:S.path;b.push(Oa(typeof S=="string"?S:S.data).then(E=>{a.mountExternalData(T,E)}))}await Promise.all(b)}i=a._OrtCreateSession(n,r,s),i===0&&He("Can't create a session.");let[u,f]=ld(i),m=[],_=[],v=[];for(let b=0;b<u;b++){let S=a._OrtGetInputName(i,b);S===0&&He("Can't get an input name."),d.push(S),m.push(a.UTF8ToString(S))}for(let b=0;b<f;b++){let S=a._OrtGetOutputName(i,b);S===0&&He("Can't get an output name."),p.push(S);let T=a.UTF8ToString(S);_.push(T);{let E=typeof e?.preferredOutputLocation=="string"?e.preferredOutputLocation:e?.preferredOutputLocation?.[T]??"cpu";if(E!=="cpu"&&E!=="cpu-pinned"&&E!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${E}.`);v.push(E)}}let $=null;return v.some(b=>b==="gpu-buffer")&&(o=a._OrtCreateBinding(i),o===0&&He("Can't create IO binding."),$={handle:o,outputPreferredLocations:v,outputPreferredLocationsEncoded:v.map(b=>qi(b))}),zn.set(i,[i,d,p,$]),[i,m,_]}catch(u){throw d.forEach(f=>a._OrtFree(f)),p.forEach(f=>a._OrtFree(f)),o!==0&&a._OrtReleaseBinding(o),i!==0&&a._OrtReleaseSession(i),u}finally{a._free(n),s!==0&&a._OrtReleaseSessionOptions(s),l.forEach(u=>a._free(u)),a.unmountExternalData?.()}},Oh=t=>{let e=et(),n=zn.get(t);if(!n)throw new Error(`cannot release session. invalid session id: ${t}`);let[r,a,i,s]=n;s&&e._OrtReleaseBinding(s.handle),e.jsepUnregisterBuffers?.(t),a.forEach(o=>e._OrtFree(o)),i.forEach(o=>e._OrtFree(o)),e._OrtReleaseSession(r),zn.delete(t)},Pi=(t,e,n,r,a)=>{if(!t){e.push(0);return}let i=et(),s=t[0],o=t[1],l=t[3],d,p;if(s==="string"&&l==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(l==="gpu-buffer"){let m=t[2].gpuBuffer,_=Aa(Hi(s));p=o.reduce((v,$)=>v*$,1)*_,d=i.jsepRegisterBuffer(r,a,m,p)}else{let m=t[2];if(Array.isArray(m)){p=4*m.length,d=i._malloc(p),n.push(d);let _=d/4;for(let v=0;v<m.length;v++){if(typeof m[v]!="string")throw new TypeError(`tensor data at index ${v} is not a string`);i.HEAPU32[_++]=Je(m[v],n)}}else p=m.byteLength,d=i._malloc(p),n.push(d),i.HEAPU8.set(new Uint8Array(m.buffer,m.byteOffset,p),d)}let u=i.stackSave(),f=i.stackAlloc(4*o.length);try{let m=f/4;o.forEach(v=>i.HEAP32[m++]=v);let _=i._OrtCreateTensor(Hi(s),d,p,f,o.length,qi(l));_===0&&He(`Can't create tensor for input/output. session=${r}, index=${a}.`),e.push(_)}finally{i.stackRestore(u)}},zh=async(t,e,n,r,a,i)=>{let s=et(),o=zn.get(t);if(!o)throw new Error(`cannot run inference. invalid session id: ${t}`);let[l,d,p,u]=o,f=e.length,m=r.length,_=0,v=[],$=[],b=[],S=[],T=s.stackSave(),E=s.stackAlloc(f*4),I=s.stackAlloc(f*4),M=s.stackAlloc(m*4),F=s.stackAlloc(m*4);try{[_,v]=ic(i);for(let K=0;K<f;K++)Pi(n[K],$,S,t,e[K]);for(let K=0;K<m;K++)Pi(a[K],b,S,t,f+r[K]);let L=E/4,W=I/4,X=M/4,A=F/4;for(let K=0;K<f;K++)s.HEAPU32[L++]=$[K],s.HEAPU32[W++]=d[e[K]];for(let K=0;K<m;K++)s.HEAPU32[X++]=b[K],s.HEAPU32[A++]=p[r[K]];if(u){let{handle:K,outputPreferredLocations:B,outputPreferredLocationsEncoded:U}=u;if(d.length!==f)throw new Error(`input count from feeds (${f}) is expected to be always equal to model's input count (${d.length}).`);for(let G=0;G<f;G++){let ne=e[G];await s._OrtBindInput(K,d[ne],$[G])!==0&&He(`Can't bind input[${G}] for session=${t}.`)}for(let G=0;G<m;G++){let ne=r[G];a[G]?.[3]?s._OrtBindOutput(K,p[ne],b[G],0)!==0&&He(`Can't bind pre-allocated output[${G}] for session=${t}.`):s._OrtBindOutput(K,p[ne],0,U[ne])!==0&&He(`Can't bind output[${G}] to ${B[G]} for session=${t}.`)}}let q;u?q=await s._OrtRunWithBinding(l,u.handle,m,M,_):q=await s._OrtRun(l,I,E,f,F,m,M,_),q!==0&&He("failed to call OrtRun().");let te=[];for(let K=0;K<m;K++){let B=s.HEAPU32[M/4+K];if(B===b[K]){te.push(a[K]);continue}let U=s.stackSave(),G=s.stackAlloc(4*4),ne=!1,oe,ye=0;try{s._OrtGetTensorData(B,G,G+4,G+8,G+12)!==0&&He(`Can't access output tensor data on index ${K}.`);let V=G/4,ie=s.HEAPU32[V++];ye=s.HEAPU32[V++];let $e=s.HEAPU32[V++],Le=s.HEAPU32[V++],Pe=[];for(let Fe=0;Fe<Le;Fe++)Pe.push(s.HEAPU32[$e/4+Fe]);s._OrtFree($e);let We=Pe.reduce((Fe,Ve)=>Fe*Ve,1);oe=Vt(ie);let ht=u?.outputPreferredLocations[r[K]];if(oe==="string"){if(ht==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let Fe=[],Ve=ye/4;for(let tt=0;tt<We;tt++){let vt=s.HEAPU32[Ve++],Et=tt===We-1?void 0:s.HEAPU32[Ve]-vt;Fe.push(s.UTF8ToString(vt,Et))}te.push([oe,Pe,Fe,"cpu"])}else if(ht==="gpu-buffer"&&We>0){let Fe=s.jsepGetBuffer(ye),Ve=Aa(ie);if(Ve===void 0||!vs(oe))throw new Error(`Unsupported data type: ${oe}`);ne=!0,te.push([oe,Pe,{gpuBuffer:Fe,download:s.jsepCreateDownloader(Fe,We*Ve,oe),dispose:()=>{s._OrtReleaseTensor(B)}},"gpu-buffer"])}else{let Fe=ys(oe),Ve=new Fe(We);new Uint8Array(Ve.buffer,Ve.byteOffset,Ve.byteLength).set(s.HEAPU8.subarray(ye,ye+Ve.byteLength)),te.push([oe,Pe,Ve,"cpu"])}}finally{s.stackRestore(U),oe==="string"&&ye&&s._free(ye),ne||s._OrtReleaseTensor(B)}}return u&&s._OrtClearBoundOutputs(u.handle),te}finally{s.stackRestore(T),$.forEach(L=>s._OrtReleaseTensor(L)),b.forEach(L=>s._OrtReleaseTensor(L)),S.forEach(L=>s._free(L)),_!==0&&s._OrtReleaseRunOptions(_),v.forEach(L=>s._free(L))}},Rh=t=>{let e=et(),n=zn.get(t);if(!n)throw new Error("invalid session id");let r=n[0],a=e._OrtEndProfiling(r);a===0&&He("Can't get an profile file name."),e._OrtFree(a)},Bh=t=>{let e=[];for(let n of t){let r=n[2];!Array.isArray(r)&&"buffer"in r&&e.push(r.buffer)}return e}}),f0=Un((t,e)=>{e.exports='/*!\n * ONNX Runtime Web v1.17.1\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n"use strict";(()=>{var hn=Object.defineProperty;var Lu=Object.getOwnPropertyDescriptor;var Fu=Object.getOwnPropertyNames;var ju=Object.prototype.hasOwnProperty;var j=(e,t)=>()=>(e&&(t=e(e=0)),t);var dr=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),Br=(e,t)=>{for(var r in t)hn(e,r,{get:t[r],enumerable:!0})},qu=(e,t,r,o)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of Fu(t))!ju.call(e,n)&&n!==r&&hn(e,n,{get:()=>t[n],enumerable:!(o=Lu(t,n))||o.enumerable});return e};var Ht=e=>qu(hn({},"__esModule",{value:!0}),e);var gn={};Br(gn,{createReadStream:()=>xo,readFile:()=>Ku,readFileSync:()=>Yu});var Ku,Yu,xo,yn=j(()=>{Ku=void 0,Yu=void 0,xo=void 0});var bn={};Br(bn,{join:()=>Zu});var Zu,wn=j(()=>{Zu=void 0});var Io=dr((Co,vn)=>{"use strict";var _o=(()=>{var e=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(e=e||__filename),function(t={}){var r=t,o,n;r.ready=new Promise((d,m)=>{o=d,n=m}),r.mountExternalData=(d,m)=>{(r.Fa||(r.Fa=new Map)).set(d,m)},r.unmountExternalData=()=>{delete r.Fa},r.jsepInit=(d,m,v,C,B,H,q,le)=>{r.ab=d,r.Qa=m,r.Sa=v,r.La=C,r.Ra=B,r.sa=H,r.Ta=q,r.Ua=le,m=(J,re,se)=>(...we)=>{let _e=tt,P=re?.();we=J(...we);let ue=re?.();return P!==ue&&(J=ue,se(P),re=se=null),tt!=_e?xr():we},v=J=>async(...re)=>{try{if(r.Ea)throw Error("Session already started");let se=r.Ea={Va:re[0],errors:[]},we=await J(...re);if(r.Ea!==se)throw Error("Session mismatch");d.flush();let _e=se.errors;if(0<_e.length){let P=await Promise.all(_e);if(P=P.filter(ue=>ue),0<P.length)throw Error(P.join(`\n`))}return we}finally{r.Ea=null}},r._OrtRun=v(m(r._OrtRun,()=>r._OrtRun,J=>r._OrtRun=J)),r._OrtRunWithBinding=v(m(r._OrtRunWithBinding,()=>r._OrtRunWithBinding,J=>r._OrtRunWithBinding=J)),r._OrtBindInput=m(r._OrtBindInput,()=>r._OrtBindInput,J=>r._OrtBindInput=J),r.jsepRegisterBuffer=(J,re,se,we)=>d.registerBuffer(J,re,se,we),r.jsepUnregisterBuffers=J=>{d.unregisterBuffers(J)},r.jsepGetBuffer=J=>d.getBuffer(J),r.jsepCreateDownloader=(J,re,se)=>d.createDownloader(J,re,se)};var s=Object.assign({},r),u="./this.program",l=(d,m)=>{throw m},a=typeof window=="object",p=typeof importScripts=="function",h=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",g="",b,w,y;if(h){var _=(yn(),Ht(gn)),I=(wn(),Ht(bn));g=p?I.dirname(g)+"/":__dirname+"/",b=(d,m)=>(d=We(d)?new URL(d):I.normalize(d),_.readFileSync(d,m?void 0:"utf8")),y=d=>(d=b(d,!0),d.buffer||(d=new Uint8Array(d)),d),w=(d,m,v,C=!0)=>{d=We(d)?new URL(d):I.normalize(d),_.readFile(d,C?void 0:"utf8",(B,H)=>{B?v(B):m(C?H.buffer:H)})},!r.thisProgram&&1<process.argv.length&&(u=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),l=(d,m)=>{throw process.exitCode=d,m},r.inspect=()=>"[Emscripten Module object]"}else(a||p)&&(p?g=self.location.href:typeof document<"u"&&document.currentScript&&(g=document.currentScript.src),e&&(g=e),g.indexOf("blob:")!==0?g=g.substr(0,g.replace(/[?#].*/,"").lastIndexOf("/")+1):g="",b=d=>{var m=new XMLHttpRequest;return m.open("GET",d,!1),m.send(null),m.responseText},p&&(y=d=>{var m=new XMLHttpRequest;return m.open("GET",d,!1),m.responseType="arraybuffer",m.send(null),new Uint8Array(m.response)}),w=(d,m,v)=>{var C=new XMLHttpRequest;C.open("GET",d,!0),C.responseType="arraybuffer",C.onload=()=>{C.status==200||C.status==0&&C.response?m(C.response):v()},C.onerror=v,C.send(null)});var $=console.log.bind(console),x=console.error.bind(console);Object.assign(r,s),s=null,typeof WebAssembly!="object"&&he("no native wasm support detected");var E,A=!1,z,R,V,T,N,te,Y;function K(){var d=E.buffer;r.HEAP8=R=new Int8Array(d),r.HEAP16=new Int16Array(d),r.HEAPU8=V=new Uint8Array(d),r.HEAPU16=new Uint16Array(d),r.HEAP32=T=new Int32Array(d),r.HEAPU32=N=new Uint32Array(d),r.HEAPF32=te=new Float32Array(d),r.HEAPF64=Y=new Float64Array(d)}var Q=[],Z=[],Ee=[],Pe=0,fe=null,Ie=null;function he(d){throw d="Aborted("+d+")",x(d),A=!0,z=1,d=new WebAssembly.RuntimeError(d+". Build with -sASSERTIONS for more info."),n(d),d}var ye=d=>d.startsWith("data:application/octet-stream;base64,"),We=d=>d.startsWith("file://"),De;if(De="ort-wasm-simd.wasm",!ye(De)){var Ge=De;De=r.locateFile?r.locateFile(Ge,g):g+Ge}function G(d){if(y)return y(d);throw"both async and sync fetching of the wasm failed"}function ee(d){if(a||p){if(typeof fetch=="function"&&!We(d))return fetch(d,{credentials:"same-origin"}).then(m=>{if(!m.ok)throw"failed to load wasm binary file at \'"+d+"\'";return m.arrayBuffer()}).catch(()=>G(d));if(w)return new Promise((m,v)=>{w(d,C=>m(new Uint8Array(C)),v)})}return Promise.resolve().then(()=>G(d))}function be(d,m,v){return ee(d).then(C=>WebAssembly.instantiate(C,m)).then(C=>C).then(v,C=>{x(`failed to asynchronously prepare wasm: ${C}`),he(C)})}function et(d,m){var v=De;return typeof WebAssembly.instantiateStreaming!="function"||ye(v)||We(v)||h||typeof fetch!="function"?be(v,d,m):fetch(v,{credentials:"same-origin"}).then(C=>WebAssembly.instantiateStreaming(C,d).then(m,function(B){return x(`wasm streaming compile failed: ${B}`),x("falling back to ArrayBuffer instantiation"),be(v,d,m)}))}var ze,Ue={931056:(d,m,v,C)=>{if(typeof r>"u"||!r.Fa)return 1;if(d=qe(d>>>0),d.startsWith("./")&&(d=d.substring(2)),d=r.Fa.get(d),!d)return 2;if(m>>>=0,v>>>=0,m+v>d.byteLength)return 3;try{return V.set(d.subarray(m,m+v),C>>>0>>>0),0}catch{return 4}},931557:d=>r.Qa(d),931590:d=>r.Sa(d),931622:(d,m,v)=>{r.La(d,m,v,!0)},931661:(d,m,v)=>{r.La(d,m,v)},931694:d=>{r.sa("Abs",d,void 0)},931745:d=>{r.sa("Neg",d,void 0)},931796:d=>{r.sa("Floor",d,void 0)},931849:d=>{r.sa("Ceil",d,void 0)},931901:d=>{r.sa("Reciprocal",d,void 0)},931959:d=>{r.sa("Sqrt",d,void 0)},932011:d=>{r.sa("Exp",d,void 0)},932062:d=>{r.sa("Erf",d,void 0)},932113:d=>{r.sa("Sigmoid",d,void 0)},932168:d=>{r.sa("Log",d,void 0)},932219:d=>{r.sa("Sin",d,void 0)},932270:d=>{r.sa("Cos",d,void 0)},932321:d=>{r.sa("Tan",d,void 0)},932372:d=>{r.sa("Asin",d,void 0)},932424:d=>{r.sa("Acos",d,void 0)},932476:d=>{r.sa("Atan",d,void 0)},932528:d=>{r.sa("Sinh",d,void 0)},932580:d=>{r.sa("Cosh",d,void 0)},932632:d=>{r.sa("Asinh",d,void 0)},932685:d=>{r.sa("Acosh",d,void 0)},932738:d=>{r.sa("Atanh",d,void 0)},932791:d=>{r.sa("Tanh",d,void 0)},932843:d=>{r.sa("Not",d,void 0)},932894:(d,m,v)=>{r.sa("Clip",d,{min:m,max:v})},932963:d=>{r.sa("Clip",d,void 0)},933015:(d,m)=>{r.sa("Elu",d,{alpha:m})},933073:d=>{r.sa("Relu",d,void 0)},933125:(d,m)=>{r.sa("LeakyRelu",d,{alpha:m})},933189:(d,m)=>{r.sa("ThresholdedRelu",d,{alpha:m})},933259:(d,m)=>{r.sa("Cast",d,{to:m})},933317:d=>{r.sa("Add",d,void 0)},933368:d=>{r.sa("Sub",d,void 0)},933419:d=>{r.sa("Mul",d,void 0)},933470:d=>{r.sa("Div",d,void 0)},933521:d=>{r.sa("Pow",d,void 0)},933572:d=>{r.sa("Equal",d,void 0)},933625:d=>{r.sa("Greater",d,void 0)},933680:d=>{r.sa("GreaterOrEqual",d,void 0)},933742:d=>{r.sa("Less",d,void 0)},933794:d=>{r.sa("LessOrEqual",d,void 0)},933853:(d,m,v,C,B)=>{r.sa("ReduceMean",d,{keepDims:!!m,noopWithEmptyAxes:!!v,axes:C?Array.from(T.subarray(C>>>0,B>>>0)):[]})},934012:(d,m,v,C,B)=>{r.sa("ReduceMax",d,{keepDims:!!m,noopWithEmptyAxes:!!v,axes:C?Array.from(T.subarray(C>>>0,B>>>0)):[]})},934170:(d,m,v,C,B)=>{r.sa("ReduceMin",d,{keepDims:!!m,noopWithEmptyAxes:!!v,axes:C?Array.from(T.subarray(C>>>0,B>>>0)):[]})},934328:(d,m,v,C,B)=>{r.sa("ReduceProd",d,{keepDims:!!m,noopWithEmptyAxes:!!v,axes:C?Array.from(T.subarray(C>>>0,B>>>0)):[]})},934487:(d,m,v,C,B)=>{r.sa("ReduceSum",d,{keepDims:!!m,noopWithEmptyAxes:!!v,axes:C?Array.from(T.subarray(C>>>0,B>>>0)):[]})},934645:(d,m,v,C,B)=>{r.sa("ReduceL1",d,{keepDims:!!m,noopWithEmptyAxes:!!v,axes:C?Array.from(T.subarray(C>>>0,B>>>0)):[]})},934802:(d,m,v,C,B)=>{r.sa("ReduceL2",d,{keepDims:!!m,noopWithEmptyAxes:!!v,axes:C?Array.from(T.subarray(C>>>0,B>>>0)):[]})},934959:(d,m,v,C,B)=>{r.sa("ReduceLogSum",d,{keepDims:!!m,noopWithEmptyAxes:!!v,axes:C?Array.from(T.subarray(C>>>0,B>>>0)):[]})},935120:(d,m,v,C,B)=>{r.sa("ReduceSumSquare",d,{keepDims:!!m,noopWithEmptyAxes:!!v,axes:C?Array.from(T.subarray(C>>>0,B>>>0)):[]})},935284:(d,m,v,C,B)=>{r.sa("ReduceLogSumExp",d,{keepDims:!!m,noopWithEmptyAxes:!!v,axes:C?Array.from(T.subarray(C>>>0,B>>>0)):[]})},935448:d=>{r.sa("Where",d,void 0)},935501:(d,m,v)=>{r.sa("Transpose",d,{perm:m?Array.from(T.subarray(m>>>0,v>>>0)):[]})},935609:(d,m,v,C,B,H,q,le,J,re,se,we,_e,P,ue)=>{r.sa("ConvTranspose",d,{format:J?"NHWC":"NCHW",autoPad:m,dilations:[v],group:C,kernel_shape:[B],pads:[H,q],strides:[le],wIsConst:()=>!!R[re>>>0],outputPadding:se?Array.from(T.subarray(se>>>0,we>>>0)):[],outputShape:_e?Array.from(T.subarray(_e>>>0,P>>>0)):[],activation:qe(ue)})},936011:(d,m,v,C,B,H,q,le,J,re,se,we,_e,P)=>{r.sa("ConvTranspose",d,{format:le?"NHWC":"NCHW",autoPad:m,dilations:Array.from(T.subarray(v>>>0,(v>>>0)+2>>>0)),group:C,kernelShape:Array.from(T.subarray(B>>>0,(B>>>0)+2>>>0)),pads:Array.from(T.subarray(H>>>0,(H>>>0)+4>>>0)),strides:Array.from(T.subarray(q>>>0,(q>>>0)+2>>>0)),wIsConst:()=>!!R[J>>>0],outputPadding:re?Array.from(T.subarray(re>>>0,se>>>0)):[],outputShape:we?Array.from(T.subarray(we>>>0,_e>>>0)):[],activation:qe(P)})},936576:(d,m,v,C,B,H,q,le,J,re,se,we,_e,P,ue)=>{r.sa("ConvTranspose",d,{format:J?"NHWC":"NCHW",autoPad:m,dilations:[v],group:C,kernel_shape:[B],pads:[H,q],strides:[le],wIsConst:()=>!!R[re>>>0],outputPadding:se?Array.from(T.subarray(se>>>0,we>>>0)):[],outputShape:_e?Array.from(T.subarray(_e>>>0,P>>>0)):[],activation:qe(ue)})},936978:(d,m,v,C,B,H,q,le,J,re,se,we,_e,P)=>{r.sa("ConvTranspose",d,{format:le?"NHWC":"NCHW",autoPad:m,dilations:Array.from(T.subarray(v>>>0,(v>>>0)+2>>>0)),group:C,kernelShape:Array.from(T.subarray(B>>>0,(B>>>0)+2>>>0)),pads:Array.from(T.subarray(H>>>0,(H>>>0)+4>>>0)),strides:Array.from(T.subarray(q>>>0,(q>>>0)+2>>>0)),wIsConst:()=>!!R[J>>>0],outputPadding:re?Array.from(T.subarray(re>>>0,se>>>0)):[],outputShape:we?Array.from(T.subarray(we>>>0,_e>>>0)):[],activation:qe(P)})},937543:(d,m)=>{r.sa("GlobalAveragePool",d,{format:m?"NHWC":"NCHW"})},937634:(d,m,v,C,B,H,q,le,J,re,se,we,_e,P,ue,Se)=>{r.sa("AveragePool",d,{format:Se?"NHWC":"NCHW",auto_pad:m,ceil_mode:v,count_include_pad:C,storage_order:B,dilations:[H,q],kernel_shape:[le,J],pads:[re,se,we,_e],strides:[P,ue]})},937918:(d,m)=>{r.sa("GlobalAveragePool",d,{format:m?"NHWC":"NCHW"})},938009:(d,m,v,C,B,H,q,le,J,re,se,we,_e,P,ue,Se)=>{r.sa("AveragePool",d,{format:Se?"NHWC":"NCHW",auto_pad:m,ceil_mode:v,count_include_pad:C,storage_order:B,dilations:[H,q],kernel_shape:[le,J],pads:[re,se,we,_e],strides:[P,ue]})},938293:(d,m)=>{r.sa("GlobalMaxPool",d,{format:m?"NHWC":"NCHW"})},938380:(d,m,v,C,B,H,q,le,J,re,se,we,_e,P,ue,Se)=>{r.sa("MaxPool",d,{format:Se?"NHWC":"NCHW",auto_pad:m,ceil_mode:v,count_include_pad:C,storage_order:B,dilations:[H,q],kernel_shape:[le,J],pads:[re,se,we,_e],strides:[P,ue]})},938660:(d,m)=>{r.sa("GlobalMaxPool",d,{format:m?"NHWC":"NCHW"})},938747:(d,m,v,C,B,H,q,le,J,re,se,we,_e,P,ue,Se)=>{r.sa("MaxPool",d,{format:Se?"NHWC":"NCHW",auto_pad:m,ceil_mode:v,count_include_pad:C,storage_order:B,dilations:[H,q],kernel_shape:[le,J],pads:[re,se,we,_e],strides:[P,ue]})},939027:(d,m,v,C,B)=>{r.sa("Gemm",d,{alpha:m,beta:v,transA:C,transB:B})},939131:d=>{r.sa("MatMul",d,void 0)},939185:(d,m,v,C)=>{r.sa("ArgMax",d,{keepDims:!!m,selectLastIndex:!!v,axis:C})},939293:(d,m,v,C)=>{r.sa("ArgMin",d,{keepDims:!!m,selectLastIndex:!!v,axis:C})},939401:(d,m)=>{r.sa("Softmax",d,{axis:m})},939464:(d,m)=>{r.sa("Concat",d,{axis:m})},939524:(d,m,v,C,B)=>{r.sa("Split",d,{axis:m,numOutputs:v,splitSizes:C?Array.from(T.subarray(C>>>0,B>>>0)):[]})},939664:d=>{r.sa("Expand",d,void 0)},939718:(d,m)=>{r.sa("Gather",d,{axis:Number(m)})},939789:(d,m)=>{r.sa("GatherElements",d,{axis:Number(m)})},939868:(d,m,v,C,B,H,q,le,J,re,se)=>{r.sa("Resize",d,{antialias:m,axes:v?Array.from(T.subarray(v>>>0,C>>>0)):[],coordinateTransformMode:qe(B),cubicCoeffA:H,excludeOutside:q,extrapolationValue:le,keepAspectRatioPolicy:qe(J),mode:qe(re),nearestMode:qe(se)})},940214:(d,m,v,C,B,H,q)=>{r.sa("Slice",d,{starts:m?Array.from(T.subarray(m>>>0,v>>>0)):[],ends:C?Array.from(T.subarray(C>>>0,B>>>0)):[],axes:H?Array.from(T.subarray(H>>>0,q>>>0)):[]})},940430:d=>{r.sa("Tile",d,void 0)},940482:(d,m,v)=>{r.sa("LayerNormalization",d,{axis:Number(m),epsilon:Number(v)})},940589:(d,m,v)=>{r.sa("InstanceNormalization",d,{epsilon:m,format:v?"NHWC":"NCHW"})},940703:(d,m,v)=>{r.sa("InstanceNormalization",d,{epsilon:m,format:v?"NHWC":"NCHW"})},940817:d=>{r.sa("Range",d,void 0)},940870:(d,m)=>{r.sa("Einsum",d,{equation:qe(m)})},940951:(d,m,v,C,B)=>{r.sa("Pad",d,{mode:m,value:v,pads:C?Array.from(T.subarray(C>>>0,B>>>0)):[]})},941078:(d,m,v,C,B,H)=>{r.sa("BatchNormalization",d,{epsilon:m,momentum:v,spatial:!!B,trainingMode:!!C,format:H?"NHWC":"NCHW"})},941247:(d,m,v,C,B,H)=>{r.sa("BatchNormalization",d,{epsilon:m,momentum:v,spatial:!!B,trainingMode:!!C,format:H?"NHWC":"NCHW"})},941416:(d,m,v)=>{r.sa("CumSum",d,{exclusive:Number(m),reverse:Number(v)})},941513:(d,m,v,C,B,H,q,le,J)=>{r.sa("Attention",d,{numHeads:m,isUnidirectional:v,maskFilterValue:C,scale:B,doRotary:H,qkvHiddenSizes:q?Array.from(T.subarray(Number(le)>>>0,Number(le)+q>>>0)):[],pastPresentShareBuffer:!!J})},941785:d=>{r.sa("Gelu",d,void 0)},941837:(d,m,v,C,B,H)=>{r.sa("MultiHeadAttention",d,{numHeads:m,isUnidirectional:v,maskFilterValue:C,scale:B,doRotary:H})},941996:d=>{r.sa("BiasAdd",d,void 0)},942051:d=>{r.sa("BiasSplitGelu",d,void 0)},942112:(d,m)=>{r.sa("SkipLayerNormalization",d,{epsilon:m})},942193:(d,m,v,C,B,H,q,le,J,re,se,we,_e)=>{r.sa("Conv",d,{format:J?"NHWC":"NCHW",auto_pad:m,dilations:[v],group:C,kernel_shape:[B],pads:H?Array.from(T.subarray(H>>>0,q>>>0)):[],strides:[le],w_is_const:()=>!!R[re>>>0],activation:qe(se),activation_params:we?Array.from(te.subarray(we>>>0,_e>>>0)):[]})},942563:(d,m,v,C,B,H,q,le,J,re,se,we,_e,P,ue,Se)=>{r.sa("Conv",d,{format:we?"NHWC":"NCHW",auto_pad:m,dilations:[v,C],group:B,kernel_shape:[H,q],pads:le?Array.from(T.subarray(le>>>0,J>>>0)):[],strides:[re,se],w_is_const:()=>!!R[_e>>>0],activation:qe(P),activation_params:ue?Array.from(te.subarray(ue>>>0,Se>>>0)):[]})},942954:d=>{r.Ta(d)},942988:(d,m)=>r.Ua(d,m,r.Ea.Va,r.Ea.errors)};function Me(d){this.name="ExitStatus",this.message=`Program terminated with exit(${d})`,this.status=d}function wt(d){this.Ja=d-24,this.Oa=function(m){N[this.Ja+4>>>2>>>0]=m},this.Na=function(m){N[this.Ja+8>>>2>>>0]=m},this.$a=function(m,v){this.Ma(),this.Oa(m),this.Na(v)},this.Ma=function(){N[this.Ja+16>>>2>>>0]=0}}var rt=0,Dt=0,At=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,vt=(d,m,v)=>{m>>>=0;var C=m+v;for(v=m;d[v]&&!(v>=C);)++v;if(16<v-m&&d.buffer&&At)return At.decode(d.subarray(m,v));for(C="";m<v;){var B=d[m++];if(B&128){var H=d[m++]&63;if((B&224)==192)C+=String.fromCharCode((B&31)<<6|H);else{var q=d[m++]&63;B=(B&240)==224?(B&15)<<12|H<<6|q:(B&7)<<18|H<<12|q<<6|d[m++]&63,65536>B?C+=String.fromCharCode(B):(B-=65536,C+=String.fromCharCode(55296|B>>10,56320|B&1023))}}else C+=String.fromCharCode(B)}return C},qe=(d,m)=>(d>>>=0)?vt(V,d,m):"",qt=d=>{for(var m=0,v=0;v<d.length;++v){var C=d.charCodeAt(v);127>=C?m++:2047>=C?m+=2:55296<=C&&57343>=C?(m+=4,++v):m+=3}return m},Mt=(d,m,v,C)=>{if(v>>>=0,!(0<C))return 0;var B=v;C=v+C-1;for(var H=0;H<d.length;++H){var q=d.charCodeAt(H);if(55296<=q&&57343>=q){var le=d.charCodeAt(++H);q=65536+((q&1023)<<10)|le&1023}if(127>=q){if(v>=C)break;m[v++>>>0]=q}else{if(2047>=q){if(v+1>=C)break;m[v++>>>0]=192|q>>6}else{if(65535>=q){if(v+2>=C)break;m[v++>>>0]=224|q>>12}else{if(v+3>=C)break;m[v++>>>0]=240|q>>18,m[v++>>>0]=128|q>>12&63}m[v++>>>0]=128|q>>6&63}m[v++>>>0]=128|q&63}}return m[v>>>0]=0,v-B},$t=d=>d%4===0&&(d%100!==0||d%400===0),yt=[0,31,60,91,121,152,182,213,244,274,305,335],zt=[0,31,59,90,120,151,181,212,243,273,304,334],Ut=d=>{var m=qt(d)+1,v=Wt(m);return v&&Mt(d,V,v,m),v},Tt=[],Kt=(d,m)=>{Tt.length=0;for(var v;v=V[d++>>>0];){var C=v!=105;C&=v!=112,m+=C&&m%8?4:0,Tt.push(v==112?N[m>>>2>>>0]:v==105?T[m>>>2>>>0]:Y[m>>>3>>>0]),m+=C?8:4}return Tt},nt={},Yt=()=>{if(!Vt){var d={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:u||"./this.program"},m;for(m in nt)nt[m]===void 0?delete d[m]:d[m]=nt[m];var v=[];for(m in d)v.push(`${m}=${d[m]}`);Vt=v}return Vt},Vt,Ye=[null,[],[]],br=[31,29,31,30,31,30,31,31,30,31,30,31],Oe=[31,28,31,30,31,30,31,31,30,31,30,31];function wr(d){var m=Array(qt(d)+1);return Mt(d,m,0,m.length),m}function Nt(d,m,v,C){function B(P,ue,Se){for(P=typeof P=="number"?P.toString():P||"";P.length<ue;)P=Se[0]+P;return P}function H(P,ue){return B(P,ue,"0")}function q(P,ue){function Se(Tr){return 0>Tr?-1:0<Tr?1:0}var st;return(st=Se(P.getFullYear()-ue.getFullYear()))===0&&(st=Se(P.getMonth()-ue.getMonth()))===0&&(st=Se(P.getDate()-ue.getDate())),st}function le(P){switch(P.getDay()){case 0:return new Date(P.getFullYear()-1,11,29);case 1:return P;case 2:return new Date(P.getFullYear(),0,3);case 3:return new Date(P.getFullYear(),0,2);case 4:return new Date(P.getFullYear(),0,1);case 5:return new Date(P.getFullYear()-1,11,31);case 6:return new Date(P.getFullYear()-1,11,30)}}function J(P){var ue=P.Ca;for(P=new Date(new Date(P.Da+1900,0,1).getTime());0<ue;){var Se=P.getMonth(),st=($t(P.getFullYear())?br:Oe)[Se];if(ue>st-P.getDate())ue-=st-P.getDate()+1,P.setDate(1),11>Se?P.setMonth(Se+1):(P.setMonth(0),P.setFullYear(P.getFullYear()+1));else{P.setDate(P.getDate()+ue);break}}return Se=new Date(P.getFullYear()+1,0,4),ue=le(new Date(P.getFullYear(),0,4)),Se=le(Se),0>=q(ue,P)?0>=q(Se,P)?P.getFullYear()+1:P.getFullYear():P.getFullYear()-1}d>>>=0,m>>>=0,v>>>=0,C>>>=0;var re=N[C+40>>>2>>>0];C={Ya:T[C>>>2>>>0],Xa:T[C+4>>>2>>>0],Ga:T[C+8>>>2>>>0],Ka:T[C+12>>>2>>>0],Ha:T[C+16>>>2>>>0],Da:T[C+20>>>2>>>0],xa:T[C+24>>>2>>>0],Ca:T[C+28>>>2>>>0],bb:T[C+32>>>2>>>0],Wa:T[C+36>>>2>>>0],Za:re?qe(re):""},v=qe(v),re={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var se in re)v=v.replace(new RegExp(se,"g"),re[se]);var we="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),_e="January February March April May June July August September October November December".split(" ");re={"%a":P=>we[P.xa].substring(0,3),"%A":P=>we[P.xa],"%b":P=>_e[P.Ha].substring(0,3),"%B":P=>_e[P.Ha],"%C":P=>H((P.Da+1900)/100|0,2),"%d":P=>H(P.Ka,2),"%e":P=>B(P.Ka,2," "),"%g":P=>J(P).toString().substring(2),"%G":P=>J(P),"%H":P=>H(P.Ga,2),"%I":P=>(P=P.Ga,P==0?P=12:12<P&&(P-=12),H(P,2)),"%j":P=>{for(var ue=0,Se=0;Se<=P.Ha-1;ue+=($t(P.Da+1900)?br:Oe)[Se++]);return H(P.Ka+ue,3)},"%m":P=>H(P.Ha+1,2),"%M":P=>H(P.Xa,2),"%n":()=>`\n`,"%p":P=>0<=P.Ga&&12>P.Ga?"AM":"PM","%S":P=>H(P.Ya,2),"%t":()=>"	","%u":P=>P.xa||7,"%U":P=>H(Math.floor((P.Ca+7-P.xa)/7),2),"%V":P=>{var ue=Math.floor((P.Ca+7-(P.xa+6)%7)/7);if(2>=(P.xa+371-P.Ca-2)%7&&ue++,ue)ue==53&&(Se=(P.xa+371-P.Ca)%7,Se==4||Se==3&&$t(P.Da)||(ue=1));else{ue=52;var Se=(P.xa+7-P.Ca-1)%7;(Se==4||Se==5&&$t(P.Da%400-1))&&ue++}return H(ue,2)},"%w":P=>P.xa,"%W":P=>H(Math.floor((P.Ca+7-(P.xa+6)%7)/7),2),"%y":P=>(P.Da+1900).toString().substring(2),"%Y":P=>P.Da+1900,"%z":P=>{P=P.Wa;var ue=0<=P;return P=Math.abs(P)/60,(ue?"+":"-")+("0000"+(P/60*100+P%60)).slice(-4)},"%Z":P=>P.Za,"%%":()=>"%"},v=v.replace(/%%/g,"\\0\\0");for(se in re)v.includes(se)&&(v=v.replace(new RegExp(se,"g"),re[se](C)));return v=v.replace(/\\0\\0/g,"%"),se=wr(v),se.length>m?0:(R.set(se,d>>>0),se.length-1)}var St=d=>{try{d()}catch(m){he(m)}};function un(){var d=ae,m={};for(let[v,C]of Object.entries(d))m[v]=typeof C=="function"?function(){bt.push(v);try{return C.apply(null,arguments)}finally{A||(bt.pop(),tt&&ot===1&&bt.length===0&&(ot=0,St(ir),typeof Fibers<"u"&&Fibers.cb()))}}:C;return m}var ot=0,tt=null,de=0,bt=[],Zt={},vr={},$r=0,Qt=null,Sr=[];function xr(){return new Promise((d,m)=>{Qt={resolve:d,reject:m}})}function _r(){var d=Wt(65548),m=d+12;N[d>>>2>>>0]=m,N[d+4>>>2>>>0]=m+65536,m=bt[0];var v=Zt[m];return v===void 0&&(v=$r++,Zt[m]=v,vr[v]=m),T[d+8>>>2>>>0]=v,d}function Cr(d){if(!A){if(ot===0){var m=!1,v=!1;d((C=0)=>{if(!A&&(de=C,m=!0,v)){ot=2,St(()=>sr(tt)),typeof Browser<"u"&&Browser.Ia.Pa&&Browser.Ia.resume(),C=!1;try{var B=(0,ae[vr[T[tt+8>>>2>>>0]]])()}catch(le){B=le,C=!0}var H=!1;if(!tt){var q=Qt;q&&(Qt=null,(C?q.reject:q.resolve)(B),H=!0)}if(C&&!H)throw B}}),v=!0,m||(ot=1,tt=_r(),typeof Browser<"u"&&Browser.Ia.Pa&&Browser.Ia.pause(),St(()=>ar(tt)))}else ot===2?(ot=0,St(ur),er(tt),tt=null,Sr.forEach(C=>{if(!A)try{C();try{z=z=C=z,r.onExit?.(C),A=!0,l(C,new Me(C))}catch(B){B instanceof Me||B=="unwind"||l(1,B)}}catch(B){B instanceof Me||B=="unwind"||l(1,B)}})):he(`invalid state: ${ot}`);return de}}function Xt(d){return Cr(m=>{d().then(m)})}var Ir={n:function(d,m,v){return Xt(async()=>{await r.Ra(d,m,v)})},a:function(d,m,v){throw d>>>=0,new wt(d).$a(m>>>0,v>>>0),rt=d,Dt++,rt},g:function(){return 0},J:function(){},A:function(){},C:function(){},L:function(){return 0},H:function(){},D:function(){},G:function(){},l:function(){},B:function(){},y:function(){},I:function(){},z:function(){},m:()=>1,q:function(d,m,v){d=m+2097152>>>0<4194305-!!d?(d>>>0)+4294967296*m:NaN,v>>>=0,d=new Date(1e3*d),T[v>>>2>>>0]=d.getUTCSeconds(),T[v+4>>>2>>>0]=d.getUTCMinutes(),T[v+8>>>2>>>0]=d.getUTCHours(),T[v+12>>>2>>>0]=d.getUTCDate(),T[v+16>>>2>>>0]=d.getUTCMonth(),T[v+20>>>2>>>0]=d.getUTCFullYear()-1900,T[v+24>>>2>>>0]=d.getUTCDay(),T[v+28>>>2>>>0]=(d.getTime()-Date.UTC(d.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},r:function(d,m,v){d=m+2097152>>>0<4194305-!!d?(d>>>0)+4294967296*m:NaN,v>>>=0,d=new Date(1e3*d),T[v>>>2>>>0]=d.getSeconds(),T[v+4>>>2>>>0]=d.getMinutes(),T[v+8>>>2>>>0]=d.getHours(),T[v+12>>>2>>>0]=d.getDate(),T[v+16>>>2>>>0]=d.getMonth(),T[v+20>>>2>>>0]=d.getFullYear()-1900,T[v+24>>>2>>>0]=d.getDay(),T[v+28>>>2>>>0]=($t(d.getFullYear())?yt:zt)[d.getMonth()]+d.getDate()-1|0,T[v+36>>>2>>>0]=-(60*d.getTimezoneOffset()),m=new Date(d.getFullYear(),6,1).getTimezoneOffset();var C=new Date(d.getFullYear(),0,1).getTimezoneOffset();T[v+32>>>2>>>0]=(m!=C&&d.getTimezoneOffset()==Math.min(C,m))|0},s:function(d){d>>>=0;var m=new Date(T[d+20>>>2>>>0]+1900,T[d+16>>>2>>>0],T[d+12>>>2>>>0],T[d+8>>>2>>>0],T[d+4>>>2>>>0],T[d>>>2>>>0],0),v=T[d+32>>>2>>>0],C=m.getTimezoneOffset(),B=new Date(m.getFullYear(),6,1).getTimezoneOffset(),H=new Date(m.getFullYear(),0,1).getTimezoneOffset(),q=Math.min(H,B);return 0>v?T[d+32>>>2>>>0]=+(B!=H&&q==C):0<v!=(q==C)&&(B=Math.max(H,B),m.setTime(m.getTime()+6e4*((0<v?q:B)-C))),T[d+24>>>2>>>0]=m.getDay(),T[d+28>>>2>>>0]=($t(m.getFullYear())?yt:zt)[m.getMonth()]+m.getDate()-1|0,T[d>>>2>>>0]=m.getSeconds(),T[d+4>>>2>>>0]=m.getMinutes(),T[d+8>>>2>>>0]=m.getHours(),T[d+12>>>2>>>0]=m.getDate(),T[d+16>>>2>>>0]=m.getMonth(),T[d+20>>>2>>>0]=m.getYear(),d=m.getTime(),isNaN(d)?(T[Jt()>>>2>>>0]=61,d=-1):d/=1e3,tr((ze=d,1<=+Math.abs(ze)?0<ze?+Math.floor(ze/4294967296)>>>0:~~+Math.ceil((ze-+(~~ze>>>0))/4294967296)>>>0:0)),d>>>0},o:function(){return-52},p:function(){},w:function(d,m,v){function C(J){return(J=J.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?J[1]:"GMT"}v>>>=0;var B=new Date().getFullYear(),H=new Date(B,0,1),q=new Date(B,6,1);B=H.getTimezoneOffset();var le=q.getTimezoneOffset();N[d>>>0>>>2>>>0]=60*Math.max(B,le),T[m>>>0>>>2>>>0]=+(B!=le),d=C(H),m=C(q),d=Ut(d),m=Ut(m),le<B?(N[v>>>2>>>0]=d,N[v+4>>>2>>>0]=m):(N[v>>>2>>>0]=m,N[v+4>>>2>>>0]=d)},e:()=>{he("")},b:function(d,m,v){return d>>>=0,m=Kt(m>>>0,v>>>0),Ue[d].apply(null,m)},i:function(d,m,v){return d>>>=0,m=Kt(m>>>0,v>>>0),Ue[d].apply(null,m)},h:()=>Date.now(),x:function(){return 4294901760},c:()=>performance.now(),K:function(d,m,v){return m>>>=0,V.copyWithin(d>>>0>>>0,m>>>0,m+(v>>>0)>>>0)},u:function(d){d>>>=0;var m=V.length;if(4294901760<d)return!1;for(var v=1;4>=v;v*=2){var C=m*(1+.2/v);C=Math.min(C,d+100663296);var B=Math;C=Math.max(d,C);e:{B=(B.min.call(B,4294901760,C+(65536-C%65536)%65536)-E.buffer.byteLength+65535)/65536;try{E.grow(B),K();var H=1;break e}catch{}H=void 0}if(H)return!0}return!1},E:function(d,m){d>>>=0,m>>>=0;var v=0;return Yt().forEach((C,B)=>{var H=m+v;for(B=N[d+4*B>>>2>>>0]=H,H=0;H<C.length;++H)R[B++>>>0>>>0]=C.charCodeAt(H);R[B>>>0>>>0]=0,v+=C.length+1}),0},F:function(d,m){d>>>=0,m>>>=0;var v=Yt();N[d>>>2>>>0]=v.length;var C=0;return v.forEach(B=>C+=B.length+1),N[m>>>2>>>0]=C,0},f:()=>52,k:function(){return 52},t:function(){return 70},j:function(d,m,v,C){m>>>=0,v>>>=0,C>>>=0;for(var B=0,H=0;H<v;H++){var q=N[m>>>2>>>0],le=N[m+4>>>2>>>0];m+=8;for(var J=0;J<le;J++){var re=V[q+J>>>0],se=Ye[d];re===0||re===10?((d===1?$:x)(vt(se,0)),se.length=0):se.push(re)}B+=le}return N[C>>>2>>>0]=B,0},v:Nt,d:function(d,m,v,C){return Nt(d>>>0,m>>>0,v>>>0,C>>>0)}},ae=function(){function d(v){return ae=v.exports,ae=un(),ae=Ar(),E=ae.M,K(),Z.unshift(ae.N),Pe--,Pe==0&&(fe!==null&&(clearInterval(fe),fe=null),Ie&&(v=Ie,Ie=null,v())),ae}var m={a:Ir};if(Pe++,r.instantiateWasm)try{return r.instantiateWasm(m,d)}catch(v){x(`Module.instantiateWasm callback failed with error: ${v}`),n(v)}return et(m,function(v){d(v.instance)}).catch(n),{}}();r._OrtInit=(d,m)=>(r._OrtInit=ae.O)(d,m),r._OrtGetLastError=(d,m)=>(r._OrtGetLastError=ae.P)(d,m),r._OrtCreateSessionOptions=(d,m,v,C,B,H,q,le,J,re)=>(r._OrtCreateSessionOptions=ae.Q)(d,m,v,C,B,H,q,le,J,re),r._OrtAppendExecutionProvider=(d,m)=>(r._OrtAppendExecutionProvider=ae.R)(d,m),r._OrtAddFreeDimensionOverride=(d,m,v)=>(r._OrtAddFreeDimensionOverride=ae.S)(d,m,v),r._OrtAddSessionConfigEntry=(d,m,v)=>(r._OrtAddSessionConfigEntry=ae.T)(d,m,v),r._OrtReleaseSessionOptions=d=>(r._OrtReleaseSessionOptions=ae.U)(d),r._OrtCreateSession=(d,m,v)=>(r._OrtCreateSession=ae.V)(d,m,v),r._OrtReleaseSession=d=>(r._OrtReleaseSession=ae.W)(d),r._OrtGetInputOutputCount=(d,m,v)=>(r._OrtGetInputOutputCount=ae.X)(d,m,v),r._OrtGetInputName=(d,m)=>(r._OrtGetInputName=ae.Y)(d,m),r._OrtGetOutputName=(d,m)=>(r._OrtGetOutputName=ae.Z)(d,m),r._OrtFree=d=>(r._OrtFree=ae._)(d),r._OrtCreateTensor=(d,m,v,C,B,H)=>(r._OrtCreateTensor=ae.$)(d,m,v,C,B,H),r._OrtGetTensorData=(d,m,v,C,B)=>(r._OrtGetTensorData=ae.aa)(d,m,v,C,B),r._OrtReleaseTensor=d=>(r._OrtReleaseTensor=ae.ba)(d),r._OrtCreateRunOptions=(d,m,v,C)=>(r._OrtCreateRunOptions=ae.ca)(d,m,v,C),r._OrtAddRunConfigEntry=(d,m,v)=>(r._OrtAddRunConfigEntry=ae.da)(d,m,v),r._OrtReleaseRunOptions=d=>(r._OrtReleaseRunOptions=ae.ea)(d),r._OrtCreateBinding=d=>(r._OrtCreateBinding=ae.fa)(d),r._OrtBindInput=(d,m,v)=>(r._OrtBindInput=ae.ga)(d,m,v),r._OrtBindOutput=(d,m,v,C)=>(r._OrtBindOutput=ae.ha)(d,m,v,C),r._OrtClearBoundOutputs=d=>(r._OrtClearBoundOutputs=ae.ia)(d),r._OrtReleaseBinding=d=>(r._OrtReleaseBinding=ae.ja)(d),r._OrtRunWithBinding=(d,m,v,C,B)=>(r._OrtRunWithBinding=ae.ka)(d,m,v,C,B),r._OrtRun=(d,m,v,C,B,H,q,le)=>(r._OrtRun=ae.la)(d,m,v,C,B,H,q,le),r._OrtEndProfiling=d=>(r._OrtEndProfiling=ae.ma)(d),r._JsepOutput=(d,m,v)=>(r._JsepOutput=ae.na)(d,m,v),r._JsepGetNodeName=d=>(r._JsepGetNodeName=ae.oa)(d);var Jt=()=>(Jt=ae.pa)(),Wt=r._malloc=d=>(Wt=r._malloc=ae.qa)(d),er=r._free=d=>(er=r._free=ae.ra)(d),tr=d=>(tr=ae.ta)(d),rr=()=>(rr=ae.ua)(),nr=d=>(nr=ae.va)(d),or=d=>(or=ae.wa)(d),ar=d=>(ar=ae.ya)(d),ir=()=>(ir=ae.za)(),sr=d=>(sr=ae.Aa)(d),ur=()=>(ur=ae.Ba)();r.___start_em_js=943100,r.___stop_em_js=943261;function Ar(){var d=ae;d=Object.assign({},d);var m=C=>()=>C()>>>0,v=C=>B=>C(B)>>>0;return d.pa=m(d.pa),d.qa=v(d.qa),d.ua=m(d.ua),d.wa=v(d.wa),d}r.stackAlloc=or,r.stackSave=rr,r.stackRestore=nr,r.UTF8ToString=qe,r.stringToUTF8=(d,m,v)=>Mt(d,V,m,v),r.lengthBytesUTF8=qt;var xt;Ie=function d(){xt||Et(),xt||(Ie=d)};function Et(){if(!(0<Pe)){if(r.preRun)for(typeof r.preRun=="function"&&(r.preRun=[r.preRun]);r.preRun.length;){var d=r.preRun.shift();Q.unshift(d)}for(;0<Q.length;)Q.shift()(r);if(!(0<Pe||xt||(xt=!0,r.calledRun=!0,A))){for(;0<Z.length;)Z.shift()(r);for(o(r);0<Ee.length;)Ee.shift()(r)}}}return Et(),t.ready}})();typeof Co=="object"&&typeof vn=="object"?vn.exports=_o:typeof define=="function"&&define.amd&&define([],()=>_o)});var Ao=dr(()=>{});var To=dr(()=>{});var Eo={};Br(Eo,{cpus:()=>Qu});var Qu,Oo=j(()=>{Qu=void 0});var Ro=dr((ko,$n)=>{"use strict";var Po=(()=>{var e=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(e=e||__filename),function(t={}){function r(){return Q.buffer!=fe.buffer&&Ge(),fe}function o(){return Q.buffer!=fe.buffer&&Ge(),Ie}function n(){return Q.buffer!=fe.buffer&&Ge(),he}function s(){return Q.buffer!=fe.buffer&&Ge(),ye}function u(){return Q.buffer!=fe.buffer&&Ge(),We}function l(){return Q.buffer!=fe.buffer&&Ge(),De}var a=t,p,h;a.ready=new Promise((i,c)=>{p=i,h=c}),a.mountExternalData=(i,c)=>{(a.cb||(a.cb=new Map)).set(i,c)},a.unmountExternalData=()=>{delete a.cb},a.jsepInit=(i,c,f,S,O,D,W,ie)=>{a.Mb=i,a.wb=c,a.yb=f,a.kb=S,a.xb=O,a.Ea=D,a.zb=W,a.Ab=ie,c=(ne,oe,pe)=>(...xe)=>{let Te=ut,k=oe?.();xe=ne(...xe);let me=oe?.();return k!==me&&(ne=me,pe(k),oe=pe=null),ut!=Te?Mu():xe},f=ne=>async(...oe)=>{try{if(a.bb)throw Error("Session already started");let pe=a.bb={Cb:oe[0],errors:[]},xe=await ne(...oe);if(a.bb!==pe)throw Error("Session mismatch");i.flush();let Te=pe.errors;if(0<Te.length){let k=await Promise.all(Te);if(k=k.filter(me=>me),0<k.length)throw Error(k.join(`\n`))}return xe}finally{a.bb=null}},a._OrtRun=f(c(a._OrtRun,()=>a._OrtRun,ne=>a._OrtRun=ne)),a._OrtRunWithBinding=f(c(a._OrtRunWithBinding,()=>a._OrtRunWithBinding,ne=>a._OrtRunWithBinding=ne)),a._OrtBindInput=c(a._OrtBindInput,()=>a._OrtBindInput,ne=>a._OrtBindInput=ne),a.jsepRegisterBuffer=(ne,oe,pe,xe)=>i.registerBuffer(ne,oe,pe,xe),a.jsepUnregisterBuffers=ne=>{i.unregisterBuffers(ne)},a.jsepGetBuffer=ne=>i.getBuffer(ne),a.jsepCreateDownloader=(ne,oe,pe)=>i.createDownloader(ne,oe,pe)};var g=Object.assign({},a),b="./this.program",w=(i,c)=>{throw c},y=typeof window=="object",_=typeof importScripts=="function",I=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",$=a.ENVIRONMENT_IS_PTHREAD||!1,x="";function E(i){return a.locateFile?a.locateFile(i,x):x+i}var A,z,R;if(I){var V=(yn(),Ht(gn)),T=(wn(),Ht(bn));x=_?T.dirname(x)+"/":__dirname+"/",A=(c,f)=>(c=At(c)?new URL(c):T.normalize(c),V.readFileSync(c,f?void 0:"utf8")),R=c=>(c=A(c,!0),c.buffer||(c=new Uint8Array(c)),c),z=(c,f,S,O=!0)=>{c=At(c)?new URL(c):T.normalize(c),V.readFile(c,O?void 0:"utf8",(D,W)=>{D?S(D):f(O?W.buffer:W)})},!a.thisProgram&&1<process.argv.length&&(b=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),w=(c,f)=>{throw process.exitCode=c,f},a.inspect=()=>"[Emscripten Module object]";let i;try{i=Ao()}catch(c){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),c}global.Worker=i.Worker}else(y||_)&&(_?x=self.location.href:typeof document<"u"&&document.currentScript&&(x=document.currentScript.src),typeof e<"u"&&e&&(x=e),x.indexOf("blob:")!==0?x=x.substr(0,x.replace(/[?#].*/,"").lastIndexOf("/")+1):x="",I||(A=i=>{var c=new XMLHttpRequest;return c.open("GET",i,!1),c.send(null),c.responseText},_&&(R=i=>{var c=new XMLHttpRequest;return c.open("GET",i,!1),c.responseType="arraybuffer",c.send(null),new Uint8Array(c.response)}),z=(i,c,f)=>{var S=new XMLHttpRequest;S.open("GET",i,!0),S.responseType="arraybuffer",S.onload=()=>{S.status==200||S.status==0&&S.response?c(S.response):f()},S.onerror=f,S.send(null)}));I&&typeof performance>"u"&&(global.performance=To().performance);var N=console.log.bind(console),te=console.error.bind(console);I&&(N=(...i)=>V.writeSync(1,i.join(" ")+`\n`),te=(...i)=>V.writeSync(2,i.join(" ")+`\n`));var Y=N,K=te;Object.assign(a,g),g=null,typeof WebAssembly!="object"&&rt("no native wasm support detected");var Q,Z,Ee=!1,Pe,fe,Ie,he,ye,We,De;function Ge(){var i=Q.buffer;a.HEAP8=fe=new Int8Array(i),a.HEAP16=new Int16Array(i),a.HEAPU8=Ie=new Uint8Array(i),a.HEAPU16=new Uint16Array(i),a.HEAP32=he=new Int32Array(i),a.HEAPU32=ye=new Uint32Array(i),a.HEAPF32=We=new Float32Array(i),a.HEAPF64=De=new Float64Array(i)}var G=16777216;if($)Q=a.wasmMemory;else if(a.wasmMemory)Q=a.wasmMemory;else if(Q=new WebAssembly.Memory({initial:G/65536,maximum:65536,shared:!0}),!(Q.buffer instanceof SharedArrayBuffer))throw K("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),I&&K("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");Ge(),G=Q.buffer.byteLength;var ee=[],be=[],et=[],ze=0,Ue=null,Me=null;function wt(){if(ze--,ze==0&&(Ue!==null&&(clearInterval(Ue),Ue=null),Me)){var i=Me;Me=null,i()}}function rt(i){throw i="Aborted("+i+")",K(i),Ee=!0,Pe=1,i=new WebAssembly.RuntimeError(i+". Build with -sASSERTIONS for more info."),h(i),i}var Dt=i=>i.startsWith("data:application/octet-stream;base64,"),At=i=>i.startsWith("file://"),vt;vt="ort-wasm-simd-threaded.wasm",Dt(vt)||(vt=E(vt));function qe(i){if(R)return R(i);throw"both async and sync fetching of the wasm failed"}function qt(i){if(y||_){if(typeof fetch=="function"&&!At(i))return fetch(i,{credentials:"same-origin"}).then(c=>{if(!c.ok)throw"failed to load wasm binary file at \'"+i+"\'";return c.arrayBuffer()}).catch(()=>qe(i));if(z)return new Promise((c,f)=>{z(i,S=>c(new Uint8Array(S)),f)})}return Promise.resolve().then(()=>qe(i))}function Mt(i,c,f){return qt(i).then(S=>WebAssembly.instantiate(S,c)).then(S=>S).then(f,S=>{K(`failed to asynchronously prepare wasm: ${S}`),rt(S)})}function $t(i,c){var f=vt;return typeof WebAssembly.instantiateStreaming!="function"||Dt(f)||At(f)||I||typeof fetch!="function"?Mt(f,i,c):fetch(f,{credentials:"same-origin"}).then(S=>WebAssembly.instantiateStreaming(S,i).then(c,function(O){return K(`wasm streaming compile failed: ${O}`),K("falling back to ArrayBuffer instantiation"),Mt(f,i,c)}))}var yt,zt={932428:(i,c,f,S)=>{if(typeof a>"u"||!a.cb)return 1;if(i=Ye(i>>>0),i.startsWith("./")&&(i=i.substring(2)),i=a.cb.get(i),!i)return 2;if(c>>>=0,f>>>=0,S>>>=0,c+f>i.byteLength)return 3;try{return o().set(i.subarray(c,c+f),S>>>0),0}catch{return 4}},932929:i=>a.wb(i),932962:i=>a.yb(i),932994:(i,c,f)=>{a.kb(i,c,f,!0)},933033:(i,c,f)=>{a.kb(i,c,f)},933066:i=>{a.Ea("Abs",i,void 0)},933117:i=>{a.Ea("Neg",i,void 0)},933168:i=>{a.Ea("Floor",i,void 0)},933221:i=>{a.Ea("Ceil",i,void 0)},933273:i=>{a.Ea("Reciprocal",i,void 0)},933331:i=>{a.Ea("Sqrt",i,void 0)},933383:i=>{a.Ea("Exp",i,void 0)},933434:i=>{a.Ea("Erf",i,void 0)},933485:i=>{a.Ea("Sigmoid",i,void 0)},933540:i=>{a.Ea("Log",i,void 0)},933591:i=>{a.Ea("Sin",i,void 0)},933642:i=>{a.Ea("Cos",i,void 0)},933693:i=>{a.Ea("Tan",i,void 0)},933744:i=>{a.Ea("Asin",i,void 0)},933796:i=>{a.Ea("Acos",i,void 0)},933848:i=>{a.Ea("Atan",i,void 0)},933900:i=>{a.Ea("Sinh",i,void 0)},933952:i=>{a.Ea("Cosh",i,void 0)},934004:i=>{a.Ea("Asinh",i,void 0)},934057:i=>{a.Ea("Acosh",i,void 0)},934110:i=>{a.Ea("Atanh",i,void 0)},934163:i=>{a.Ea("Tanh",i,void 0)},934215:i=>{a.Ea("Not",i,void 0)},934266:(i,c,f)=>{a.Ea("Clip",i,{min:c,max:f})},934335:i=>{a.Ea("Clip",i,void 0)},934387:(i,c)=>{a.Ea("Elu",i,{alpha:c})},934445:i=>{a.Ea("Relu",i,void 0)},934497:(i,c)=>{a.Ea("LeakyRelu",i,{alpha:c})},934561:(i,c)=>{a.Ea("ThresholdedRelu",i,{alpha:c})},934631:(i,c)=>{a.Ea("Cast",i,{to:c})},934689:i=>{a.Ea("Add",i,void 0)},934740:i=>{a.Ea("Sub",i,void 0)},934791:i=>{a.Ea("Mul",i,void 0)},934842:i=>{a.Ea("Div",i,void 0)},934893:i=>{a.Ea("Pow",i,void 0)},934944:i=>{a.Ea("Equal",i,void 0)},934997:i=>{a.Ea("Greater",i,void 0)},935052:i=>{a.Ea("GreaterOrEqual",i,void 0)},935114:i=>{a.Ea("Less",i,void 0)},935166:i=>{a.Ea("LessOrEqual",i,void 0)},935225:(i,c,f,S,O)=>{a.Ea("ReduceMean",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:S?Array.from(n().subarray(S>>>0,O>>>0)):[]})},935384:(i,c,f,S,O)=>{a.Ea("ReduceMax",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:S?Array.from(n().subarray(S>>>0,O>>>0)):[]})},935542:(i,c,f,S,O)=>{a.Ea("ReduceMin",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:S?Array.from(n().subarray(S>>>0,O>>>0)):[]})},935700:(i,c,f,S,O)=>{a.Ea("ReduceProd",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:S?Array.from(n().subarray(S>>>0,O>>>0)):[]})},935859:(i,c,f,S,O)=>{a.Ea("ReduceSum",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:S?Array.from(n().subarray(S>>>0,O>>>0)):[]})},936017:(i,c,f,S,O)=>{a.Ea("ReduceL1",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:S?Array.from(n().subarray(S>>>0,O>>>0)):[]})},936174:(i,c,f,S,O)=>{a.Ea("ReduceL2",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:S?Array.from(n().subarray(S>>>0,O>>>0)):[]})},936331:(i,c,f,S,O)=>{a.Ea("ReduceLogSum",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:S?Array.from(n().subarray(S>>>0,O>>>0)):[]})},936492:(i,c,f,S,O)=>{a.Ea("ReduceSumSquare",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:S?Array.from(n().subarray(S>>>0,O>>>0)):[]})},936656:(i,c,f,S,O)=>{a.Ea("ReduceLogSumExp",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:S?Array.from(n().subarray(S>>>0,O>>>0)):[]})},936820:i=>{a.Ea("Where",i,void 0)},936873:(i,c,f)=>{a.Ea("Transpose",i,{perm:c?Array.from(n().subarray(c>>>0,f>>>0)):[]})},936981:(i,c,f,S,O,D,W,ie,ne,oe,pe,xe,Te,k,me)=>{a.Ea("ConvTranspose",i,{format:ne?"NHWC":"NCHW",autoPad:c,dilations:[f],group:S,kernel_shape:[O],pads:[D,W],strides:[ie],wIsConst:()=>!!r()[oe>>>0],outputPadding:pe?Array.from(n().subarray(pe>>>0,xe>>>0)):[],outputShape:Te?Array.from(n().subarray(Te>>>0,k>>>0)):[],activation:Ye(me)})},937383:(i,c,f,S,O,D,W,ie,ne,oe,pe,xe,Te,k)=>{a.Ea("ConvTranspose",i,{format:ie?"NHWC":"NCHW",autoPad:c,dilations:Array.from(n().subarray(f>>>0,(f>>>0)+2>>>0)),group:S,kernelShape:Array.from(n().subarray(O>>>0,(O>>>0)+2>>>0)),pads:Array.from(n().subarray(D>>>0,(D>>>0)+4>>>0)),strides:Array.from(n().subarray(W>>>0,(W>>>0)+2>>>0)),wIsConst:()=>!!r()[ne>>>0],outputPadding:oe?Array.from(n().subarray(oe>>>0,pe>>>0)):[],outputShape:xe?Array.from(n().subarray(xe>>>0,Te>>>0)):[],activation:Ye(k)})},937948:(i,c,f,S,O,D,W,ie,ne,oe,pe,xe,Te,k,me)=>{a.Ea("ConvTranspose",i,{format:ne?"NHWC":"NCHW",autoPad:c,dilations:[f],group:S,kernel_shape:[O],pads:[D,W],strides:[ie],wIsConst:()=>!!r()[oe>>>0],outputPadding:pe?Array.from(n().subarray(pe>>>0,xe>>>0)):[],outputShape:Te?Array.from(n().subarray(Te>>>0,k>>>0)):[],activation:Ye(me)})},938350:(i,c,f,S,O,D,W,ie,ne,oe,pe,xe,Te,k)=>{a.Ea("ConvTranspose",i,{format:ie?"NHWC":"NCHW",autoPad:c,dilations:Array.from(n().subarray(f>>>0,(f>>>0)+2>>>0)),group:S,kernelShape:Array.from(n().subarray(O>>>0,(O>>>0)+2>>>0)),pads:Array.from(n().subarray(D>>>0,(D>>>0)+4>>>0)),strides:Array.from(n().subarray(W>>>0,(W>>>0)+2>>>0)),wIsConst:()=>!!r()[ne>>>0],outputPadding:oe?Array.from(n().subarray(oe>>>0,pe>>>0)):[],outputShape:xe?Array.from(n().subarray(xe>>>0,Te>>>0)):[],activation:Ye(k)})},938915:(i,c)=>{a.Ea("GlobalAveragePool",i,{format:c?"NHWC":"NCHW"})},939006:(i,c,f,S,O,D,W,ie,ne,oe,pe,xe,Te,k,me,Ce)=>{a.Ea("AveragePool",i,{format:Ce?"NHWC":"NCHW",auto_pad:c,ceil_mode:f,count_include_pad:S,storage_order:O,dilations:[D,W],kernel_shape:[ie,ne],pads:[oe,pe,xe,Te],strides:[k,me]})},939290:(i,c)=>{a.Ea("GlobalAveragePool",i,{format:c?"NHWC":"NCHW"})},939381:(i,c,f,S,O,D,W,ie,ne,oe,pe,xe,Te,k,me,Ce)=>{a.Ea("AveragePool",i,{format:Ce?"NHWC":"NCHW",auto_pad:c,ceil_mode:f,count_include_pad:S,storage_order:O,dilations:[D,W],kernel_shape:[ie,ne],pads:[oe,pe,xe,Te],strides:[k,me]})},939665:(i,c)=>{a.Ea("GlobalMaxPool",i,{format:c?"NHWC":"NCHW"})},939752:(i,c,f,S,O,D,W,ie,ne,oe,pe,xe,Te,k,me,Ce)=>{a.Ea("MaxPool",i,{format:Ce?"NHWC":"NCHW",auto_pad:c,ceil_mode:f,count_include_pad:S,storage_order:O,dilations:[D,W],kernel_shape:[ie,ne],pads:[oe,pe,xe,Te],strides:[k,me]})},940032:(i,c)=>{a.Ea("GlobalMaxPool",i,{format:c?"NHWC":"NCHW"})},940119:(i,c,f,S,O,D,W,ie,ne,oe,pe,xe,Te,k,me,Ce)=>{a.Ea("MaxPool",i,{format:Ce?"NHWC":"NCHW",auto_pad:c,ceil_mode:f,count_include_pad:S,storage_order:O,dilations:[D,W],kernel_shape:[ie,ne],pads:[oe,pe,xe,Te],strides:[k,me]})},940399:(i,c,f,S,O)=>{a.Ea("Gemm",i,{alpha:c,beta:f,transA:S,transB:O})},940503:i=>{a.Ea("MatMul",i,void 0)},940557:(i,c,f,S)=>{a.Ea("ArgMax",i,{keepDims:!!c,selectLastIndex:!!f,axis:S})},940665:(i,c,f,S)=>{a.Ea("ArgMin",i,{keepDims:!!c,selectLastIndex:!!f,axis:S})},940773:(i,c)=>{a.Ea("Softmax",i,{axis:c})},940836:(i,c)=>{a.Ea("Concat",i,{axis:c})},940896:(i,c,f,S,O)=>{a.Ea("Split",i,{axis:c,numOutputs:f,splitSizes:S?Array.from(n().subarray(S>>>0,O>>>0)):[]})},941036:i=>{a.Ea("Expand",i,void 0)},941090:(i,c)=>{a.Ea("Gather",i,{axis:Number(c)})},941161:(i,c)=>{a.Ea("GatherElements",i,{axis:Number(c)})},941240:(i,c,f,S,O,D,W,ie,ne,oe,pe)=>{a.Ea("Resize",i,{antialias:c,axes:f?Array.from(n().subarray(f>>>0,S>>>0)):[],coordinateTransformMode:Ye(O),cubicCoeffA:D,excludeOutside:W,extrapolationValue:ie,keepAspectRatioPolicy:Ye(ne),mode:Ye(oe),nearestMode:Ye(pe)})},941586:(i,c,f,S,O,D,W)=>{a.Ea("Slice",i,{starts:c?Array.from(n().subarray(c>>>0,f>>>0)):[],ends:S?Array.from(n().subarray(S>>>0,O>>>0)):[],axes:D?Array.from(n().subarray(D>>>0,W>>>0)):[]})},941802:i=>{a.Ea("Tile",i,void 0)},941854:(i,c,f)=>{a.Ea("LayerNormalization",i,{axis:Number(c),epsilon:Number(f)})},941961:(i,c,f)=>{a.Ea("InstanceNormalization",i,{epsilon:c,format:f?"NHWC":"NCHW"})},942075:(i,c,f)=>{a.Ea("InstanceNormalization",i,{epsilon:c,format:f?"NHWC":"NCHW"})},942189:i=>{a.Ea("Range",i,void 0)},942242:(i,c)=>{a.Ea("Einsum",i,{equation:Ye(c)})},942323:(i,c,f,S,O)=>{a.Ea("Pad",i,{mode:c,value:f,pads:S?Array.from(n().subarray(S>>>0,O>>>0)):[]})},942450:(i,c,f,S,O,D)=>{a.Ea("BatchNormalization",i,{epsilon:c,momentum:f,spatial:!!O,trainingMode:!!S,format:D?"NHWC":"NCHW"})},942619:(i,c,f,S,O,D)=>{a.Ea("BatchNormalization",i,{epsilon:c,momentum:f,spatial:!!O,trainingMode:!!S,format:D?"NHWC":"NCHW"})},942788:(i,c,f)=>{a.Ea("CumSum",i,{exclusive:Number(c),reverse:Number(f)})},942885:(i,c,f,S,O,D,W,ie,ne)=>{a.Ea("Attention",i,{numHeads:c,isUnidirectional:f,maskFilterValue:S,scale:O,doRotary:D,qkvHiddenSizes:W?Array.from(n().subarray(Number(ie)>>>0,Number(ie)+W>>>0)):[],pastPresentShareBuffer:!!ne})},943157:i=>{a.Ea("Gelu",i,void 0)},943209:(i,c,f,S,O,D)=>{a.Ea("MultiHeadAttention",i,{numHeads:c,isUnidirectional:f,maskFilterValue:S,scale:O,doRotary:D})},943368:i=>{a.Ea("BiasAdd",i,void 0)},943423:i=>{a.Ea("BiasSplitGelu",i,void 0)},943484:(i,c)=>{a.Ea("SkipLayerNormalization",i,{epsilon:c})},943565:(i,c,f,S,O,D,W,ie,ne,oe,pe,xe,Te)=>{a.Ea("Conv",i,{format:ne?"NHWC":"NCHW",auto_pad:c,dilations:[f],group:S,kernel_shape:[O],pads:D?Array.from(n().subarray(D>>>0,W>>>0)):[],strides:[ie],w_is_const:()=>!!r()[oe>>>0],activation:Ye(pe),activation_params:xe?Array.from(u().subarray(xe>>>0,Te>>>0)):[]})},943935:(i,c,f,S,O,D,W,ie,ne,oe,pe,xe,Te,k,me,Ce)=>{a.Ea("Conv",i,{format:xe?"NHWC":"NCHW",auto_pad:c,dilations:[f,S],group:O,kernel_shape:[D,W],pads:ie?Array.from(n().subarray(ie>>>0,ne>>>0)):[],strides:[oe,pe],w_is_const:()=>!!r()[Te>>>0],activation:Ye(k),activation_params:me?Array.from(u().subarray(me>>>0,Ce>>>0)):[]})},944326:i=>{a.zb(i)},944360:(i,c)=>a.Ab(i,c,a.bb.Cb,a.bb.errors)};function Ut(i){this.name="ExitStatus",this.message=`Program terminated with exit(${i})`,this.status=i}var Tt=i=>{i.terminate(),i.onmessage=()=>{}},Kt=i=>{de.Ya.length==0&&(ot(),de.lb(de.Ya[0]));var c=de.Ya.pop();if(!c)return 6;de.Za.push(c),de.Qa[i.Xa]=c,c.Xa=i.Xa;var f={cmd:"run",start_routine:i.Db,arg:i.tb,pthread_ptr:i.Xa};return I&&c.unref(),c.postMessage(f,i.Jb),0},nt=0,Yt=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Vt=(i,c,f)=>{c>>>=0;var S=c+f;for(f=c;i[f]&&!(f>=S);)++f;if(16<f-c&&i.buffer&&Yt)return Yt.decode(i.buffer instanceof SharedArrayBuffer?i.slice(c,f):i.subarray(c,f));for(S="";c<f;){var O=i[c++];if(O&128){var D=i[c++]&63;if((O&224)==192)S+=String.fromCharCode((O&31)<<6|D);else{var W=i[c++]&63;O=(O&240)==224?(O&15)<<12|D<<6|W:(O&7)<<18|D<<12|W<<6|i[c++]&63,65536>O?S+=String.fromCharCode(O):(O-=65536,S+=String.fromCharCode(55296|O>>10,56320|O&1023))}}else S+=String.fromCharCode(O)}return S},Ye=(i,c)=>(i>>>=0)?Vt(o(),i,c):"",br=i=>{var c=mn();return i=i(),kr(c),i};function Oe(i,c){var f=arguments.length-2,S=arguments;return br(()=>{for(var O=fn(8*f),D=O>>>3,W=0;W<f;W++){var ie=S[2+W];l()[D+W>>>0]=ie}return po(i,f,O,c)})}function wr(i){if($)return Oe(0,1,i);Pe=i,0<nt||(de.Eb(),a.onExit?.(i),Ee=!0),w(i,new Ut(i))}var Nt=i=>{if(Pe=i,$)throw Zt(i),"unwind";wr(i)},St=i=>{i instanceof Ut||i=="unwind"||w(1,i)};function un(){for(var i=a.numThreads;i--;)ot();ee.unshift(()=>{ze++,tt(()=>wt())})}function ot(){var i=E("ort-wasm-simd-threaded.worker.js");i=new Worker(i),de.Ya.push(i)}function tt(i){$?i():Promise.all(de.Ya.map(de.lb)).then(i)}var de={Ya:[],Za:[],pb:[],Qa:{},hb(){$?(de.receiveObjectTransfer=de.Bb,de.threadInitTLS=de.ob,de.setExitStatus=de.nb):un()},nb:i=>Pe=i,Nb:["$terminateWorker"],Eb:()=>{for(var i of de.Za)Tt(i);for(i of de.Ya)Tt(i);de.Ya=[],de.Za=[],de.Qa=[]},mb:i=>{var c=i.Xa;delete de.Qa[c],de.Ya.push(i),de.Za.splice(de.Za.indexOf(i),1),i.Xa=0,cn(c)},Bb(){},ob(){de.pb.forEach(i=>i())},lb:i=>new Promise(c=>{i.onmessage=D=>{D=D.data;var W=D.cmd;if(D.targetThread&&D.targetThread!=Pr()){var ie=de.Qa[D.targetThread];ie?ie.postMessage(D,D.transferList):K(`Internal error! Worker sent a message "${W}" to target pthread ${D.targetThread}, but that thread no longer exists!`)}else W==="checkMailbox"?Et():W==="spawnThread"?Kt(D):W==="cleanupThread"?de.mb(de.Qa[D.thread]):W==="killThread"?(D=D.thread,W=de.Qa[D],delete de.Qa[D],Tt(W),cn(D),de.Za.splice(de.Za.indexOf(W),1),W.Xa=0):W==="cancelThread"?de.Qa[D.thread].postMessage({cmd:"cancel"}):W==="loaded"?(i.loaded=!0,I&&!i.Xa&&i.unref(),c(i)):W==="alert"?alert(`Thread ${D.threadId}: ${D.text}`):D.target==="setimmediate"?i.postMessage(D):W==="callHandler"?a[D.handler](...D.args):W&&K(`worker sent an unknown command ${W}`)},i.onerror=D=>{throw K(`worker sent an error! ${D.filename}:${D.lineno}: ${D.message}`),D},I&&(i.on("message",D=>i.onmessage({data:D})),i.on("error",D=>i.onerror(D)));var f=[],S=["onExit"],O;for(O of S)a.hasOwnProperty(O)&&f.push(O);i.postMessage({cmd:"load",handlers:f,urlOrBlob:a.mainScriptUrlOrBlob||e,wasmMemory:Q,wasmModule:Z})})};a.PThread=de;var bt=i=>{for(;0<i.length;)i.shift()(a)};a.establishStackSpace=()=>{var i=Pr(),c=s()[i+52>>>2>>>0];i=s()[i+56>>>2>>>0],ho(c,c-i),kr(c)};function Zt(i){if($)return Oe(1,0,i);Nt(i)}a.invokeEntryPoint=(i,c)=>{i=go.apply(null,[i,c]),0<nt?de.nb(i):pn(i)};function vr(i){this.gb=i-24,this.sb=function(c){s()[this.gb+4>>>2>>>0]=c},this.rb=function(c){s()[this.gb+8>>>2>>>0]=c},this.hb=function(c,f){this.qb(),this.sb(c),this.rb(f)},this.qb=function(){s()[this.gb+16>>>2>>>0]=0}}var $r=0,Qt=0;function Sr(i,c,f,S){return $?Oe(2,1,i,c,f,S):xr(i,c,f,S)}function xr(i,c,f,S){if(i>>>=0,c>>>=0,f>>>=0,S>>>=0,typeof SharedArrayBuffer>"u")return K("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var O=[];return $&&O.length===0?Sr(i,c,f,S):(i={Db:f,Xa:i,tb:S,Jb:O},$?(i.Lb="spawnThread",postMessage(i,O),0):Kt(i))}function _r(i,c,f){return $?Oe(3,1,i,c,f):0}function Cr(i,c){if($)return Oe(4,1,i,c)}var Xt=i=>{for(var c=0,f=0;f<i.length;++f){var S=i.charCodeAt(f);127>=S?c++:2047>=S?c+=2:55296<=S&&57343>=S?(c+=4,++f):c+=3}return c},Ir=(i,c,f,S)=>{if(f>>>=0,!(0<S))return 0;var O=f;S=f+S-1;for(var D=0;D<i.length;++D){var W=i.charCodeAt(D);if(55296<=W&&57343>=W){var ie=i.charCodeAt(++D);W=65536+((W&1023)<<10)|ie&1023}if(127>=W){if(f>=S)break;c[f++>>>0]=W}else{if(2047>=W){if(f+1>=S)break;c[f++>>>0]=192|W>>6}else{if(65535>=W){if(f+2>=S)break;c[f++>>>0]=224|W>>12}else{if(f+3>=S)break;c[f++>>>0]=240|W>>18,c[f++>>>0]=128|W>>12&63}c[f++>>>0]=128|W>>6&63}c[f++>>>0]=128|W&63}}return c[f>>>0]=0,f-O},ae=(i,c,f)=>Ir(i,o(),c,f);function Jt(i,c){if($)return Oe(5,1,i,c)}function Wt(i,c,f){if($)return Oe(6,1,i,c,f)}function er(i,c,f){return $?Oe(7,1,i,c,f):0}function tr(i,c){if($)return Oe(8,1,i,c)}function rr(i,c,f){if($)return Oe(9,1,i,c,f)}function nr(i,c,f,S){if($)return Oe(10,1,i,c,f,S)}function or(i,c,f,S){if($)return Oe(11,1,i,c,f,S)}function ar(i,c,f,S){if($)return Oe(12,1,i,c,f,S)}function ir(i){if($)return Oe(13,1,i)}function sr(i,c){if($)return Oe(14,1,i,c)}function ur(i,c,f){if($)return Oe(15,1,i,c,f)}var Ar=()=>{if(!(0<nt))try{$?pn(Pe):Nt(Pe)}catch(i){St(i)}};function xt(i){i>>>=0,typeof Atomics.Kb=="function"&&(Atomics.Kb(n(),i>>>2,i).value.then(Et),i+=128,Atomics.store(n(),i>>>2,1))}a.__emscripten_thread_mailbox_await=xt;var Et=()=>{var i=Pr();if(i&&(xt(i),!Ee))try{mo(),Ar()}catch(c){St(c)}};a.checkMailbox=Et;var d=[],m=i=>i%4===0&&(i%100!==0||i%400===0),v=[0,31,60,91,121,152,182,213,244,274,305,335],C=[0,31,59,90,120,151,181,212,243,273,304,334];function B(i,c,f,S,O,D,W,ie){return $?Oe(16,1,i,c,f,S,O,D,W,ie):-52}function H(i,c,f,S,O,D,W){if($)return Oe(17,1,i,c,f,S,O,D,W)}var q=i=>{var c=Xt(i)+1,f=ln(c);return f&&ae(i,f,c),f},le=[],J=(i,c)=>{le.length=0;for(var f;f=o()[i++>>>0];){var S=f!=105;S&=f!=112,c+=S&&c%8?4:0,le.push(f==112?s()[c>>>2>>>0]:f==105?n()[c>>>2>>>0]:l()[c>>>3>>>0]),c+=S?8:4}return le},re={},se=()=>{if(!we){var i={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:b||"./this.program"},c;for(c in re)re[c]===void 0?delete i[c]:i[c]=re[c];var f=[];for(c in i)f.push(`${c}=${i[c]}`);we=f}return we},we;function _e(i,c){if($)return Oe(18,1,i,c);i>>>=0,c>>>=0;var f=0;return se().forEach((S,O)=>{var D=c+f;for(O=s()[i+4*O>>>2>>>0]=D,D=0;D<S.length;++D)r()[O++>>>0>>>0]=S.charCodeAt(D);r()[O>>>0>>>0]=0,f+=S.length+1}),0}function P(i,c){if($)return Oe(19,1,i,c);i>>>=0,c>>>=0;var f=se();s()[i>>>2>>>0]=f.length;var S=0;return f.forEach(O=>S+=O.length+1),s()[c>>>2>>>0]=S,0}function ue(i){return $?Oe(20,1,i):52}function Se(i,c,f,S){return $?Oe(21,1,i,c,f,S):52}function st(i,c,f,S,O){return $?Oe(22,1,i,c,f,S,O):70}var Tr=[null,[],[]];function to(i,c,f,S){if($)return Oe(23,1,i,c,f,S);c>>>=0,f>>>=0,S>>>=0;for(var O=0,D=0;D<f;D++){var W=s()[c>>>2>>>0],ie=s()[c+4>>>2>>>0];c+=8;for(var ne=0;ne<ie;ne++){var oe=o()[W+ne>>>0],pe=Tr[i];oe===0||oe===10?((i===1?Y:K)(Vt(pe,0)),pe.length=0):pe.push(oe)}O+=ie}return s()[S>>>2>>>0]=O,0}var ro=[31,29,31,30,31,30,31,31,30,31,30,31],no=[31,28,31,30,31,30,31,31,30,31,30,31];function Pu(i){var c=Array(Xt(i)+1);return Ir(i,c,0,c.length),c}var ku=(i,c)=>{r().set(i,c>>>0)};function oo(i,c,f,S){function O(k,me,Ce){for(k=typeof k=="number"?k.toString():k||"";k.length<me;)k=Ce[0]+k;return k}function D(k,me){return O(k,me,"0")}function W(k,me){function Ce(So){return 0>So?-1:0<So?1:0}var Ot;return(Ot=Ce(k.getFullYear()-me.getFullYear()))===0&&(Ot=Ce(k.getMonth()-me.getMonth()))===0&&(Ot=Ce(k.getDate()-me.getDate())),Ot}function ie(k){switch(k.getDay()){case 0:return new Date(k.getFullYear()-1,11,29);case 1:return k;case 2:return new Date(k.getFullYear(),0,3);case 3:return new Date(k.getFullYear(),0,2);case 4:return new Date(k.getFullYear(),0,1);case 5:return new Date(k.getFullYear()-1,11,31);case 6:return new Date(k.getFullYear()-1,11,30)}}function ne(k){var me=k.$a;for(k=new Date(new Date(k.ab+1900,0,1).getTime());0<me;){var Ce=k.getMonth(),Ot=(m(k.getFullYear())?ro:no)[Ce];if(me>Ot-k.getDate())me-=Ot-k.getDate()+1,k.setDate(1),11>Ce?k.setMonth(Ce+1):(k.setMonth(0),k.setFullYear(k.getFullYear()+1));else{k.setDate(k.getDate()+me);break}}return Ce=new Date(k.getFullYear()+1,0,4),me=ie(new Date(k.getFullYear(),0,4)),Ce=ie(Ce),0>=W(me,k)?0>=W(Ce,k)?k.getFullYear()+1:k.getFullYear():k.getFullYear()-1}i>>>=0,c>>>=0,f>>>=0,S>>>=0;var oe=s()[S+40>>>2>>>0];S={Hb:n()[S>>>2>>>0],Gb:n()[S+4>>>2>>>0],eb:n()[S+8>>>2>>>0],jb:n()[S+12>>>2>>>0],fb:n()[S+16>>>2>>>0],ab:n()[S+20>>>2>>>0],Wa:n()[S+24>>>2>>>0],$a:n()[S+28>>>2>>>0],Ob:n()[S+32>>>2>>>0],Fb:n()[S+36>>>2>>>0],Ib:oe?Ye(oe):""},f=Ye(f),oe={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var pe in oe)f=f.replace(new RegExp(pe,"g"),oe[pe]);var xe="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Te="January February March April May June July August September October November December".split(" ");oe={"%a":k=>xe[k.Wa].substring(0,3),"%A":k=>xe[k.Wa],"%b":k=>Te[k.fb].substring(0,3),"%B":k=>Te[k.fb],"%C":k=>D((k.ab+1900)/100|0,2),"%d":k=>D(k.jb,2),"%e":k=>O(k.jb,2," "),"%g":k=>ne(k).toString().substring(2),"%G":k=>ne(k),"%H":k=>D(k.eb,2),"%I":k=>(k=k.eb,k==0?k=12:12<k&&(k-=12),D(k,2)),"%j":k=>{for(var me=0,Ce=0;Ce<=k.fb-1;me+=(m(k.ab+1900)?ro:no)[Ce++]);return D(k.jb+me,3)},"%m":k=>D(k.fb+1,2),"%M":k=>D(k.Gb,2),"%n":()=>`\n`,"%p":k=>0<=k.eb&&12>k.eb?"AM":"PM","%S":k=>D(k.Hb,2),"%t":()=>"	","%u":k=>k.Wa||7,"%U":k=>D(Math.floor((k.$a+7-k.Wa)/7),2),"%V":k=>{var me=Math.floor((k.$a+7-(k.Wa+6)%7)/7);if(2>=(k.Wa+371-k.$a-2)%7&&me++,me)me==53&&(Ce=(k.Wa+371-k.$a)%7,Ce==4||Ce==3&&m(k.ab)||(me=1));else{me=52;var Ce=(k.Wa+7-k.$a-1)%7;(Ce==4||Ce==5&&m(k.ab%400-1))&&me++}return D(me,2)},"%w":k=>k.Wa,"%W":k=>D(Math.floor((k.$a+7-(k.Wa+6)%7)/7),2),"%y":k=>(k.ab+1900).toString().substring(2),"%Y":k=>k.ab+1900,"%z":k=>{k=k.Fb;var me=0<=k;return k=Math.abs(k)/60,(me?"+":"-")+("0000"+(k/60*100+k%60)).slice(-4)},"%Z":k=>k.Ib,"%%":()=>"%"},f=f.replace(/%%/g,"\\0\\0");for(pe in oe)f.includes(pe)&&(f=f.replace(new RegExp(pe,"g"),oe[pe](S)));return f=f.replace(/\\0\\0/g,"%"),pe=Pu(f),pe.length>c?0:(ku(pe,i),pe.length-1)}var Er=i=>{try{i()}catch(c){rt(c)}};function Ru(){var i=X,c={};for(let[f,S]of Object.entries(i))c[f]=typeof S=="function"?function(){Or.push(f);try{return S.apply(null,arguments)}finally{Ee||(Or.pop(),ut&&_t===1&&Or.length===0&&(_t=0,nt+=1,Er(bo),typeof Fibers<"u"&&Fibers.Pb()))}}:S;return c}var _t=0,ut=null,ao=0,Or=[],io={},so={},Bu=0,dn=null,Du=[];function Mu(){return new Promise((i,c)=>{dn={resolve:i,reject:c}})}function zu(){var i=ln(65548),c=i+12;s()[i>>>2>>>0]=c,s()[i+4>>>2>>>0]=c+65536,c=Or[0];var f=io[c];return f===void 0&&(f=Bu++,io[c]=f,so[f]=c),c=f,n()[i+8>>>2>>>0]=c,i}function Uu(){var i=n()[ut+8>>>2>>>0];return i=X[so[i]],--nt,i()}function Vu(i){if(!Ee){if(_t===0){var c=!1,f=!1;i((S=0)=>{if(!Ee&&(ao=S,c=!0,f)){_t=2,Er(()=>wo(ut)),typeof Browser<"u"&&Browser.ib.vb&&Browser.ib.resume(),S=!1;try{var O=Uu()}catch(ie){O=ie,S=!0}var D=!1;if(!ut){var W=dn;W&&(dn=null,(S?W.reject:W.resolve)(O),D=!0)}if(S&&!D)throw O}}),f=!0,c||(_t=1,ut=zu(),typeof Browser<"u"&&Browser.ib.vb&&Browser.ib.pause(),Er(()=>yo(ut)))}else _t===2?(_t=0,Er(vo),lo(ut),ut=null,Du.forEach(S=>{if(!Ee)try{S(),Ar()}catch(O){St(O)}})):rt(`invalid state: ${_t}`);return ao}}function Nu(i){return Vu(c=>{i().then(c)})}de.hb();var Wu=[wr,Zt,Sr,_r,Cr,Jt,Wt,er,tr,rr,nr,or,ar,ir,sr,ur,B,H,_e,P,ue,Se,st,to],Hu={r:function(i,c,f){return Nu(async()=>{await a.xb(i,c,f)})},b:function(i,c,f){throw i>>>=0,new vr(i).hb(c>>>0,f>>>0),$r=i,Qt++,$r},N:function(i){co(i>>>0,!_,1,!y,131072,!1),de.ob()},l:function(i){i>>>=0,$?postMessage({cmd:"cleanupThread",thread:i}):de.mb(de.Qa[i])},J:xr,i:_r,T:Cr,F:Jt,H:Wt,U:er,R:tr,L:rr,Q:nr,p:or,G:ar,D:ir,S:sr,E:ur,q:()=>1,B:function(i,c){i>>>=0,i==c>>>0?setTimeout(()=>Et()):$?postMessage({targetThread:i,cmd:"checkMailbox"}):(i=de.Qa[i])&&i.postMessage({cmd:"checkMailbox"})},K:function(i,c,f,S){c>>>=0,d.length=f,S=S>>>0>>>3;for(var O=0;O<f;O++)d[O]=l()[S+O>>>0];return i=0>i?zt[-i-1]:Wu[i],de.ub=c,c=i.apply(null,d),de.ub=0,c},M:xt,W:function(i){I&&de.Qa[i>>>0].ref()},u:function(i,c,f){i=c+2097152>>>0<4194305-!!i?(i>>>0)+4294967296*c:NaN,f>>>=0,i=new Date(1e3*i),n()[f>>>2>>>0]=i.getUTCSeconds(),n()[f+4>>>2>>>0]=i.getUTCMinutes(),n()[f+8>>>2>>>0]=i.getUTCHours(),n()[f+12>>>2>>>0]=i.getUTCDate(),n()[f+16>>>2>>>0]=i.getUTCMonth(),n()[f+20>>>2>>>0]=i.getUTCFullYear()-1900,n()[f+24>>>2>>>0]=i.getUTCDay(),i=(i.getTime()-Date.UTC(i.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,n()[f+28>>>2>>>0]=i},v:function(i,c,f){i=c+2097152>>>0<4194305-!!i?(i>>>0)+4294967296*c:NaN,f>>>=0,i=new Date(1e3*i),n()[f>>>2>>>0]=i.getSeconds(),n()[f+4>>>2>>>0]=i.getMinutes(),n()[f+8>>>2>>>0]=i.getHours(),n()[f+12>>>2>>>0]=i.getDate(),n()[f+16>>>2>>>0]=i.getMonth(),n()[f+20>>>2>>>0]=i.getFullYear()-1900,n()[f+24>>>2>>>0]=i.getDay(),c=(m(i.getFullYear())?v:C)[i.getMonth()]+i.getDate()-1|0,n()[f+28>>>2>>>0]=c,n()[f+36>>>2>>>0]=-(60*i.getTimezoneOffset()),c=new Date(i.getFullYear(),6,1).getTimezoneOffset();var S=new Date(i.getFullYear(),0,1).getTimezoneOffset();i=(c!=S&&i.getTimezoneOffset()==Math.min(S,c))|0,n()[f+32>>>2>>>0]=i},w:function(i){i>>>=0;var c=new Date(n()[i+20>>>2>>>0]+1900,n()[i+16>>>2>>>0],n()[i+12>>>2>>>0],n()[i+8>>>2>>>0],n()[i+4>>>2>>>0],n()[i>>>2>>>0],0),f=n()[i+32>>>2>>>0],S=c.getTimezoneOffset(),O=new Date(c.getFullYear(),6,1).getTimezoneOffset(),D=new Date(c.getFullYear(),0,1).getTimezoneOffset(),W=Math.min(D,O);return 0>f?n()[i+32>>>2>>>0]=+(O!=D&&W==S):0<f!=(W==S)&&(O=Math.max(D,O),c.setTime(c.getTime()+6e4*((0<f?W:O)-S))),n()[i+24>>>2>>>0]=c.getDay(),f=(m(c.getFullYear())?v:C)[c.getMonth()]+c.getDate()-1|0,n()[i+28>>>2>>>0]=f,n()[i>>>2>>>0]=c.getSeconds(),n()[i+4>>>2>>>0]=c.getMinutes(),n()[i+8>>>2>>>0]=c.getHours(),n()[i+12>>>2>>>0]=c.getDate(),n()[i+16>>>2>>>0]=c.getMonth(),n()[i+20>>>2>>>0]=c.getYear(),i=c.getTime(),isNaN(i)?(n()[uo()>>>2>>>0]=61,i=-1):i/=1e3,fo((yt=i,1<=+Math.abs(yt)?0<yt?+Math.floor(yt/4294967296)>>>0:~~+Math.ceil((yt-+(~~yt>>>0))/4294967296)>>>0:0)),i>>>0},s:B,t:H,A:function(i,c,f){function S(oe){return(oe=oe.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?oe[1]:"GMT"}i>>>=0,c>>>=0,f>>>=0;var O=new Date().getFullYear(),D=new Date(O,0,1),W=new Date(O,6,1);O=D.getTimezoneOffset();var ie=W.getTimezoneOffset(),ne=Math.max(O,ie);s()[i>>>2>>>0]=60*ne,n()[c>>>2>>>0]=+(O!=ie),i=S(D),c=S(W),i=q(i),c=q(c),ie<O?(s()[f>>>2>>>0]=i,s()[f+4>>>2>>>0]=c):(s()[f>>>2>>>0]=c,s()[f+4>>>2>>>0]=i)},d:()=>{rt("")},c:function(i,c,f){return i>>>=0,c=J(c>>>0,f>>>0),zt[i].apply(null,c)},k:function(i,c,f){return i>>>=0,c=J(c>>>0,f>>>0),zt[i].apply(null,c)},m:()=>{},j:()=>Date.now(),V:()=>{throw nt+=1,"unwind"},C:function(){return 4294901760},f:()=>performance.timeOrigin+performance.now(),g:()=>I?(Oo(),Ht(Eo)).cpus().length:navigator.hardwareConcurrency,y:function(i){i>>>=0;var c=o().length;if(i<=c||4294901760<i)return!1;for(var f=1;4>=f;f*=2){var S=c*(1+.2/f);S=Math.min(S,i+100663296);var O=Math;S=Math.max(i,S);e:{O=(O.min.call(O,4294901760,S+(65536-S%65536)%65536)-Q.buffer.byteLength+65535)/65536;try{Q.grow(O),Ge();var D=1;break e}catch{}D=void 0}if(D)return!0}return!1},O:_e,P,I:Nt,h:ue,o:Se,x:st,n:to,a:Q||a.wasmMemory,z:oo,e:function(i,c,f,S){return oo(i>>>0,c>>>0,f>>>0,S>>>0)}},X=function(){function i(f,S){return X=f.exports,X=Ru(),X=Gu(),de.pb.push(X.Da),be.unshift(X.X),Z=S,wt(),X}var c={a:Hu};if(ze++,a.instantiateWasm)try{return a.instantiateWasm(c,i)}catch(f){K(`Module.instantiateWasm callback failed with error: ${f}`),h(f)}return $t(c,function(f){i(f.instance,f.module)}).catch(h),{}}();a._OrtInit=(i,c)=>(a._OrtInit=X.Y)(i,c),a._OrtGetLastError=(i,c)=>(a._OrtGetLastError=X.Z)(i,c),a._OrtCreateSessionOptions=(i,c,f,S,O,D,W,ie,ne,oe)=>(a._OrtCreateSessionOptions=X._)(i,c,f,S,O,D,W,ie,ne,oe),a._OrtAppendExecutionProvider=(i,c)=>(a._OrtAppendExecutionProvider=X.$)(i,c),a._OrtAddFreeDimensionOverride=(i,c,f)=>(a._OrtAddFreeDimensionOverride=X.aa)(i,c,f),a._OrtAddSessionConfigEntry=(i,c,f)=>(a._OrtAddSessionConfigEntry=X.ba)(i,c,f),a._OrtReleaseSessionOptions=i=>(a._OrtReleaseSessionOptions=X.ca)(i),a._OrtCreateSession=(i,c,f)=>(a._OrtCreateSession=X.da)(i,c,f),a._OrtReleaseSession=i=>(a._OrtReleaseSession=X.ea)(i),a._OrtGetInputOutputCount=(i,c,f)=>(a._OrtGetInputOutputCount=X.fa)(i,c,f),a._OrtGetInputName=(i,c)=>(a._OrtGetInputName=X.ga)(i,c),a._OrtGetOutputName=(i,c)=>(a._OrtGetOutputName=X.ha)(i,c),a._OrtFree=i=>(a._OrtFree=X.ia)(i),a._OrtCreateTensor=(i,c,f,S,O,D)=>(a._OrtCreateTensor=X.ja)(i,c,f,S,O,D),a._OrtGetTensorData=(i,c,f,S,O)=>(a._OrtGetTensorData=X.ka)(i,c,f,S,O),a._OrtReleaseTensor=i=>(a._OrtReleaseTensor=X.la)(i),a._OrtCreateRunOptions=(i,c,f,S)=>(a._OrtCreateRunOptions=X.ma)(i,c,f,S),a._OrtAddRunConfigEntry=(i,c,f)=>(a._OrtAddRunConfigEntry=X.na)(i,c,f),a._OrtReleaseRunOptions=i=>(a._OrtReleaseRunOptions=X.oa)(i),a._OrtCreateBinding=i=>(a._OrtCreateBinding=X.pa)(i),a._OrtBindInput=(i,c,f)=>(a._OrtBindInput=X.qa)(i,c,f),a._OrtBindOutput=(i,c,f,S)=>(a._OrtBindOutput=X.ra)(i,c,f,S),a._OrtClearBoundOutputs=i=>(a._OrtClearBoundOutputs=X.sa)(i),a._OrtReleaseBinding=i=>(a._OrtReleaseBinding=X.ta)(i),a._OrtRunWithBinding=(i,c,f,S,O)=>(a._OrtRunWithBinding=X.ua)(i,c,f,S,O),a._OrtRun=(i,c,f,S,O,D,W,ie)=>(a._OrtRun=X.va)(i,c,f,S,O,D,W,ie),a._OrtEndProfiling=i=>(a._OrtEndProfiling=X.wa)(i),a._JsepOutput=(i,c,f)=>(a._JsepOutput=X.xa)(i,c,f),a._JsepGetNodeName=i=>(a._JsepGetNodeName=X.ya)(i);var uo=()=>(uo=X.za)(),Pr=a._pthread_self=()=>(Pr=a._pthread_self=X.Aa)(),ln=a._malloc=i=>(ln=a._malloc=X.Ba)(i),lo=a._free=i=>(lo=a._free=X.Ca)(i);a.__emscripten_tls_init=()=>(a.__emscripten_tls_init=X.Da)();var co=a.__emscripten_thread_init=(i,c,f,S,O,D)=>(co=a.__emscripten_thread_init=X.Fa)(i,c,f,S,O,D);a.__emscripten_thread_crashed=()=>(a.__emscripten_thread_crashed=X.Ga)();var po=(i,c,f,S)=>(po=X.Ha)(i,c,f,S),cn=i=>(cn=X.Ia)(i),pn=a.__emscripten_thread_exit=i=>(pn=a.__emscripten_thread_exit=X.Ja)(i),mo=()=>(mo=X.Ka)(),fo=i=>(fo=X.La)(i),ho=(i,c)=>(ho=X.Ma)(i,c),mn=()=>(mn=X.Na)(),kr=i=>(kr=X.Oa)(i),fn=i=>(fn=X.Pa)(i),go=a.dynCall_ii=(i,c)=>(go=a.dynCall_ii=X.Ra)(i,c),yo=i=>(yo=X.Sa)(i),bo=()=>(bo=X.Ta)(),wo=i=>(wo=X.Ua)(i),vo=()=>(vo=X.Va)();a.___start_em_js=944472,a.___stop_em_js=944633;function Gu(){var i=X;i=Object.assign({},i);var c=S=>()=>S()>>>0,f=S=>O=>S(O)>>>0;return i.za=c(i.za),i.Aa=c(i.Aa),i.Ba=f(i.Ba),i.emscripten_main_runtime_thread_id=c(i.emscripten_main_runtime_thread_id),i.Na=c(i.Na),i.Pa=f(i.Pa),i}a.wasmMemory=Q,a.stackAlloc=fn,a.stackSave=mn,a.stackRestore=kr,a.keepRuntimeAlive=()=>0<nt,a.UTF8ToString=Ye,a.stringToUTF8=ae,a.lengthBytesUTF8=Xt,a.ExitStatus=Ut,a.PThread=de;var Rr;Me=function i(){Rr||$o(),Rr||(Me=i)};function $o(){if(!(0<ze))if($)p(a),$||bt(be),startWorker(a);else{if(a.preRun)for(typeof a.preRun=="function"&&(a.preRun=[a.preRun]);a.preRun.length;)ee.unshift(a.preRun.shift());bt(ee),0<ze||Rr||(Rr=!0,a.calledRun=!0,Ee||($||bt(be),p(a),$||bt(et)))}}return $o(),t.ready}})();typeof ko=="object"&&typeof $n=="object"?$n.exports=Po:typeof define=="function"&&define.amd&&define([],()=>Po)});var Bo=dr((qc,Xu)=>{Xu.exports=\'"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs"),vm=require("vm");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>vm.runInThisContext(fs.readFileSync(e,"utf8"),{filename:e}),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(){var e=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,e+`\\n`);return}console.error(e)}function threadAlert(){var e=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:e,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,t)=>{var a=Module.wasmModule;Module.wasmModule=null;var r=new WebAssembly.Instance(a,e);return t(r)},self.onunhandledrejection=e=>{throw e.reason||e};function handleMessage(e){try{if(e.data.cmd==="load"){let a=[];self.onmessage=r=>a.push(r),self.startWorker=r=>{Module=r,postMessage({cmd:"loaded"});for(let s of a)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const r of e.data.handlers)Module[r]=(...s)=>{postMessage({cmd:"callHandler",handler:r,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var t=URL.createObjectURL(e.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(a){if(a!="unwind")throw a}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err(`worker.js received unknown command ${e.data.cmd}`),err(e.data)))}catch(a){throw Module.__emscripten_thread_crashed?.(),a}}self.onmessage=handleMessage;\\n\'});var _n,Xe,cr,Mr,pr,No,Cn,Ne=j(()=>{"use strict";_n=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},Xe=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},cr=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],Mr=e=>{switch(e){case"float16":return Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},pr=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},No=e=>e==="float32"||e==="int32"||e==="int64"||e==="bool"||e==="float16"||e==="uint32",Cn=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${e}`)}}});var zr=j(()=>{"use strict"});var Ho=j(()=>{"use strict";zr()});var Go,Lo=j(()=>{"use strict";Go="1.17.1"});var Fo,Pt,In=j(()=>{"use strict";Lo();Fo="warning",Pt={wasm:{},webgl:{},webgpu:{},versions:{common:Go},set logLevel(e){if(e!==void 0){if(typeof e!="string"||["verbose","info","warning","error","fatal"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);Fo=e}},get logLevel(){return Fo}};Object.defineProperty(Pt,"logLevel",{enumerable:!0})});var Gt,jo=j(()=>{"use strict";In();Gt=Pt});var qo=j(()=>{"use strict"});var Ko=j(()=>{"use strict";Ur()});var Zo=j(()=>{"use strict"});var Qo=j(()=>{"use strict";Ur()});var Ur=j(()=>{"use strict";qo();Ko();Zo();Qo()});var Vr=j(()=>{"use strict";Ur()});var An,Xo,kt,Rt,Tn=j(()=>{"use strict";In();An=(e,t)=>{Pt.wasm.trace&&console.timeStamp(`${e}::ORT::${t}`)},Xo=(e,t)=>{let r=new Error().stack?.split(/\\r\\n|\\r|\\n/g)||[],o=!1;for(let n=0;n<r.length;n++){if(o&&!r[n].includes("TRACE_FUNC")){let s=`FUNC_${e}::${r[n].trim().split(" ")[1]}`;t&&(s+=`::${t}`),An("CPU",s);return}r[n].includes("TRACE_FUNC")&&(o=!0)}},kt=e=>{Pt.wasm.trace&&Xo("BEGIN",e)},Rt=e=>{Pt.wasm.trace&&Xo("END",e)}});var Jo=j(()=>{"use strict";zr();Vr();Tn()});var ea=j(()=>{"use strict";Jo()});var ta=j(()=>{"use strict"});var ra=j(()=>{"use strict";zr();Vr()});var na=j(()=>{"use strict";ra()});var Lt=j(()=>{"use strict";Ho();jo();ea();Vr();Tn();ta();na()});var dd,ld,oa,aa,ia,cd,Be,Ct=j(()=>{"use strict";Ne();dd=["V","I","W","E","F"],ld=(e,t)=>{console.log(`[${dd[e]},${new Date().toISOString()}]${t}`)},ia=(e,t)=>{oa=e,aa=t},cd=(e,t)=>{let r=pr(e),o=pr(oa);r>=o&&ld(r,typeof t=="function"?t():t)},Be=(...e)=>{aa&&cd(...e)}});var sa,ua=j(()=>{"use strict";Ne();sa=(e,t)=>new(Mr(t))(e)});var Nr=j(()=>{"use strict"});var Wr,pd,da,On,En,ca,pa=j(()=>{"use strict";Ct();Nr();Wr=e=>Math.ceil(e/16)*16,pd=1,da=()=>pd++,On=async(e,t,r,o)=>{let n=Wr(r),s=e.device.createBuffer({size:n,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let u=e.getCommandEncoder();e.endComputePass(),u.copyBufferToBuffer(t,0,s,0,n),e.flush(),await s.mapAsync(GPUMapMode.READ);let l=s.getMappedRange();if(o){let a=o();return a.set(new Uint8Array(l,0,r)),a}else return new Uint8Array(l.slice(0,r))}finally{s.destroy()}},En=class{constructor(t){this.backend=t;this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.externalBuffers=new Map}upload(t,r){let o=r.buffer,n=r.byteOffset,s=r.byteLength,u=Wr(s),l=this.storageCache.get(t);if(!l)throw new Error("gpu data for uploading does not exist");if(l.originalSize!==s)throw new Error(`inconsistent data size. gpu data size=${l.originalSize}, data size=${s}`);let a=this.backend.device.createBuffer({mappedAtCreation:!0,size:u,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),p=a.getMappedRange();new Uint8Array(p).set(new Uint8Array(o,n,s)),a.unmap();let h=this.backend.getCommandEncoder();this.backend.endComputePass(),h.copyBufferToBuffer(a,0,l.gpuData.buffer,0,u),Be("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${t})`),this.buffersForUploadingPending.push(a)}memcpy(t,r){let o=this.storageCache.get(t);if(!o)throw new Error("source gpu data for memcpy does not exist");let n=this.storageCache.get(r);if(!n)throw new Error("destination gpu data for memcpy does not exist");if(o.originalSize!==n.originalSize)throw new Error("inconsistent source and destination gpu data size");let s=Wr(o.originalSize),u=this.backend.getCommandEncoder();this.backend.endComputePass(),u.copyBufferToBuffer(o.gpuData.buffer,0,n.gpuData.buffer,0,s)}registerExternalBuffer(t,r,o){let n;if(o){if(n=this.externalBuffers.get(o),n===void 0)throw new Error("previous buffer is not registered");if(t===o)return Be("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${n}, buffer is the same, skip.`),n;this.externalBuffers.delete(o)}else n=da();return this.storageCache.set(n,{gpuData:{id:n,type:0,buffer:t},originalSize:r}),this.externalBuffers.set(t,n),Be("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${n}, registered.`),n}unregisterExternalBuffer(t){let r=this.externalBuffers.get(t);r!==void 0&&(this.storageCache.delete(r),this.externalBuffers.delete(t),Be("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${r}`))}create(t,r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let o=Wr(t),n,s=(r&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,u=(r&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(s||u){let a=s?this.freeBuffers:this.freeUniformBuffers,p=a.get(o);p||(p=[],a.set(o,p)),p.length>0?n=p.pop():n=this.backend.device.createBuffer({size:o,usage:r})}else n=this.backend.device.createBuffer({size:o,usage:r});let l={id:da(),type:0,buffer:n};return this.storageCache.set(l.id,{gpuData:l,originalSize:t}),Be("verbose",()=>`[WebGPU] GpuDataManager.create(size=${t}) => id=${l.id}`),l}get(t){return this.storageCache.get(t)?.gpuData}release(t){let r=this.storageCache.get(t);if(!r)throw new Error("releasing data does not exist");return Be("verbose",()=>`[WebGPU] GpuDataManager.release(id=${t}), gpuDataId=${r.gpuData.id}`),this.storageCache.delete(t),this.buffersPending.push(r.gpuData.buffer),r.originalSize}async download(t,r){let o=this.storageCache.get(t);if(!o)throw new Error("data does not exist");await On(this.backend,o.gpuData.buffer,o.originalSize,r)}refreshPendingBuffers(){for(let t of this.buffersForUploadingPending)t.destroy();this.buffersForUploadingPending=[];for(let t of this.buffersPending)(t.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE?this.freeBuffers.get(t.size).push(t):(t.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM?this.freeUniformBuffers.get(t.size).push(t):t.destroy();this.buffersPending=[]}dispose(){this.freeBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.freeUniformBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.storageCache.forEach(t=>{t.gpuData.buffer.destroy()}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map}},ca=(...e)=>new En(...e)});var Pn,ge,je=j(()=>{"use strict";Pn=class{constructor(t){Object.assign(this,t)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(t=>`${this[t]}`).join(";")),this.key}},ge=e=>new Pn(e)});var kn,dt,U,Bt,Hr,Gr,Lr,$e=j(()=>{"use strict";kn=class{static calcMatMulShape(t,r){return t[1]!==r[0]?void 0:[t[0],r[1]]}},dt=class{static calcShape(t,r,o=!1){let n=t.length,s=r.length;if(n===0)return r;if(s===0)return t;let u=Math.max(t.length,r.length),l=new Array(u);if(o){if(n<2||s<2)return;let a=kn.calcMatMulShape([t[n-2],t[n-1]],[r[s-2],r[s-1]]);if(a===void 0)return;[l[u-2],l[u-1]]=a}for(let a=o?3:1;a<=u;a++){let p=n-a<0?1:t[n-a],h=s-a<0?1:r[s-a];if(p!==h&&p>1&&h>1)return;l[u-a]=Math.max(p,h)}return l}static isValidBroadcast(t,r){let o=t.length,n=r.length;if(o>n)return!1;for(let s=1;s<=o;s++)if(t[o-s]!==1&&t[o-s]!==r[n-s])return!1;return!0}},U=class e{static size(t){return e.getSizeFromDimensionRange(t,0,t.length)}static sizeFromDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,r,t.length)}static sizeToDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeToDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,0,r)}static getSizeFromDimensionRange(t,r,o){let n=1;for(let s=r;s<o;s++){if(t[s]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");n*=t[s]}return n}static computeStrides(t){let r=t.length;if(r===0)return[];if(r===1)return[1];let o=new Array(r);o[r-1]=1,o[r-2]=t[r-1];for(let n=r-3;n>=0;--n)o[n]=o[n+1]*t[n+1];return o}static normalizeAxis(t,r){if(t<-r&&t>=r)throw new Error("unsupported axis for this operation.");return t<0?t+r:t}static normalizeAxes(t,r){return t.map(o=>this.normalizeAxis(o,r??t.length))}static sortBasedOnPerm(t,r){return r?r.map(o=>t[o]):t.slice().reverse()}static padShape(t,r){let o=t.length;return t.map((n,s)=>n+r[s]+r[s+o])}static areEqual(t,r){return t.length!==r.length?!1:t.every((o,n)=>o===r[n])}},Bt=class e{static adjustPoolAttributes(t,r,o,n,s,u){if(!t&&o.length!==r.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(t)for(let l=0;l<r.length-2;l++)l>=o.length?o.push(r[l+2]):o[l]=r[l+2];for(let l=0;l<o.length;l++)if(l<n.length){if(n[l]<0)throw new Error("strides should be greater than or equal to 1")}else n.push(1);for(let l=0;l<o.length;l++)if(l<s.length){if(s[l]<0)throw new Error("dilations should be greater than or equal to 1")}else s.push(1);for(let l=0;l<o.length*2;l++)if(l<u.length){if(u[l]<0)throw new Error("pad should be greater than or equal to 1")}else u.push(0);for(let l=0;l<o.length;l++){if(o[l]<=0)throw new Error("kernel shapes need to be greater than 0");if(u[l]>=o[l]||u[l+o.length]>=o[l])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(t,r,o,n,s,u,l){if(l){if(s.length!==2*(t.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(r.length!==t.length-2)throw new Error("length of strides should be the length of data dimensions");if(n.length!==t.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let a=0;a<t.length-2;a++)e.adjustPadAndReturnShape(t[a+(u?1:2)],r[a],o[a],n[a],s,a,a+t.length-2,l)}}static computePoolOutputShape(t,r,o,n,s,u,l){if(r.length<=0)throw new Error("input shape must be of size greater than 0");let a=[r[0],r[1]];return e.computeShapeHelper(t,r,a,o,n,s,u,l),a}static computeConvOutputShape(t,r,o,n,s,u,l){if(t.length<=0||r.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let a=[t[0],r[0]];return e.computeShapeHelper(!1,t,a,o,n,s,u,l),a}static computeShapeHelper(t,r,o,n,s,u,l,a){if(t)for(let p=0;p<r.length-2;p++)o.push(1);else for(let p=0;p<r.length-2;p++)o.push(e.adjustPadAndReturnShape(r[p+2],n[p],s[p],u[p],l,p,p+r.length-2,a))}static adjustPadAndReturnShape(t,r,o,n,s,u,l,a){let p=o*(n-1)+1;if(a&&a!=="NOTSET")switch(a){case"VALID":return s[u]=0,s[l]=0,Math.floor((t-p)/r+1);case"SAME_LOWER":case"SAME_UPPER":if(o!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let g=((t+r-1)/r-1)*r+n-t;return s[u]=Math.floor(a==="SAME_LOWER"?(g+1)/2:g/2),s[l]=g-s[u],Math.floor((t+g-n)/r+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((t+s[u]+s[l]-p)/r+1)}},Hr=class{static getShapeOfGemmResult(t,r,o,n,s){if(t.length!==2||o.length!==2)throw new Error("shape need to be of size 2");let u,l,a;r?(u=t[1],l=t[0]):(u=t[0],l=t[1]);let p=-1;if(n?(a=o[0],p=1):(a=o[1],p=0),o[p]!==l)throw new Error("dimension mismatch");if(u<=0||a<=0||l<=0)throw new Error("invalid shape specified");if(s&&!dt.isValidBroadcast(s,[u,a]))throw new Error("gemm: invalid bias shape for broadcast");return[u,a,l]}},Gr=-34028234663852886e22,Lr=34028234663852886e22});var md,Bn,Le,lt,L,Fe,Ze,at,Je,ce,Dn,M,F,Fr,Rn,ma,Ft,Re,ve=j(()=>{"use strict";Ne();$e();md=64,Bn=(e,t)=>{if(t===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(e){case 10:return t>1?`vec${t}<f16>`:"f16";case 1:return t>1?`vec${t}<f32>`:"f32";case 6:return t>1?`vec${t}<i32>`:"i32";case 12:return t>1?`vec${t}<u32>`:"u32";case 7:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(t!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];default:throw new Error(`Unknown data type: ${e}`)}},Le=(e,t=1)=>{let r=Bn(e,t);return typeof r=="string"?r:r[0]},lt=(e,t=1)=>{let r=Bn(e,t);return typeof r=="string"?r:r[1]},L=e=>e.length===0?[]:[{type:"uint32",data:e},{type:"uint32",data:U.computeStrides(e)}],Fe=e=>e%4===0?4:e%2===0?2:1,Ze=(e="f32",t,r="0")=>!t||t===1?`${e}(${r})`:`vec${t}<${e}>(${r})`,at=(e,t,r)=>e==="f32"?r:t===1?`f32(${r})`:`vec${t}f(${r})`,Je=(e,t)=>t===4?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:t===2?`(${e}.x + ${e}.y)`:t===3?`(${e}.x + ${e}.y + ${e}.z)`:e,ce=(e,t,r)=>e.startsWith("uniforms.")&&r>4?typeof t=="string"?`${e}[(${t}) / 4][(${t}) % 4]`:`${e}[${Math.floor(t/4)}][${t%4}]`:r>1?`${e}[${t}]`:e,Dn=(e,t,r,o,n)=>{let s=typeof r=="number",u=s?r:r.length,l=[...new Array(u).keys()],a=u<2?"u32":u<=4?`vec${u}<u32>`:`array<u32, ${u}>`,p=Bn(t,n),h=typeof p=="string"?p:p[1],g=typeof p=="string"?p:p[0],b={indices:a,value:h,storage:g,tensor:t},w=G=>typeof G=="string"?G:`${G}u`,y={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},_=s?"uniforms.":"",I=`${_}${e}_shape`,$=`${_}${e}_strides`,x="";for(let G=0;G<u-1;G++)x+=`\n    let dim${G} = current / ${ce($,G,u)};\n    let rest${G} = current % ${ce($,G,u)};\n    indices[${G}] = dim${G};\n    current = rest${G};\n    `;x+=`indices[${u-1}] = current;`;let E=u<2?"":`\n  fn o2i_${e}(offset: u32) -> ${b.indices} {\n    var indices: ${b.indices};\n    var current = offset;\n    ${x}\n    return indices;\n  }`,A=G=>(y.offsetToIndices=!0,u<2?G:`o2i_${e}(${G})`),z=[];if(u>=2)for(let G=u-1;G>=0;G--)z.push(`${ce($,G,u)} * (indices[${G}])`);let R=u<2?"":`\n  fn i2o_${e}(indices: ${b.indices}) -> u32 {\n    return ${z.join("+")};\n  }`,V=G=>(y.indicesToOffset=!0,u<2?G:`i2o_${e}(${G})`),T=(...G)=>u===0?"0u":`${b.indices}(${G.map(w).join(",")})`,N=(G,ee)=>u<2?`${G}`:`${ce(G,ee,u)}`,te=(G,ee,be)=>u<2?`${G}=${be};`:`${ce(G,ee,u)}=${be};`,Y={},K=(G,ee)=>{y.broadcastedIndicesToOffset=!0;let be=`${ee.name}broadcastedIndicesTo${e}Offset`;if(be in Y)return`${be}(${G})`;let et=[];for(let ze=u-1;ze>=0;ze--){let Ue=ee.indicesGet("outputIndices",ze+ee.rank-u);et.push(`${N($,ze)} * (${Ue} % ${N(I,ze)})`)}return Y[be]=`fn ${be}(outputIndices: ${ee.type.indices}) -> u32 {\n             return ${et.length>0?et.join("+"):"0u"};\n           }`,`${be}(${G})`},Q=(G,ee)=>(()=>{if(b.storage===b.value)return`${e}[${G}]=${ee};`;if(b.storage==="vec2<u32>"&&b.value==="i32")return`${e}[${G}]=vec2<u32>(u32(${ee}), select(0u, 0xFFFFFFFFu, ${ee} < 0));`;if(b.storage==="vec2<u32>"&&b.value==="u32")return`${e}[${G}]=vec2<u32>(u32(${ee}), 0u);`;if(b.storage==="u32"&&b.value==="vec4<bool>")return`${e}[${G}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${ee}));`;throw new Error(`not supported combination of storage type ${b.storage} and value type ${b.value} yet`)})(),Z=G=>(()=>{if(b.storage===b.value)return`${e}[${G}]`;if(b.storage==="vec2<u32>"&&b.value==="i32")return`i32(${e}[${G}].x)`;if(b.storage==="vec2<u32>"&&b.value==="u32")return`u32(${e}[${G}].x)`;if(b.storage==="u32"&&b.value==="vec4<bool>")return`vec4<bool>(bool(${e}[${G}] & 0xFFu), bool(${e}[${G}] & 0xFF00u), bool(${e}[${G}] & 0xFF0000u), bool(${e}[${G}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${b.storage} and value type ${b.value} yet`)})(),Ee=u<2?"":`\n  fn get_${e}ByIndices(indices: ${b.indices}) -> ${h} {\n    return ${Z(`i2o_${e}(indices)`)};\n  }`,Pe=u<2?"":(()=>{let G=l.map(be=>`d${be}: u32`).join(", "),ee=l.map(be=>`d${be}`).join(", ");return`\n  fn get_${e}(${G}) -> ${h} {\n    return get_${e}ByIndices(${T(ee)});\n  }`})(),fe=(...G)=>{if(G.length!==u)throw new Error(`indices length must be ${u}`);let ee=G.map(w).join(",");return u===0?Z("0u"):u===1?Z(ee[0]):(y.get=!0,y.getByIndices=!0,y.indicesToOffset=!0,`get_${e}(${ee})`)},Ie=G=>u<2?Z(G):(y.getByIndices=!0,y.indicesToOffset=!0,`get_${e}ByIndices(${G})`),he=u<2?"":`\n  fn set_${e}ByIndices(indices: ${b.indices}, value: ${h}) {\n    ${Q(`i2o_${e}(indices)`,"value")}\n  }`,ye=u<2?"":(()=>{let G=l.map(be=>`d${be}: u32`).join(", "),ee=l.map(be=>`d${be}`).join(", ");return`\n  fn set_${e}(${G}, value: ${h}) {\n    set_${e}ByIndices(${T(ee)}, value);\n  }`})();return{impl:()=>{let G=[],ee=!1;return y.offsetToIndices&&(G.push(E),ee=!0),y.indicesToOffset&&(G.push(R),ee=!0),y.broadcastedIndicesToOffset&&(Object.values(Y).forEach(be=>G.push(be)),ee=!0),y.set&&(G.push(ye),ee=!0),y.setByIndices&&(G.push(he),ee=!0),y.get&&(G.push(Pe),ee=!0),y.getByIndices&&(G.push(Ee),ee=!0),!s&&ee&&G.unshift(`const ${I} = ${b.indices}(${r.join(",")});`,`const ${$} = ${b.indices}(${U.computeStrides(r).join(",")});`),G.join(`\n`)},type:b,offsetToIndices:A,indicesToOffset:V,broadcastedIndicesToOffset:K,indices:T,indicesGet:N,indicesSet:te,set:(...G)=>{if(G.length!==u+1)throw new Error(`indices length must be ${u}`);let ee=G[u];if(typeof ee!="string")throw new Error("value must be string");let be=G.slice(0,u).map(w).join(",");return u===0?Q("0u",ee):u===1?Q(be[0],ee):(y.set=!0,y.setByIndices=!0,y.indicesToOffset=!0,`set_${e}(${be}, ${ee})`)},setByOffset:Q,setByIndices:(G,ee)=>u<2?Q(G,ee):(y.setByIndices=!0,y.indicesToOffset=!0,`set_${e}ByIndices(${G}, ${ee});`),get:fe,getByOffset:Z,getByIndices:Ie,usage:o,name:e,strides:$,shape:I,rank:u}},M=(e,t,r,o=1)=>Dn(e,t,r,"input",o),F=(e,t,r,o=1)=>Dn(e,t,r,"output",o),Fr=(e,t,r,o=1)=>Dn(e,t,r,"internal",o),Rn=class{constructor(t){this.normalizedDispatchGroup=t;this.internalVariables=[];this.variables=[];this.uniforms=[];this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(t){return`if (global_idx >= ${typeof t=="number"?`${t}u`:t}) { return; }`}mainStart(t=md){let r=typeof t=="number"?t:t[0],o=typeof t=="number"?1:t[1],n=typeof t=="number"?1:t[2],s=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,u=s?`@builtin(global_invocation_id) global_id : vec3<u32>,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(local_invocation_id) local_id : vec3<u32>,\n    @builtin(local_invocation_index) local_idx : u32,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(num_workgroups) num_workgroups : vec3<u32>`,l=s?"let global_idx = global_id.x; let local_idx = local_id.x;":`let global_idx = (workgroup_id.z * num_workgroups[0] * num_workgroups[1] +\n          workgroup_id.y * num_workgroups[0] + workgroup_id.x) * ${r*o*n}u + local_idx;`;return`@compute @workgroup_size(${r}, ${o}, ${n})\n  fn main(${u}) {\n    ${l}\n  `}appendVariableUniforms(t){t.rank!==0&&(t.shape.startsWith("uniforms.")&&this.uniforms.push({name:t.shape.replace("uniforms.",""),type:"u32",length:t.rank}),t.strides.startsWith("uniforms.")&&this.uniforms.push({name:t.strides.replace("uniforms.",""),type:"u32",length:t.rank}))}declareVariable(t,r){if(t.usage==="internal")throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(t),this.appendVariableUniforms(t);let o=t.usage==="input"?"read":"read_write",n=t.type.storage;return`@group(0) @binding(${r}) var<storage, ${o}> ${t.name}: array<${n}>;`}declareVariables(...t){return t.map(r=>this.declareVariable(r,this.variableIndex++)).join(`\n`)}registerInternalVariable(t){if(t.usage!=="internal")throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(t),this.appendVariableUniforms(t)}registerInternalVariables(...t){return t.forEach(r=>this.registerInternalVariable(r)),this}registerUniform(t,r,o=1){return this.uniforms.push({name:t,type:r,length:o}),this}registerUniforms(t){return this.uniforms=this.uniforms.concat(t),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let t=[];for(let{name:r,type:o,length:n}of this.uniforms)if(n&&n>4)t.push(`${r}:array<vec4<${o}>, ${Math.ceil(n/4)}>`);else{let s=n==null||n===1?o:`vec${n}<${o}>`;t.push(`${r}:${s}`)}return`\n      struct Uniforms { ${t.join(", ")} };\n      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map(t=>t.impl()).join(`\n`)+this.internalVariables.map(t=>t.impl()).join(`\n`)}},ma=e=>new Rn(e),Ft=(e,t)=>{let r=e.length,o=[];for(let n=0;n<r;n++){let s=r-1-n,u=e[s]||1;(t[t.length-1-n]||1)>1&&u===1&&o.unshift(s)}return o},Re=e=>!0});var fd,fa,hd,gd,it,ha,ga,jt=j(()=>{"use strict";$e();je();ve();fd=e=>{if(!e||e.length!==1)throw new Error("Transpose requires 1 input.")},fa=(e,t)=>t&&t.length!==e?[...new Array(e).keys()].reverse():t,hd=(e,t)=>U.sortBasedOnPerm(e,fa(e.length,t)),gd=(e,t,r,o)=>{let n=[];n.push(`fn perm(i: ${o.type.indices}) -> ${r.type.indices} {\n    var a: ${r.type.indices};`);for(let s=0;s<t;++s)n.push(r.indicesSet("a",e[s],`i[${s}]`));return n.push("return a;}"),n.join(`\n`)},it=(e,t)=>{let r=e.dataType,o=e.dims.length,n=fa(o,t),s=Re(o),u=hd(e.dims,n),l=s?u.length:u,a=s?o:e.dims,p=F("output",r,l),h=M("a",r,a),g=b=>`\n  ${b.registerUniform("output_size","u32").declareVariables(h,p)}\n\n  ${gd(n,o,h,p)}\n\n  ${b.mainStart()}\n    ${b.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let indices = ${p.offsetToIndices("global_idx")};\n    let aIndices = perm(indices);\n\n    ${p.setByOffset("global_idx",h.getByIndices("aIndices"))}\n  }`;return{name:"Transpose",shaderCache:{hint:`${t}`,inputDependencies:s?["rank"]:["dims"]},getRunData:b=>{let w=U.size(u);return{outputs:[{dims:u,dataType:b[0].dataType}],dispatchGroup:{x:Math.ceil(w/64)},programUniforms:s?[{type:"uint32",data:w},...L(b[0].dims),...L(u)]:[{type:"uint32",data:w}]}},getShaderSource:g}},ha=(e,t)=>{fd(e.inputs),e.compute(it(e.inputs[0],t.perm))},ga=e=>ge({perm:e.perm})});var yd,bd,wd,vd,$d,Sd,xd,_d,Cd,Id,ct,ya,ba,wa,va,$a,Sa,xa,_a,Ca,Ia,Aa=j(()=>{"use strict";$e();ve();jr();jt();yd={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},bd={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},wd={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},vd={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},$d=(e,t)=>{let r=[];for(let o=t-e;o<t;++o)r.push(o);return r},Sd=(e,t)=>{let r=[],o=e.length;for(let s=0;s<o;s++)t.indexOf(s)===-1&&r.push(e[s]);let n=t.map(s=>e[s]);return[r,n]},xd=(e,t)=>{let r=e.length+t.length,o=[],n=0;for(let s=0;s<r;s++)t.indexOf(s)===-1?o.push(e[n++]):o.push(1);return o},_d=(e,t)=>{for(let r=0;r<e.length;++r)if(e[e.length-r-1]!==t-1-r)return!1;return!0},Cd=(e,t)=>{let r=[];if(!_d(e,t)){for(let o=0;o<t;++o)e.indexOf(o)===-1&&r.push(o);e.forEach(o=>r.push(o))}return r},Id=(e,t,r,o,n,s,u)=>{let l=r[0].dims,a=U.size(s),p=U.size(u),h=M("_A",r[0].dataType,l),g=F("output",n,s),b=32,w=`\n          var<workgroup> aBestValues : array<${g.type.storage}, ${b}>;\n       `;return{name:e,shaderCache:t,getShaderSource:_=>`\n        ${_.registerUniform("reduceSize","u32").declareVariables(h,g)}\n        ${w}\n        fn DIV_CEIL(a : u32, b : u32) -> u32 {\n          return ((a - 1u) / b + 1u);\n         }\n         ${_.mainStart(b)}\n\n          let outputIndex = global_idx / ${b};\n          let offset = outputIndex * uniforms.reduceSize;\n\n          var bestValue = ${g.type.storage}(${wd[o]});\n          let Length = uniforms.reduceSize;\n          for (var k = local_idx; k < Length; k = k + ${b}) {\n           let candidate = ${g.type.storage}(${h.getByOffset("offset + k")});\n           bestValue = ${yd[o]};\n          }\n          aBestValues[local_idx] = bestValue;\n          workgroupBarrier();\n\n         var reduceSize = min(Length, ${b}u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (local_idx < currentSize) {\n            let candidate = aBestValues[local_idx + interval];\n            bestValue = ${bd[o]};\n            aBestValues[local_idx] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (local_idx == 0u) {\n          ${g.setByOffset("outputIndex",`${o==="mean"?`bestValue / ${g.type.storage}(uniforms.reduceSize)`:`${vd[o]}`}`)};\n         }\n        }`,getRunData:()=>({outputs:[{dims:s,dataType:n}],dispatchGroup:{x:a},programUniforms:[{type:"uint32",data:p}]})}},ct=(e,t,r,o)=>{let n=e.inputs.length===1?r:Mn(e.inputs,r),s=n.axes;s.length===0&&!n.noopWithEmptyAxes&&(s=e.inputs[0].dims.map((w,y)=>y));let u=U.normalizeAxes(s,e.inputs[0].dims.length),l=u,a=e.inputs[0],p=Cd(l,e.inputs[0].dims.length);p.length>0&&(a=e.compute(it(e.inputs[0],p),{inputs:[0],outputs:[-1]})[0],l=$d(l.length,a.dims.length));let[h,g]=Sd(a.dims,l),b=h;n.keepDims&&(b=xd(h,u)),e.compute(Id(t,{hint:n.cacheKey,inputDependencies:["type"]},[a],o,e.inputs[0].dataType,b,g),{inputs:[a]})},ya=(e,t)=>{ct(e,"ReduceMeanShared",t,"mean")},ba=(e,t)=>{ct(e,"ReduceL1Shared",t,"l1")},wa=(e,t)=>{ct(e,"ReduceL2Shared",t,"l2")},va=(e,t)=>{ct(e,"ReduceLogSumExpShared",t,"logSumExp")},$a=(e,t)=>{ct(e,"ReduceMaxShared",t,"max")},Sa=(e,t)=>{ct(e,"ReduceMinShared",t,"min")},xa=(e,t)=>{ct(e,"ReduceProdShared",t,"prod")},_a=(e,t)=>{ct(e,"ReduceSumShared",t,"sum")},Ca=(e,t)=>{ct(e,"ReduceSumSquareShared",t,"sumSquare")},Ia=(e,t)=>{ct(e,"ReduceLogSumShared",t,"logSum")}});var pt,Ad,qr,Mn,mt,Td,Ed,Od,Pd,kd,Rd,Bd,Dd,Md,zd,ft,Ta,Ea,Oa,Pa,ka,Ra,Ba,Da,Ma,za,jr=j(()=>{"use strict";$e();je();ve();Aa();pt=e=>{if(!e||e.length===0||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(e.length===2&&e[1].dims.length!==1)throw new Error("Invalid axes input dims.")},Ad=e=>["","",`var value = ${e.getByIndices("input_indices")};`,""],qr=(e,t,r,o,n,s,u=!1,l=!1)=>{let a=[],p=r[0].dims,h=p.length,g=U.normalizeAxes(n,h),b=!l&&g.length===0;p.forEach((I,$)=>{b||g.indexOf($)>=0?u&&a.push(1):a.push(I)});let w=a.length,y=U.size(a);return{name:e,shaderCache:t,getShaderSource:I=>{let $=[],x=M("_A",r[0].dataType,h),E=F("output",s,w),A=o(x,E,g),z=A[2];for(let R=0,V=0;R<h;R++)b||g.indexOf(R)>=0?(u&&V++,z=`for(var j${R}: u32 = 0; j${R} < ${p[R]}; j${R}++) {\n                  ${A[2].includes("last_index")?`let last_index = j${R};`:""}\n                  ${x.indicesSet("input_indices",R,`j${R}`)}\n                  ${z}\n                }`):($.push(`${x.indicesSet("input_indices",R,E.indicesGet("output_indices",V))};`),V++);return`\n\n        ${I.registerUniform("output_size","u32").declareVariables(x,E)}\n\n        ${I.mainStart()}\n          ${I.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n          var input_indices: ${x.type.indices};\n          let output_indices = ${E.offsetToIndices("global_idx")};\n\n          ${$.join(`\n`)}\n          ${A[0]}       // init ops for reduce max/min\n          ${A[1]}\n          ${z}\n          ${A[3]}\n          ${A.length===4?E.setByOffset("global_idx","value"):A.slice(4).join(`\n`)}\n        }`},getRunData:()=>({outputs:[{dims:a,dataType:s}],dispatchGroup:{x:Math.ceil(y/64)},programUniforms:[{type:"uint32",data:y},...L(p),...L(a)]})}},Mn=(e,t)=>{let r=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach(o=>r.push(Number(o))),ge({axes:r,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},mt=(e,t,r,o)=>{let n=e.inputs,s=n.length===1?r:Mn(n,r);e.compute(qr(t,{hint:s.cacheKey,inputDependencies:["rank"]},[n[0]],s.noopWithEmptyAxes&&s.axes.length===0?Ad:o,s.axes,n[0].dataType,s.keepDims,s.noopWithEmptyAxes),{inputs:[0]})},Td=(e,t)=>{pt(e.inputs),mt(e,"ReduceLogSum",t,(o,n)=>[`var value = ${n.type.storage}(0);`,"",`value += ${o.getByIndices("input_indices")};`,"value = log(value);"])},Ed=(e,t)=>{pt(e.inputs),mt(e,"ReduceL1",t,(o,n)=>[`var value = ${n.type.storage}(0);`,"",`value += abs(${o.getByIndices("input_indices")});`,""])},Od=(e,t)=>{pt(e.inputs),mt(e,"ReduceL2",t,(o,n)=>[`var t = ${n.type.value}(0); var value = ${n.type.value}(0);`,"",`t = ${o.getByIndices("input_indices")}; value += (t * t);`,"value = sqrt(value);"])},Pd=(e,t)=>{pt(e.inputs),mt(e,"ReduceLogSumExp",t,(o,n)=>[`var value = ${n.type.storage}(0);`,"",`value += exp(${o.getByIndices("input_indices")});`,"value = log(value);"])},kd=(e,t)=>{pt(e.inputs),mt(e,"ReduceMax",t,(o,n,s)=>{let u=[];for(let l=0;l<o.rank;l++)(s.indexOf(l)>=0||s.length===0)&&u.push(o.indicesSet("input_indices",l,0));return[`${u.join(`\n`)}`,`var value = ${o.getByIndices("input_indices")};`,`value = max(value, ${o.getByIndices("input_indices")});`,""]})},Rd=(e,t)=>{pt(e.inputs),mt(e,"ReduceMean",t,(o,n,s)=>{let u=1;for(let l=0;l<o.rank;l++)(s.indexOf(l)>=0||s.length===0)&&(u*=e.inputs[0].dims[l]);return["var sum = f32(0);","",`sum += f32(${o.getByIndices("input_indices")});`,`let value = ${n.type.value}(sum / ${u});`]})},Bd=(e,t)=>{pt(e.inputs),mt(e,"ReduceMin",t,(o,n,s)=>{let u=[];for(let l=0;l<o.rank;l++)(s.indexOf(l)>=0||s.length===0)&&u.push(`input_indices[${l}] = 0;`);return[`${u.join(`\n`)}`,`var value = ${o.getByIndices("input_indices")};`,`value = min(value, ${o.getByIndices("input_indices")});`,""]})},Dd=(e,t)=>{pt(e.inputs),mt(e,"ReduceProd",t,(o,n)=>[`var value = ${n.type.storage}(1);`,"",`value *= ${o.getByIndices("input_indices")};`,""])},Md=(e,t)=>{pt(e.inputs),mt(e,"ReduceSum",t,(o,n)=>[`var value = ${n.type.storage}(0);`,"",`value += ${o.getByIndices("input_indices")};`,""])},zd=(e,t)=>{pt(e.inputs),mt(e,"ReduceSumSquare",t,(o,n)=>[`var t = ${n.type.value}(0); var value = ${n.type.value}(0);`,"",`t = ${o.getByIndices("input_indices")}; value += t * t;`,""])},ft=(e,t,r)=>{if(t.length===0)return r;let o=1,n=1;for(let s=0;s<t.length;s++)t.indexOf(s)===-1?o*=e[s]:n*=e[s];return n<32&&o>1024},Ta=(e,t)=>{ft(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Rd(e,t):ya(e,t)},Ea=(e,t)=>{ft(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Ed(e,t):ba(e,t)},Oa=(e,t)=>{ft(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Od(e,t):wa(e,t)},Pa=(e,t)=>{ft(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Pd(e,t):va(e,t)},ka=(e,t)=>{ft(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?kd(e,t):$a(e,t)},Ra=(e,t)=>{ft(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Bd(e,t):Sa(e,t)},Ba=(e,t)=>{ft(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Dd(e,t):xa(e,t)},Da=(e,t)=>{ft(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Md(e,t):_a(e,t)},Ma=(e,t)=>{ft(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?zd(e,t):Ca(e,t)},za=(e,t)=>{ft(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Td(e,t):Ia(e,t)}});var Ua,Va,Na,zn,Wa=j(()=>{"use strict";Ne();je();jr();Ua=e=>{if(!e||e.length===0||e.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(e[0].dataType!==1)throw new Error("Invalid input type.")},Va=(e,t)=>{Ua(e.inputs);let r=(o,n,s)=>{let u=[];for(let l=0;l<o.rank;l++)(s.indexOf(l)>=0||s.length===0)&&u.push(`input_indices[${l}] = 0;`);return[`${u.join(`\n`)}`,`var value = ${o.getByIndices("input_indices")};\nvar best_index : i32 = 0;`,`if (${o.getByIndices("input_indices")} ${t.selectLastIndex>0?"<=":"<"} value) {\n         value = ${o.getByIndices("input_indices")};\n         best_index = i32(last_index);\n       }`,"",n.setByOffset("global_idx","best_index")]};e.compute(qr("ArgMin",{hint:t.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],r,[t.axis],7,t.keepDims),{inputs:[0]})},Na=(e,t)=>{Ua(e.inputs);let r=(o,n,s)=>{let u=[];for(let l=0;l<o.rank;l++)(s.indexOf(l)>=0||s.length===0)&&u.push(`input_indices[${l}] = 0;`);return[`${u.join(`\n`)}`,`var value = ${o.getByIndices("input_indices")};\nvar best_index : i32 = 0;`,`if (${o.getByIndices("input_indices")} ${t.selectLastIndex>0?">=":">"} value) {\n         value = ${o.getByIndices("input_indices")};\n         best_index = i32(last_index);\n       }`,"",n.setByOffset("global_idx","best_index")]};e.compute(qr("argMax",{hint:t.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],r,[t.axis],7,t.keepDims),{inputs:[0]})},zn=e=>ge(e)});var Ud,Vd,Nd,Wd,Kr,Hd,Ha,Un=j(()=>{"use strict";Ne();Nr();ve();Ud=(e,t)=>{let r=e[0],o=e[1],n=e[2],s=e[3],u=e[4],l=e[5];if(u&&l)throw new Error("Attention cannot have both past and relative_position_bias");if(r.dims.length!==3)throw new Error(\'Input "input" must have 3 dimensions\');let a=r.dims[0],p=r.dims[1],h=r.dims[2];if(n.dims.length!==1)throw new Error(\'Input "bias" is expected to have 1 dimensions\');if(o.dims.length!==2)throw new Error(\'Input "weights" is expected to have 2 dimensions\');if(o.dims[0]!==h)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(n.dims[0]!==o.dims[1])throw new Error(\'Input "bias" dimension 0 should have same length as dimension 1 of input "weights"\');let g=n.dims[0]/3,b=g,w=b;if(t.qkvHiddenSizes.length>0){if(t.qkvHiddenSizes.length!==3)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let E of t.qkvHiddenSizes)if(E%t.numHeads!==0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");g=t.qkvHiddenSizes[0],b=t.qkvHiddenSizes[1],w=t.qkvHiddenSizes[2]}let y=p;if(g!==b)throw new Error("qkv_hidden_sizes first element should be same as the second");if(n.dims[0]!==g+b+w)throw new Error(\'Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes\');let _=0;if(u){if(b!==w)throw new Error(\'Input "past" expect k_hidden_size == v_hidden_size\');if(u.dims.length!==5)throw new Error(\'Input "past" must have 5 dimensions\');if(u.dims[0]!==2)throw new Error(\'Input "past" first dimension must be 2\');if(u.dims[1]!==a)throw new Error(\'Input "past" second dimension must be batch_size\');if(u.dims[2]!==t.numHeads)throw new Error(\'Input "past" third dimension must be num_heads\');if(u.dims[4]!==b/t.numHeads)throw new Error(\'Input "past" fifth dimension must be k_hidden_size / num_heads\');t.pastPresentShareBuffer||(_=u.dims[3])}let I=y+_,$=-1,x=0;if(s)throw new Error("Mask not supported");if(u)throw new Error("past is not supported");if(l)throw new Error("relativePositionBias is not supported");return{batchSize:a,sequenceLength:p,pastSequenceLength:_,kvSequenceLength:y,totalSequenceLength:I,maxSequenceLength:$,inputHiddenSize:h,hiddenSize:g,vHiddenSize:w,headSize:Math.floor(g/t.numHeads),vHeadSize:Math.floor(w/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:x,scale:t.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},Vd=(e,t,r,o)=>{let n=Fe(o),s=64,u=o/n;u<s?s=1:u/8<64&&(s=Math.ceil(u/8));let l=Math.ceil(o/n/s),p=[{type:Xe(t.dataType),data:1/o},{type:"uint32",data:u},{type:"uint32",data:l}],h=Le(t.dataType,n),g=b=>{let w=F("x",t.dataType,t.dims,n),y="thread_max_vector";n===2?y="max(thread_max_vector.x, thread_max_vector.y)":n===4&&(y="max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))");let _=lt(t.dataType),I=[{name:"d_inv",type:_},{name:"d_comp",type:"u32"},{name:"elements_per_wg",type:"u32"}];return`\n  var<workgroup> wgMax: array<f32, ${s}>;\n  var<workgroup> wgSum: array<f32, ${s}>;\n  ${b.registerUniforms(I).declareVariables(w)}\n  ${b.mainStart([s,1,1])}\n    let localOffset = local_idx * uniforms.elements_per_wg;\n    let offset: u32 = workgroup_id.x * uniforms.d_comp + localOffset;\n\n    var thread_max_vector = ${Ze("f32",n,"-3.402823e+38f")};\n    for (var i: u32 = 0; i < uniforms.elements_per_wg && i + localOffset < uniforms.d_comp; i++) {\n      thread_max_vector = max(${at(_,n,"x[offset + i]")}, thread_max_vector);\n    }\n    wgMax[local_idx] = ${y};\n    workgroupBarrier();\n\n    var maxValue = -3.402823e+38f;\n    for (var i = 0u; i < ${s}; i++) {\n      maxValue = max(wgMax[i], maxValue);\n    }\n\n    var sumVector = ${Ze("f32",n,"0")};\n    for (var i: u32 = 0; i < uniforms.elements_per_wg && i + localOffset < uniforms.d_comp; i++) {\n      sumVector += exp(${at(_,n,"x[offset + i]")} - maxValue);\n    }\n    wgSum[local_idx] = ${Je("sumVector",n)};\n    workgroupBarrier();\n\n    var sum: f32 = 0;\n    for (var i = 0u; i < ${s}; i++) {\n      sum += wgSum[i];\n    }\n\n    if (sum == 0) {\n      for (var i: u32 = 0; i < uniforms.elements_per_wg && i + localOffset < uniforms.d_comp; i++) {\n        x[offset + i] = ${Ze("f32",n,"uniforms.d_inv")};\n      }\n    } else {\n      for (var i: u32 = 0; i < uniforms.elements_per_wg && i + localOffset < uniforms.d_comp; i++) {\n        let f32input = ${at(_,n,"x[offset + i]")};\n        x[offset + i] = ${w.type.value}(exp(f32input - maxValue) / sum);\n      }\n    }\n  }`};e.compute({name:"AttentionProbsSoftmax",shaderCache:{hint:`${s};${h};${n}`},getShaderSource:g,getRunData:()=>({outputs:[],dispatchGroup:{x:r},programUniforms:p})},{inputs:[t],outputs:[]})},Nd=(e,t,r,o,n,s)=>{let u=[n.batchSize,n.numHeads,n.sequenceLength,n.kvSequenceLength+n.pastSequenceLength],l=s.scale===0?1/Math.sqrt(n.headSize):s.scale,a=Fe(n.headSize),p=n.headSize/a,h=12,g={x:Math.ceil(n.totalSequenceLength/h),y:Math.ceil(n.sequenceLength/h),z:n.batchSize*n.numHeads},b=Xe(t.dataType),w=[{type:"uint32",data:n.sequenceLength},{type:"uint32",data:p},{type:"uint32",data:n.totalSequenceLength},{type:"uint32",data:n.kvSequenceLength},{type:b,data:l}],y=[t,r],_=$=>{let x=M("q",t.dataType,t.dims,a),E=M("key",r.dataType,r.dims,a),A=F("output",t.dataType,u),z=Le(t.dataType),R=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"alpha",type:z}];return`\n  const beta: ${z} = 1.0;\n  const TILE_SIZE = ${h}u;\n\n  var<workgroup> tileQ: array<${x.type.storage}, ${h*h}>;\n  var<workgroup> tileK: array<${x.type.storage}, ${h*h}>;\n  ${$.registerUniforms(R).declareVariables(x,E,A)}\n  ${$.mainStart([h,h,1])}\n    // x holds the N and y holds the M\n    let headIdx = workgroup_id.z;\n    let m = workgroup_id.y * TILE_SIZE;\n    let n = workgroup_id.x * TILE_SIZE;\n    let lm = m + local_id.y;\n    let ln = n + local_id.x;\n\n    let qOffset = uniforms.M * uniforms.K * headIdx + m * uniforms.K;\n    let kOffset = uniforms.kv_sequence_length * uniforms.K * headIdx + n * uniforms.K;\n\n    var value = ${Ze(z,a)};\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (m + local_id.y < uniforms.M && w + local_id.x < uniforms.K) {\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];\n      }\n      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {\n        tileK[TILE_SIZE * local_id.y + local_id.x] = key[kOffset + local_id.y * uniforms.K + w + local_id.x];\n      }\n      workgroupBarrier();\n\n      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {\n        value += tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k];\n      }\n\n      workgroupBarrier();\n    }\n\n    let headOffset = headIdx * uniforms.M * uniforms.N;\n    if (lm < uniforms.M && ln < uniforms.N) {\n      let outputIdx = headOffset + lm * uniforms.N + ln;\n      output[outputIdx] = ${Je("value",a)} * uniforms.alpha;\n    }\n  }`},I=e.compute({name:"AttentionProbs",shaderCache:{hint:`${a}`,inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:u,dataType:t.dataType,gpuDataType:0}],dispatchGroup:g,programUniforms:w}),getShaderSource:_},{inputs:y,outputs:[-1]})[0];return Vd(e,I,n.batchSize*n.numHeads*n.sequenceLength,n.totalSequenceLength),I},Wd=(e,t,r,o)=>{let n=[o.batchSize,o.sequenceLength,o.vHiddenSize],s=12,u={x:Math.ceil(o.vHeadSize/s),y:Math.ceil(o.sequenceLength/s),z:o.batchSize*o.numHeads},l=[{type:"uint32",data:o.sequenceLength},{type:"uint32",data:o.totalSequenceLength},{type:"uint32",data:o.vHeadSize},{type:"uint32",data:o.numHeads},{type:"uint32",data:o.vHiddenSize}],a=p=>{let h=M("probs",t.dataType,t.dims),g=M("v",r.dataType,r.dims),b=F("output",t.dataType,n),w=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"v_hidden_size",type:"u32"}];return`\n  const TILE_SIZE = ${s}u;\n  var<workgroup> tileQ: array<${h.type.value}, ${s*s}>;\n  var<workgroup> tileK: array<${h.type.value}, ${s*s}>;\n  ${p.registerUniforms(w).declareVariables(h,g,b)}\n  ${p.mainStart([s,s,1])}\n   let headIdx = workgroup_id.z;\n   let m = workgroup_id.y * TILE_SIZE + local_id.y;\n   let n = workgroup_id.x * TILE_SIZE + local_id.x;\n\n   let offsetA = headIdx * (uniforms.M * uniforms.K) + m * uniforms.K;\n   let offsetB = headIdx * (uniforms.N * uniforms.K) + n;\n\n   var value = ${h.type.storage}(0);\n   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n     if (m < uniforms.M && w + local_id.x < uniforms.K) {\n       tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];\n     }\n     if (n < uniforms.N && w + local_id.y < uniforms.K) {\n       tileK[TILE_SIZE * local_id.y + local_id.x] = v[offsetB + (w + local_id.y) * uniforms.N];\n     }\n     workgroupBarrier();\n     for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {\n       value += tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * k + local_id.x];\n     }\n     workgroupBarrier();\n   }\n\n   // we need to transpose output from BNSH_v to BSND_v\n   let batchIdx = workgroup_id.z / uniforms.num_heads;\n   let currentBatchHeadNumber = workgroup_id.z % uniforms.num_heads;\n   let headOffset = (batchIdx * uniforms.M * uniforms.num_heads + currentBatchHeadNumber) * uniforms.N;\n   if (m < uniforms.M && n < uniforms.N) {\n     let outputIdx = batchIdx * uniforms.M *uniforms.v_hidden_size + m * uniforms.v_hidden_size\n       + currentBatchHeadNumber * uniforms.N + n;\n     output[outputIdx] = value;\n   }\n  }`};return e.compute({name:"AttentionScore",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:n,dataType:t.dataType,gpuDataType:0}],dispatchGroup:u,programUniforms:l}),getShaderSource:a},{inputs:[t,r],outputs:[0]})[0]},Kr=(e,t,r,o,n,s,u,l,a,p,h)=>{let g=Nd(e,t,r,a,p,h);Wd(e,g,o,p)},Hd=(e,t)=>{let r=[t.batchSize,t.numHeads,t.sequenceLength,t.headSize],o=t.sequenceLength,n=t.inputHiddenSize,s=t.headSize,u=12,l={x:Math.ceil(t.headSize/u),y:Math.ceil(t.sequenceLength/u),z:t.batchSize*t.numHeads},a=[e.inputs[0],e.inputs[1],e.inputs[2]],p=[{type:"uint32",data:o},{type:"uint32",data:n},{type:"uint32",data:s},{type:"uint32",data:t.numHeads},{type:"uint32",data:t.headSize},{type:"uint32",data:t.hiddenSize},{type:"uint32",data:t.hiddenSize+t.hiddenSize+t.vHiddenSize}],h=g=>{let b=F("output_q",a[0].dataType,r),w=F("output_k",a[0].dataType,r),y=F("output_v",a[0].dataType,r),_=M("input",a[0].dataType,a[0].dims),I=M("weight",a[1].dataType,a[1].dims),$=M("bias",a[2].dataType,a[2].dims),x=_.type.storage,E=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"hidden_size",type:"u32"},{name:"ldb",type:"u32"}];return`\n  const TILE_SIZE = ${u}u;\n  var<workgroup> tileInput: array<${x}, ${u*u}>;\n  var<workgroup> tileWeightQ: array<${x}, ${u*u}>;\n  var<workgroup> tileWeightK: array<${x}, ${u*u}>;\n  var<workgroup> tileWeightV: array<${x}, ${u*u}>;\n  ${g.registerUniforms(E).declareVariables(_,I,$,b,w,y)}\n  ${g.mainStart([u,u,1])}\n    let batchIndex = workgroup_id.z / uniforms.num_heads;\n    let headNumber = workgroup_id.z % uniforms.num_heads;\n    let m = workgroup_id.y * TILE_SIZE + local_id.y;\n    let n = workgroup_id.x * TILE_SIZE + local_id.x;\n\n    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;\n    let biasOffsetQ = headNumber * uniforms.head_size;\n    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;\n    let biasOffsetV = uniforms.hidden_size + biasOffsetK;\n\n    var valueQ = ${x}(0);\n    var valueK = ${x}(0);\n    var valueV = ${x}(0);\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (m < uniforms.M && w + local_id.x < uniforms.K) {\n        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];\n      }\n      if (n < uniforms.N && w + local_id.y < uniforms.K) {\n        let offset = n + (w + local_id.y) * uniforms.ldb;\n        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];\n        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];\n        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];\n      }\n      workgroupBarrier();\n      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {\n        let inputTileOffset = TILE_SIZE * local_id.y + k;\n        let weightTileOffset = TILE_SIZE * k + local_id.x;\n        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];\n        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];\n        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];\n      }\n\n      workgroupBarrier();\n    }\n\n    let headOffset = (m * uniforms.N + n) % uniforms.head_size;\n    valueQ += bias[headOffset + biasOffsetQ];\n    valueK += bias[headOffset + biasOffsetK];\n    valueV += bias[headOffset + biasOffsetV];\n\n    let offset = workgroup_id.z * uniforms.M * uniforms.N;\n    if (m < uniforms.M && n < uniforms.N) {\n      let outputIdx = offset + m * uniforms.N + n;\n      output_q[outputIdx] = valueQ;\n      output_k[outputIdx] = valueK;\n      output_v[outputIdx] = valueV;\n    }\n  }`};return e.compute({name:"AttentionPrepare",shaderCache:{inputDependencies:["type","type","type"]},getRunData:()=>({outputs:[{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0}],dispatchGroup:l,programUniforms:p}),getShaderSource:h},{inputs:a,outputs:[-1,-1,-1]})},Ha=(e,t)=>{let r=Ud(e.inputs,t),[o,n,s]=Hd(e,r);return Kr(e,o,n,s,e.inputs[4],void 0,void 0,void 0,e.inputs[5],r,t)}});var Gd,Ld,Fd,Ga,La=j(()=>{"use strict";Lt();$e();je();ve();Gd=(e,t)=>{if(!e||e.length!==5)throw new Error("BatchNormalization requires 5 inputs");let r=(o,n,s)=>{let u=n.length;if(u!==o.length)throw new Error(`${s}: num dimensions != ${u}`);n.forEach((l,a)=>{if(l!==o[a])throw new Error(`${s}: dim[${a}] do not match`)})};if(e[0].dims.length>1){let o=t.format==="NHWC"?t.spatial?e[0].dims.slice(-1):e[0].dims.slice(-1).concat(e[0].dims.slice(1,e[0].dims.length-1)):e[0].dims.slice(1,t.spatial?2:void 0);r(e[1].dims,o,"Invalid input scale"),r(e[2].dims,o,"Invalid input B"),r(e[3].dims,o,"Invalid input mean"),r(e[4].dims,o,"Invalid input var")}else r(e[1].dims,[1],"Invalid input scale"),r(e[2].dims,[1],"Invalid input B"),r(e[3].dims,[1],"Invalid input mean"),r(e[4].dims,[1],"Invalid input var")},Ld=(e,t)=>{let{epsilon:r,spatial:o,format:n}=t,s=e[0].dims,u=o?Fe(s[s.length-1]):1,l=n==="NHWC"&&s.length>1?u:1,a=U.size(s)/u,p=Re(s.length)&&o,h=p?s.length:s,g=M("x",e[0].dataType,e[0].dims,u),b=M("scale",e[1].dataType,e[1].dims,l),w=M("bias",e[2].dataType,e[2].dims,l),y=M("inputMean",e[3].dataType,e[3].dims,l),_=M("inputVar",e[4].dataType,e[4].dims,l),I=F("y",e[0].dataType,h,u),$=()=>{let E="";if(o)E=`let cOffset = ${s.length===1?"0u":n==="NHWC"?`outputIndices[${s.length-1}] / ${u}`:"outputIndices[1]"};`;else if(n==="NCHW")E=`\n            ${I.indicesSet("outputIndices","0","0")}\n            let cOffset = ${I.indicesToOffset("outputIndices")};`;else{E=`var cIndices = ${b.type.indices}(0);\n                       cIndices[0] = outputIndices[${s.length-1}];`;for(let A=1;A<b.rank;A++)E+=`cIndices[${A}] = outputIndices[${A}];`;E+=`let cOffset = ${b.indicesToOffset("cIndices")};`}return E},x=E=>`\n  const epsilon = ${r};\n  ${E.registerUniform("outputSize","u32").declareVariables(g,b,w,y,_,I)}\n  ${E.mainStart()}\n  ${E.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n    var outputIndices = ${I.offsetToIndices(`global_idx * ${u}`)};\n    ${$()}\n    let scale = ${b.getByOffset("cOffset")};\n    let bias = ${w.getByOffset("cOffset")};\n    let inputMean = ${y.getByOffset("cOffset")};\n    let inputVar = ${_.getByOffset("cOffset")};\n    let x = ${g.getByOffset("global_idx")};\n    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;\n    ${I.setByOffset("global_idx","value")}\n  }`;return{name:"BatchNormalization",shaderCache:{hint:`${t.epsilon}_${t.format}_${o}_${u}`,inputDependencies:p?["rank","type","type","type","type"]:void 0},getShaderSource:x,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:p?[{type:"uint32",data:a},...L(s)]:[{type:"uint32",data:a}]})}},Fd=e=>ge(e),Ga=(e,t)=>{let{inputs:r,outputCount:o}=e,n=Fd({...t,outputCount:o});if(Gt.webgpu.validateInputContent&&Gd(r,n),t.trainingMode)throw new Error("BatchNormalization trainingMode is not supported yet.");e.compute(Ld(r,n))}});var jd,qd,Fa,ja=j(()=>{"use strict";$e();ve();jd=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(e[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},qd=e=>{let t=e[0].dims,r=e[0].dims[2],o=U.size(t)/4,n=e[0].dataType,s=M("input",n,t,4),u=M("bias",n,[r],4),l=M("residual",n,t,4),a=F("output",n,t,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)}}),getShaderSource:h=>`\n  const channels = ${r}u / 4;\n  ${h.declareVariables(s,u,l,a)}\n\n  ${h.mainStart()}\n    ${h.guardAgainstOutOfBoundsWorkgroupSizes(o)}\n    let value = ${s.getByOffset("global_idx")}\n      + ${u.getByOffset("global_idx % channels")} + ${l.getByOffset("global_idx")};\n    ${a.setByOffset("global_idx","value")}\n  }`}},Fa=e=>{jd(e.inputs),e.compute(qd(e.inputs))}});var Kd,Ae,qa,Ka,Ya,Za,Qa,Xa,Ja,ei,ti,Yd,ri,ni,oi,ai,Yr,ii,Zr,si,ui,di,li,ci,pi,mi,fi,hi,gi,yi,bi,wi,vi,$i,Si,xi,Vn=j(()=>{"use strict";Ne();$e();je();ve();Kd=(e,t,r,o,n,s)=>{let u=Math.ceil(t/4),l="";typeof n=="string"?l=`${n}(a)`:l=n("a");let a=M("inputData",r,[u],4),p=F("outputData",o,[u],4);return`\n      ${e.registerUniform("vec_size","u32").declareVariables(a,p)}\n\n  ${s??""}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n\n    let a = ${a.getByOffset("global_idx")};\n    ${p.setByOffset("global_idx",l)}\n  }`},Ae=(e,t,r,o,n,s=e.dataType)=>({name:t,shaderCache:{hint:n,inputDependencies:["type"]},getShaderSource:u=>Kd(u,U.size(e.dims),e.dataType,s,r,o),getRunData:u=>({outputs:[{dims:e.dims,dataType:s}],dispatchGroup:{x:Math.ceil(U.size(u[0].dims)/64/4)},programUniforms:[{type:"uint32",data:Math.ceil(U.size(e.dims)/4)}]})}),qa=e=>{e.compute(Ae(e.inputs[0],"Abs","abs"))},Ka=e=>{e.compute(Ae(e.inputs[0],"Acos","acos"))},Ya=e=>{e.compute(Ae(e.inputs[0],"Acosh","acosh"))},Za=e=>{e.compute(Ae(e.inputs[0],"Asin","asin"))},Qa=e=>{e.compute(Ae(e.inputs[0],"Asinh","asinh"))},Xa=e=>{e.compute(Ae(e.inputs[0],"Atan","atan"))},Ja=e=>{e.compute(Ae(e.inputs[0],"Atanh","atanh"))},ei=e=>ge(e),ti=(e,t)=>{let r;switch(t.to){case 10:r="vec4<f16>";break;case 1:r="vec4<f32>";break;case 12:r="vec4<u32>";break;case 6:r="vec4<i32>";break;case 9:r="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute \'to\' from \'Cast\' operator): ${t.to}`)}e.compute(Ae(e.inputs[0],"Cast",r,void 0,t.cacheKey,t.to))},Yd=e=>{let t=e.length>=2&&e[1].data!==0?e[1].getFloat32Array()[0]:Gr,r=e.length>=3&&e[2].data!==0?e[2].getFloat32Array()[0]:Lr;return ge({min:t,max:r})},ri=(e,t)=>{let r=e.inputs.length===1?t:Yd(e.inputs),o=lt(e.inputs[0].dataType);e.compute(Ae(e.inputs[0],"Clip",n=>`clamp(${n}, clip_min_, clip_max_)`,`\n    const clip_min_: vec4<${o}> = vec4(${o}(${r.min}));\n    const clip_max_: vec4<${o}> = vec4(${o}(${r.max}));\n`,r.cacheKey),{inputs:[0]})},ni=e=>{e.compute(Ae(e.inputs[0],"Ceil","ceil"))},oi=e=>{e.compute(Ae(e.inputs[0],"Cos","cos"))},ai=e=>{e.compute(Ae(e.inputs[0],"Cosh","cosh"))},Yr=e=>ge(e),ii=(e,t)=>{let r=lt(e.inputs[0].dataType);e.compute(Ae(e.inputs[0],"Elu",o=>`elu_vf32(${o})`,`\n  const elu_alpha_ = ${r}(${t.alpha});\n\n  fn elu_f32(a: ${r}) -> ${r} {\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\n  }\n\n  fn elu_vf32(v: vec4<${r}>) -> vec4<${r}> {\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\n  }`,t.cacheKey))},Zr=(e,t="f32")=>`\nconst r0: ${t} = 0.3275911;\nconst r1: ${t} = 0.254829592;\nconst r2: ${t} = -0.284496736;\nconst r3: ${t} = 1.421413741;\nconst r4: ${t} = -1.453152027;\nconst r5: ${t} = 1.061405429;\n\nfn erf_vf32(v: ${e}) -> ${e} {\n  let absv = abs(v);\n  let x = 1.0 / (1.0 + r0 * absv);\n  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\n}`,si=e=>{let t=lt(e.inputs[0].dataType);e.compute(Ae(e.inputs[0],"Erf",r=>`erf_vf32(${r})`,Zr(`vec4<${t}>`,t)))},ui=e=>{e.compute(Ae(e.inputs[0],"Exp","exp"))},di=e=>{e.compute(Ae(e.inputs[0],"Floor","floor"))},li=e=>{let t=lt(e.inputs[0].dataType);e.compute(Ae(e.inputs[0],"Gelu",r=>`0.5 * ${r} * (1.0 + erf_vf32(${r} * 0.7071067811865475))`,Zr(`vec4<${t}>`,t)))},ci=(e,t)=>{let r=lt(e.inputs[0].dataType);e.compute(Ae(e.inputs[0],"LeakyRelu",o=>`select(leaky_relu_alpha_ * ${o}, ${o}, ${o} >= vec4<${r}>(0.0))`,`const leaky_relu_alpha_ = ${r}(${t.alpha});`,t.cacheKey))},pi=e=>{e.compute(Ae(e.inputs[0],"Not",t=>`!${t}`))},mi=e=>{e.compute(Ae(e.inputs[0],"Neg",t=>`-${t}`))},fi=e=>{e.compute(Ae(e.inputs[0],"Reciprocal",t=>`1.0/${t}`))},hi=e=>{let t=lt(e.inputs[0].dataType);e.compute(Ae(e.inputs[0],"Relu",r=>`select(vec4<${t}>(0.0), ${r}, ${r} > vec4<${t}>(0.0))`))},gi=e=>{e.compute(Ae(e.inputs[0],"Sigmoid",t=>`(1.0 / (1.0 + exp(-${t})))`))},yi=e=>{e.compute(Ae(e.inputs[0],"Sin","sin"))},bi=e=>{e.compute(Ae(e.inputs[0],"Sinh","sinh"))},wi=e=>{e.compute(Ae(e.inputs[0],"Sqrt","sqrt"))},vi=e=>{e.compute(Ae(e.inputs[0],"Tan","tan"))},$i=e=>{e.compute(Ae(e.inputs[0],"Tanh","tanh"))},Si=(e,t)=>{let r=lt(e.inputs[0].dataType);return e.compute(Ae(e.inputs[0],"ThresholdedRelu",o=>`select(vec4<${r}>(0.0), ${o}, ${o} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_ = vec4<${r}>(${t.alpha});`,t.cacheKey)),0},xi=e=>{e.compute(Ae(e.inputs[0],"Log","log"))}});var Qd,Xd,_i,Ci=j(()=>{"use strict";$e();ve();Vn();Qd=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Xd=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let r=M("input",e[0].dataType,e[0].dims,4),o=M("bias",e[0].dataType,[e[0].dims[2]],4),n=F("output",e[0].dataType,t,4),s=U.size(t)/4,u=Le(e[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:a=>`\n  const M_SQRT2 = sqrt(2.0);\n  const halfChannels = ${e[0].dims[2]/4/2}u;\n\n  ${a.declareVariables(r,o,n)}\n\n  ${Zr(`vec4<${u}>`,u)}\n\n  ${a.mainStart()}\n    ${a.guardAgainstOutOfBoundsWorkgroupSizes(s)}\n    let biasIdx = global_idx % halfChannels;\n    let batchIndex = global_idx / halfChannels;\n    let inputOffset = biasIdx + batchIndex * halfChannels * 2;\n    let valueLeft = input[inputOffset] + bias[biasIdx];\n    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];\n    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);\n\n    ${n.setByOffset("global_idx","valueLeft * geluRight")}\n  }`}},_i=e=>{Qd(e.inputs),e.compute(Xd(e.inputs))}});var Jd,el,ht,Ii,Ai,Ti,Ei,Oi,Pi,ki,Ri,Bi,Di,Mi=j(()=>{"use strict";Ne();$e();ve();Jd=(e,t,r,o,n,s,u,l,a,p,h,g,b)=>{let w,y;typeof l=="string"?w=y=(R,V)=>`${l}((${R}),(${V}))`:typeof l=="function"?w=y=l:(w=l.scalar,y=l.vector);let _=g?t.length:t,I=g?r.length:r,$=g?o.length:o,x=F("outputData",h,$,4),E=M("aData",a,_,4),A=M("bData",p,I,4),z;if(n)if(s){let R=U.size(t)===1,V=U.size(r)===1,T=t.length>0&&t[t.length-1]%4===0,N=r.length>0&&r[r.length-1]%4===0;R||V?z=x.setByOffset("global_idx",y(R?`${E.type.value}(${E.getByOffset("0")}.x)`:E.getByOffset("global_idx"),V?`${A.type.value}(${A.getByOffset("0")}.x)`:A.getByOffset("global_idx"))):z=`\n            let outputIndices = ${x.offsetToIndices("global_idx * 4u")};\n            let offsetA = ${E.broadcastedIndicesToOffset("outputIndices",x)};\n            let offsetB = ${A.broadcastedIndicesToOffset("outputIndices",x)};\n            ${x.setByOffset("global_idx",y(u||T?E.getByOffset("offsetA / 4u"):`${E.type.value}(${E.getByOffset("offsetA / 4u")}[offsetA % 4u])`,u||N?A.getByOffset("offsetB / 4u"):`${A.type.value}(${A.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}\n          `}else z=x.setByOffset("global_idx",y(E.getByOffset("global_idx"),A.getByOffset("global_idx")));else{if(!s)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let R=(V,T,N="")=>{let te=`aData[indexA${T}][componentA${T}]`,Y=`bData[indexB${T}][componentB${T}]`;return`\n            let outputIndices${T} = ${x.offsetToIndices(`global_idx * 4u + ${T}u`)};\n            let offsetA${T} = ${E.broadcastedIndicesToOffset(`outputIndices${T}`,x)};\n            let offsetB${T} = ${A.broadcastedIndicesToOffset(`outputIndices${T}`,x)};\n            let indexA${T} = offsetA${T} / 4u;\n            let indexB${T} = offsetB${T} / 4u;\n            let componentA${T} = offsetA${T} % 4u;\n            let componentB${T} = offsetB${T} % 4u;\n            ${V}[${T}] = ${N}(${w(te,Y)});\n          `};h===9?z=`\n            var data = vec4<u32>(0);\n            ${R("data",0,"u32")}\n            ${R("data",1,"u32")}\n            ${R("data",2,"u32")}\n            ${R("data",3,"u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:z=`\n            ${R("outputData[global_idx]",0)}\n            ${R("outputData[global_idx]",1)}\n            ${R("outputData[global_idx]",2)}\n            ${R("outputData[global_idx]",3)}\n          `}return`\n        ${e.registerUniform("vec_size","u32").declareVariables(E,A,x)}\n\n        ${b??""}\n\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n        ${z}\n      }`},el=(e,t,r,o,n,s,u=r.dataType)=>{let l=!U.areEqual(r.dims,o.dims),a=r.dims,p=U.size(r.dims),h=!1,g=!1,b=[l];if(l){let y=dt.calcShape(r.dims,o.dims,!1);if(!y)throw new Error("Can\'t perform binary op on the given tensors");a=y,p=U.size(a);let _=U.size(r.dims)===1,I=U.size(o.dims)===1,$=r.dims.length>0&&r.dims[r.dims.length-1]%4===0,x=o.dims.length>0&&o.dims[o.dims.length-1]%4===0;b.push(_),b.push(I),b.push($),b.push(x);let E=1;for(let A=1;A<a.length;A++){let z=r.dims[r.dims.length-A]??1,R=o.dims[o.dims.length-A]??1;if(z===R)E*=z;else break}E%4===0?(g=!0,h=!0):(_||I||$||x)&&(h=!0)}else h=!0;b.push(h);let w=Re(r.dims.length)&&Re(o.dims.length)&&Re(a.length);return{name:e,shaderCache:{hint:t+b.map(y=>y.toString()).join("_"),inputDependencies:w?["rank","rank"]:["dims","dims"]},getShaderSource:y=>Jd(y,r.dims,o.dims,a,h,l,g,n,r.dataType,o.dataType,u,w,s),getRunData:()=>({outputs:[{dims:a,dataType:u}],dispatchGroup:{x:Math.ceil(p/64/4)},programUniforms:w?[{type:"uint32",data:Math.ceil(U.size(a)/4)},...L(r.dims),...L(o.dims),...L(a)]:[{type:"uint32",data:Math.ceil(U.size(a)/4)}]})}},ht=(e,t,r,o,n,s)=>{e.compute(el(t,n??"",e.inputs[0],e.inputs[1],r,o,s))},Ii=e=>{ht(e,"Add",(t,r)=>`${t}+${r}`)},Ai=e=>{ht(e,"Div",(t,r)=>`${t}/${r}`)},Ti=e=>{ht(e,"Equal",{scalar:(t,r)=>`u32(${t}==${r})`,vector:(t,r)=>`vec4<u32>(${t}==${r})`},void 0,void 0,9)},Ei=e=>{ht(e,"Mul",(t,r)=>`${t}*${r}`)},Oi=e=>{let t=M("input",e.inputs[0].dataType,e.inputs[0].dims).type.value;ht(e,"Pow",{scalar:(o,n)=>`pow_custom(${o},${n})`,vector:(o,n)=>`pow_vector_custom(${o},${n})`},`\n    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {\n      if (b == ${t}(0.0)) {\n        return ${t}(1.0);\n      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {\n        return ${t}(pow(f32(a), f32(b))); // NaN\n      }\n      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${t==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));\n    }\n    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {\n      // TODO: implement vectorized pow\n      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));\n    }\n      `)},Pi=e=>{ht(e,"Sub",(t,r)=>`${t}-${r}`)},ki=e=>{ht(e,"Greater",{scalar:(t,r)=>`u32(${t}>${r})`,vector:(t,r)=>`vec4<u32>(${t}>${r})`},void 0,void 0,9)},Ri=e=>{ht(e,"Less",{scalar:(t,r)=>`u32(${t}<${r})`,vector:(t,r)=>`vec4<u32>(${t}<${r})`},void 0,void 0,9)},Bi=e=>{ht(e,"GreaterOrEqual",{scalar:(t,r)=>`u32(${t}>=${r})`,vector:(t,r)=>`vec4<u32>(${t}>=${r})`},void 0,void 0,9)},Di=e=>{ht(e,"LessOrEqual",{scalar:(t,r)=>`u32(${t}<=${r})`,vector:(t,r)=>`vec4<u32>(${t}<=${r})`},void 0,void 0,9)}});var rl,nl,ol,al,zi,Ui,Vi=j(()=>{"use strict";$e();je();ve();rl=e=>{if(!e||e.length<1)throw new Error("too few inputs");let t=e[0].dataType,r=e[0].dims.length;for(let o of e){if(o.dataType!==t)throw new Error("input tensors should be one type");if(o.dims.length!==r)throw new Error("input tensors should have the same shape")}},nl=(e,t)=>`\n  fn calculateInputIndex(index: u32) -> u32 {\n    let sizeInConcatAxis = array<u32, ${e}u>(${t});\n    for (var i: u32 = 0u; i < ${e}; i += 1u ) {\n      if (index < sizeInConcatAxis[i]) {\n        return i;\n      }\n    }\n    return ${e}u;\n  }`,ol=(e,t)=>{let r=e.length,o=[];for(let n=0;n<r;++n){let s=t.setByOffset("global_idx",e[n].getByIndices("indices"));r===1?o.push(s):n===0?o.push(`if (inputIndex == ${n}u) { ${s} }`):n===r-1?o.push(`else { ${s} }`):o.push(`else if (inputIndex == ${n}) { ${s} }`)}return o.join(`\n`)},al=(e,t)=>{let r=e[0].dims.slice();if(t>=r.length||t<-1*r.length)throw new Error("axis specified for concat doesn\'t match input dimensionality");let o=t<0?r.length+t:t,n=r.slice(0);for(let A=1;A<e.length;A++){let z=e[A].dims.slice();for(let R=0;R<r.length;R++)if(R===o)n[o]+=z[R];else if(r[R]!==z[R])throw new Error("non concat dimensions must match")}let s=U.size(n),u=new Array(e.length),l=new Array(e.length),a=e[0].dataType,p=0,h=[],g=[],b=[],w=[{type:"uint32",data:s}];for(let A=0;A<e.length;++A)p+=e[A].dims[o],u[A]=p,b.push(Re(e[A].dims.length)),g.push(b[A]?e[A].dims.length:e[A].dims),l[A]=M(`input${A}`,a,g[A]),h.push(b[A]?"rank":"dims"),w.push({type:"uint32",data:u[A]});for(let A=0;A<e.length;++A)b[A]&&w.push(...L(e[A].dims));let y=Re(n.length);y&&w.push(...L(n));let _=y?n.length:n,I=F("output",a,_),$=I.indicesGet("indices",o),x=Array.from(Array(u.length).keys()).map(A=>`uniforms.sizeInConcatAxis${A}`).join(","),E=A=>`\n\n  ${(()=>{A.registerUniform("outputSize","u32");for(let z=0;z<e.length;z++)A.registerUniform(`sizeInConcatAxis${z}`,"u32");return A.declareVariables(...l,I)})()}\n\n  ${nl(u.length,x)}\n\n  ${A.mainStart()}\n    ${A.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n    var indices = ${I.offsetToIndices("global_idx")};\n\n    let inputIndex = calculateInputIndex(${$});\n    if (inputIndex != 0u) {\n      let sizeInConcatAxis = array<u32, ${u.length}u>(${x});\n      ${$} -= sizeInConcatAxis[inputIndex - 1u];\n    }\n\n    ${ol(l,I)}\n  }`;return{name:"Concat",shaderCache:{hint:`${t}`,inputDependencies:h},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:w}),getShaderSource:E}},zi=(e,t)=>{rl(e.inputs),e.compute(al(e.inputs,t.axis))},Ui=e=>ge({axis:e.axis})});var gt,Qr,It=j(()=>{"use strict";$e();gt=(e,t)=>{switch(e.activation){case"Relu":return{activationFunction:"",applyActivation:`value = max(value, ${t}(0.0));`};case"Sigmoid":return{activationFunction:"",applyActivation:`value = (${t}(1.0) / (${t}(1.0) + exp(-value)));`};case"Clip":return{activationFunction:`const clip_min_=${t}(${e.clipMin});const clip_max_=${t}(${e.clipMax});`,applyActivation:"value = clamp(value, clip_min_, clip_max_);"};default:return{activationFunction:"",applyActivation:""}}},Qr=e=>{let t=e?.activation||"";if(t==="Clip"){let[r,o]=e?.activation_params||[Gr,Lr];return{activation:t,clipMax:o,clipMin:r,activationCacheKey:`${t}:${r},${o}`}}return{activation:t,activationCacheKey:t}}});var Ke,Xr,Jr=j(()=>{"use strict";Ke=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},Xr=e=>`\n      ${e?"value = value + getBiasByOutputCoords(coords);":""}\n      `});var en,Nn=j(()=>{"use strict";en=e=>`\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n}\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n    i32(${e}.x), i32(${e}.y), i32(${e}.z), 1));\n}\n`});var il,sl,mr,Ni,ul,fr,dl,tn,hr=j(()=>{"use strict";$e();ve();It();Jr();il=(e,t)=>e?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `,sl=(e,t)=>e?`\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\n        ${t===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${t===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}\n        }`:`\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${t===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}\n        }`,mr=(e,t,r="f32",o,n=!1,s=32,u=!1,l=32)=>{let a=t[1]*e[1],p=t[0]*e[0],h=n?a:s,g=n?s:a,b=h/t[0],w=s/t[1];if(!((n&&b===4&&e[1]===4||!n&&(b===3||b===4))&&h%t[0]===0&&s%t[1]===0&&e[0]===4))throw new Error(`If transposeA ${n} is true, innerElementSize ${b} and workPerThread[1] ${e[1]} must be 4.\n      Otherwise, innerElementSize ${b} must be 3 or 4.\n  tileAWidth ${h} must be divisible by workgroupSize[0]${t[0]}. tileInner ${s} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`\nvar<workgroup> mm_Asub: array<array<vec${b}<${r}>, ${h/b}>, ${g}>;\nvar<workgroup> mm_Bsub: array<array<vec4<${r}>, ${p/e[0]}>, ${s}>;\n\nconst rowPerThread = ${e[1]};\nconst colPerThread = ${e[0]};\nconst innerElementSize = ${b};\nconst tileInner = ${s};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n  let localRow = i32(localId.y);\n  let tileRow = localRow * rowPerThread;\n  let tileCol = i32(localId.x);\n\n  let globalRow =i32(globalId.y) * rowPerThread;\n  let globalCol = i32(globalId.x);\n  let batch = ${u?"0":"i32(globalId.z)"};\n  ${o?`let batchIndices = ${o.offsetToIndices("u32(batch)")};`:""}\n  let globalRowStart = i32(workgroupId.y) * ${a};\n\n  let numTiles = ${u?`${Math.ceil(l/s)}`:"(uniforms.dimInner - 1) / tileInner + 1"};\n  var kStart = ${u?`i32(globalId.z) * ${l}`:"0"};\n\n  var acc: array<vec4<${r}>, rowPerThread>;\n\n  // Loop over shared dimension.\n  let tileRowB = localRow * ${w};\n  for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let inputRow = tileRow + innerRow;\n          let inputCol = tileCol;\n          ${il(n,o)}\n      }\n\n      // Load one tile of B into local memory.\n      for (var innerRow = 0; innerRow < ${w}; innerRow = innerRow + 1) {\n          let inputRow = tileRowB + innerRow;\n          let inputCol = tileCol;\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${o?", batchIndices":""});\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\n          ${b===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}\n\n          ${sl(n,b)}\n      }\n\n      workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n  }\n}`},Ni=(e,t)=>e?`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              kStart + inputRow,\n              globalRowStart + inputCol${t?", batchIndices":""});\n            `:`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              globalRowStart + inputRow,\n              kStart + inputCol${t?", batchIndices":""});\n            `,ul=e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",fr=(e,t,r="f32",o,n=!1,s=32,u=!1,l=32,a=!1)=>{let p=e[1]*t[1],h=e[0]*t[0],g=n?p:s,b=n?s:p;if(!(b%t[1]===0&&g%t[0]===0&&s%t[1]===0))throw new Error(`tileAHight ${b} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${g} must be divisible by workgroupSize[0]${t[0]}, tileInner ${s} must be divisible by workgroupSize[1]${t[1]}`);let w=b/t[1],y=g/t[0],_=s/t[1],I=a?`\n    let localRow = i32(localId.y);\n    let localCol = i32(localId.x);\n    let globalRowStart = i32(workgroupId.y) * ${p};\n    let globalColStart = i32(workgroupId.x) * ${h};\n\n    // Loop over shared dimension.\n    for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var inputRow = localRow; inputRow < ${b}; inputRow = inputRow + ${t[1]}) {\n        for (var inputCol = localCol; inputCol < ${g}; inputCol = inputCol + ${t[0]}) {\n          ${Ni(n,o)}\n        }\n      }\n      // Load one tile of B into local memory.\n      for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${t[1]}) {\n            for (var inputCol = localCol; inputCol < ${h}; inputCol = inputCol + ${t[0]}) {\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n            kStart + inputRow,\n            globalColStart + inputCol${o?", batchIndices":""});\n        }\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      var BCached : array<${r}, colPerThread>;\n      for (var k = 0; k < tileInner; k = k + 1) {\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\n        }\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let ACached = ${n?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                ACached * BCached[innerCol];\n          }\n        }\n      }\n      workgroupBarrier();\n    }\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      let gRow = globalRowStart + localRow + innerRow * ${t[1]};\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        let gCol = globalColStart + localCol + innerCol * ${t[0]};\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n      }\n    }\n    `:`\nlet tileRow = i32(localId.y) * rowPerThread;\nlet tileCol = i32(localId.x) * colPerThread;\n\nlet globalRow = i32(globalId.y) * rowPerThread;\nlet globalCol = i32(globalId.x) * colPerThread;\nlet globalRowStart = i32(workgroupId.y) * ${p};\n\nlet tileRowA = i32(localId.y) * ${w};\nlet tileColA = i32(localId.x) * ${y};\nlet tileRowB = i32(localId.y) * ${_};\n// Loop over shared dimension.\nfor (var t = 0; t < numTiles; t = t + 1) {\n  // Load one tile of A into local memory.\n  for (var innerRow = 0; innerRow < ${w}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < ${y}; innerCol = innerCol + 1) {\n      let inputRow = tileRowA + innerRow;\n      let inputCol = tileColA + innerCol;\n      ${Ni(n,o)}\n    }\n  }\n\n  // Load one tile of B into local memory.\n  for (var innerRow = 0; innerRow < ${_}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n      let inputRow = tileRowB + innerRow;\n      let inputCol = tileCol + innerCol;\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n        kStart + inputRow,\n        globalCol + innerCol${o?", batchIndices":""});\n    }\n  }\n  kStart = kStart + tileInner;\n  workgroupBarrier();\n\n  // Compute acc values for a single thread.\n  var BCached : array<${r}, colPerThread>;\n  for (var k = 0; k < tileInner; k = k + 1) {\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\n    }\n\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      ${ul(n)}\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n      }\n    }\n  }\n\n  workgroupBarrier();\n}\n\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n        acc[innerRow][innerCol]);\n  }\n}\n`;return`\n  var<workgroup> mm_Asub : array<array<${r}, ${g}>, ${b}>;\n  var<workgroup> mm_Bsub : array<array<${r}, ${h}>, ${s}>;\n  const rowPerThread = ${e[1]};\n  const colPerThread = ${e[0]};\n  const tileInner = ${s};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n    let batch = ${u?"0":"i32(globalId.z)"};\n    ${o?`let batchIndices = ${o.offsetToIndices("u32(batch)")};`:""}\n    let numTiles = ${u?`${Math.ceil(l/s)}`:"(uniforms.dimInner - 1) / tileInner + 1"};\n    var kStart = ${u?`i32(globalId.z) * ${l}`:"0"};\n\n    var acc : array<array<${r}, colPerThread>, rowPerThread>;\n\n    // Without this initialization strange values show up in acc.\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = 0.0;\n      }\n    }\n    ${I}\n  }\n`},dl=(e,t,r,o,n,s=!1)=>{let[u,l,a]=n,[p,h,g,b]=o,w=Ft(u,a),y=Ft(l,a),_=Le(o[0].type.tensor),I=()=>{let E=h.rank,A=p.rank,z=`var aIndices: ${h.type.indices};`;for(let R=E-2-1,V=A-1;R>=0;R--,V--)z+=`\naIndices[${R}] = ${A>1?`batchIndices[${V}]`:"batchIndices"};`;return w.forEach(R=>{z+=`\naIndices[${R}] = 0;`}),z+=`\naIndices[${E-2}] = u32(row);\n                   aIndices[${E-1}] = u32(colIn);`,z},$=()=>{let E=g.rank,A=p.rank,z=`var bIndices: ${g.type.indices};`;for(let R=E-2-1,V=A-1;R>=0;R--,V--)z+=`\nbIndices[${R}] = ${A>1?`batchIndices[${V}]`:"batchIndices"};`;return y.forEach(R=>{z+=`\nbIndices[${R}] = 0;`}),z+=`\nbIndices[${E-2}] = u32(row);\n                   bIndices[${E-1}] = u32(colIn);`,z};return`\n    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${p.type.indices}) -> ${Ke(e,_)} {\n      var value = ${Ke(e,_)}(0.0);\n      let col = colIn * ${e};\n      if(row < uniforms.dimAOuter && col < uniforms.dimInner)\n      {\n        ${I()}\n        value = ${h.getByIndices("aIndices")};\n      }\n      return value;\n    }\n\n    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${p.type.indices}) -> ${Ke(e,_)} {\n      var value = ${Ke(e,_)}(0.0);\n      let col = colIn * ${e};\n      if(row < uniforms.dimInner && col < uniforms.dimBOuter)\n      {\n        ${$()}\n        value = ${g.getByIndices("bIndices")};\n      }\n      return value;\n    }\n\n    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${Ke(e,_)}) {\n      let col = colIn * ${e};\n      if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {\n        var value = valueIn;\n        let coords = vec3<i32>(batch, row, colIn);\n        ${t?`value = value + ${s?"bias[colIn]":`${Ke(e,_)}(bias[row])`};`:""}\n        ${r}\n        ${b.setByIndices("vec3<u32>(coords)","value")}\n      }\n    }\n    `},tn=(e,t,r,o,n=!1)=>{let s=e[0].dims,u=e[1].dims,l=s.slice(0,-2),a=u.slice(0,-2),p=o?o.slice(0,-2):r.slice(0,-2),h=Re(p.length),g=h?p.length:p,b=Fr("batchDims",e[0].dataType,g,1),w=U.size(p),y=s[s.length-2],_=s[s.length-1],I=u[u.length-1],$=_%4===0&&I%4===0,x=y<=8?[4,1,1]:[4,4,1],E=[8,8,1],A=[Math.ceil(I/E[0]/x[0]),Math.ceil(y/E[1]/x[1]),Math.ceil(w/E[2]/x[2])],z=Le(e[0].dataType),R=$?4:1,V=[...l,y,_/R],T=Re(V.length),N=T?V.length:V,te=[...a,_,I/R],Y=Re(te.length),K=Y?te.length:te,Q=[w,y,I/R],Z=M("a",e[0].dataType,N,R),Ee=M("b",e[1].dataType,K,R),Pe=F("result",e[0].dataType,Q.length,R),fe=[Z,Ee],Ie=[{type:"int32",data:y},{type:"int32",data:I},{type:"int32",data:_}];h&&Ie.push(...L(p)),T&&Ie.push(...L(V)),Y&&Ie.push(...L(te));let he=[];he.push(T?"rank":"dims"),he.push(Y?"rank":"dims");let ye=e.length>2,{activationFunction:We,applyActivation:De}=gt(t,Pe.type.value),Ge=dl(R,ye,De,[b,Z,Ee,Pe],[l,a,p],n);if(ye){let ee=n?R:1;fe.push(M("bias",e[2].dataType,e[2].dims.length,ee)),Ie.push(...L(e[2].dims)),he.push("rank")}Ie.push(...L(Q));let G=ee=>`\n  ${ee.registerUniform("dimAOuter","i32").registerUniform("dimBOuter","i32").registerUniform("dimInner","i32").registerInternalVariables(b).declareVariables(...fe,Pe)}\n  ${We}\n  ${Ge}\n  ${$?mr(x,E,z,b):fr(x,E,z,b)}\n                   `;return{name:"MatMul",shaderCache:{hint:t.activationCacheKey+`${x}${$}${n}`,inputDependencies:he},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:A[0],y:A[1],z:A[2]},programUniforms:Ie}),getShaderSource:G}}});var ll,Wi,Hi=j(()=>{"use strict";Ct();ve();It();Jr();Nn();hr();ll=(e,t,r,o,n=!1,s,u=4,l=4,a=4,p="f32")=>{let h=Y=>{switch(Y){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${p}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${Y} is not supported.`)}},g=Y=>{switch(Y){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw new Error(`innerElementSize ${Y} is not supported.`)}},b=e?`\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\n    `:`\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\n    `,w=e?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,y=e?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",_=e?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",I=e?"row":"col",$=e?"col":"row",x=`\n    let inChannels = i32(uniforms.w_shape[2]);\n    let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n    let outRow = ${I} / outWidth;\n    let outCol = ${I} % outWidth;\n\n    let WRow = ${$} / (filterDims[1] * inChannels);\n    let WCol = ${$} / inChannels % filterDims[1];\n    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];\n    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];\n    let xCh = ${$} % inChannels;\n    var resData = ${Ke(u,p)}(0.0);\n    // The bounds checking is always needed since we use it to pad zero for\n    // the \'same\' padding type.\n    if (xRow >= 0 && xRow < ${y} && xCol >= 0 && xCol < ${_}) {\n      ${b}\n      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));\n      ${h(u)}\n    }\n    return resData;`,E=e?t&&o?`\n    let col = colIn * ${u};\n    ${x}`:`\n    let col = colIn * ${u};\n    if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n      ${x}\n    }\n    return ${Ke(u,p)}(0.0);`:o&&r?`\n    let col = colIn * ${u};\n    ${x}`:`\n    let col = colIn * ${u};\n    if (row < uniforms.dimInner && col < uniforms.dimBOuter) {\n      ${x}\n    }\n    return ${Ke(u,p)}(0.0);`,A=`${g(l)}`,z=Ke(a,p),R=e?Ke(u,p):Ke(l,p),V=e?Ke(l,p):Ke(u,p),{activationFunction:T,applyActivation:N}=gt(s,z);return`\n    ${T}\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${R} {\n      ${e?E:A}\n    }\n\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${V} {\n      ${e?A:E}\n    }\n\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${z}) {\n      let col = colIn * ${a};\n      if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)\n      {\n      var value = valueIn;\n      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n      ${w}\n      ${Xr(n)}\n      ${N}\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n      }\n    }`},Wi=(e,t,r,o,n,s,u,l)=>{let a=t.format==="NHWC",p=a?e[0].dims[3]:e[0].dims[1],h=r[0],g=a?r[2]:r[3],b=a?r[1]:r[2],w=a?r[3]:r[1],y=a&&(p%4===0||p%3===0)&&w%4===0,_=a?w:g*b,I=a?g*b:w,$=[8,8,1],x=o<=8?[4,1,1]:[4,4,1],E=[Math.ceil(_/$[0]/x[0]),Math.ceil(I/$[1]/x[1]),Math.ceil(h/$[2]/x[2])];Be("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${E}`);let A=y?a&&p%4!==0?3:4:1,z=$[1]*x[1],R=$[0]*x[0],V=Math.max($[0]*A,$[1]),T=o%z===0,N=n%R===0,te=s%V===0,Y=y?[A,4,4]:[1,1,1],K=Le(e[0].dataType),Q=y?4:1,Z=[{type:"int32",data:o},{type:"int32",data:n},{type:"int32",data:s}],Ee=M("x",e[0].dataType,e[0].dims.length,A===3?1:A),Pe=M("w",e[1].dataType,e[1].dims.length,Q),fe=[Ee,Pe];Z.push(...L(e[0].dims)),Z.push(...L(e[1].dims));let Ie=`\n      fn setOutputAtIndex(flatIndex : i32, value : ${y?`vec4<${K}>`:K}) {\n        result[flatIndex] = ${y?`vec4<${K}>`:K}(value);\n      }\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${y?`vec4<${K}>`:K}) {\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\n        setOutputAtIndex(flatIndex ${y?"/ 4":""}, value);\n      }`;if(u){let ye=M("bias",e[2].dataType,e[2].dims.length,Q);fe.push(ye),Z.push(...L(e[2].dims)),Ie+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${y?`vec4<${K}>`:K} {\n          return bias[coords.${a?"w":"y"}${y?"/ 4":""}];\n        }`}let he=F("result",e[0].dataType,r.length,Q);return Z.push(...L(r)),{name:"Conv2DMatMul",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:E[0],y:E[1],z:E[2]},programUniforms:Z}),getShaderSource:ye=>`\n        ${en("uniforms.result_strides")}\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\n        ${ye.registerUniform("dimAOuter","i32").registerUniform("dimBOuter","i32").registerUniform("dimInner","i32").declareVariables(...fe,he)}\n        const filterDims : vec2<i32> = vec2<i32>(${t.kernelShape[0]}, ${t.kernelShape[1]});\n        const pad : vec2<i32> = vec2<i32>(${t.pads[0]}, ${t.pads[1]});\n        const stride : vec2<i32> = vec2<i32>(${t.strides[0]}, ${t.strides[1]});\n        const dilation : vec2<i32> = vec2<i32>(${t.dilations[0]}, ${t.dilations[1]});\n        ${Ie}\n        ${ll(a,T,N,te,u,t,Y[0],Y[1],Y[2],K)}\n            ${y?mr(x,$,K,void 0,!a,V):fr(x,$,K,void 0,!a,V,!1,void 0,l)}`}}});var Wn,Gi=j(()=>{"use strict";$e();ve();Gn();It();Wn=(e,t,r)=>{let o=e.length>2,n=o?"value += b[output_channel];":"",s=e[0].dims,u=e[1].dims,l=u[0]/t.group,a=t.format==="NHWC",p=Hn(s,u,t.dilations,t.pads,t.strides,a),h=U.size(p),g=F("output",e[0].dataType,p),{activationFunction:b,applyActivation:w}=gt(t,g.type.value),y=M("x",e[0].dataType,s),_=M("w",e[1].dataType,u),I=[y,_];o&&I.push(M("b",e[2].dataType,e[2].dims));let $=x=>`\n  const strides: vec2<u32> = vec2(${t.strides[0]}u, ${t.strides[1]}u);\n  const pads: vec2<u32> = vec2(${t.pads[0]}u, ${t.pads[1]}u);\n\n  ${x.declareVariables(...I,g)}\n\n  ${b}\n\n  ${x.mainStart()}\n    ${x.guardAgainstOutOfBoundsWorkgroupSizes(h)}\n\n    let outputIndices = ${g.offsetToIndices("global_idx")};\n    let batch: u32 = outputIndices[0];\n    let output_channel: u32 = outputIndices[${a?3:1}];\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${a?1:2}], outputIndices[${a?2:3}]) * strides - pads;\n    let group_id: u32 = output_channel / ${l}u;\n\n    var value: ${g.type.value} = ${g.type.value}(0);\n    for (var wInChannel: u32 = 0u; wInChannel < ${u[1]}u; wInChannel++) {\n      let input_channel = group_id * ${u[1]}u + wInChannel;\n      for (var wHeight: u32 = 0u; wHeight < ${u[2]}u; wHeight++) {\n        let xHeight = xRCCorner.x + wHeight * ${t.dilations[0]}u;\n\n        if (xHeight < 0u || xHeight >= ${s[a?1:2]}u) {\n          continue;\n        }\n\n        for (var wWidth: u32 = 0u; wWidth < ${u[3]}u; wWidth++) {\n          let xWidth = xRCCorner.y + wWidth * ${t.dilations[1]}u;\n          if (xWidth < 0u || xWidth >= ${s[a?2:3]}u) {\n            continue;\n          }\n\n          let xVal = ${a?y.get("batch","xHeight","xWidth","input_channel"):y.get("batch","input_channel","xHeight","xWidth")};\n          let wVal = ${_.get("output_channel","wInChannel","wHeight","wWidth")};\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${n}\n    ${w}\n    ${g.setByOffset("global_idx","value")}\n  }`;return{name:"GroupedConv",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r?r(p):p,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)}}),getShaderSource:$}}});var Ln,cl,Li,Fn=j(()=>{"use strict";$e();hr();ve();It();Ln=(e,t,r,o,n=!1)=>{let s=e[0].dims,u=e[1].dims,l=s[s.length-2],a=u[u.length-1],p=s[s.length-1],h=Fe(a),g=Fe(p),b=Fe(l),w=U.size(r)/h/b,y=e.length>2,_=o?o.slice(0,-2):r.slice(0,-2),$=[U.size(_),l,a],x=[{type:"uint32",data:w},{type:"uint32",data:l},{type:"uint32",data:a},{type:"uint32",data:p},...L(_),...L(s),...L(u)];y&&x.push(...L(e[2].dims)),x.push(...L($));let E=A=>{let z=Fr("batch_dims",e[0].dataType,_.length),R=M("a",e[0].dataType,s.length,g),V=M("b",e[1].dataType,u.length,h),T=F("output",e[0].dataType,$.length,h),{activationFunction:N,applyActivation:te}=gt(t,T.type.value),Y=[R,V],K="";if(y){let he=n?h:1;Y.push(M("bias",e[2].dataType,e[2].dims.length,he)),K=`${n?`value += bias[col / ${he}];`:`value += ${T.type.value}(bias[row + i]);`}`}let Q=s.slice(0,-2),Z=u.slice(0,-2),Ee=Ft(Q,_),Pe=Ft(Z,_),fe=(he,ye)=>{let We=he.rank,De=he.name;if(We===2)return`var ${De}_indices = ${he.type.indices}(0u, 0u);`;let Ge=z.rank,G=`var ${De}_indices: ${he.type.indices};`;for(let ee=We-2-1,be=Ge-1;ee>=0;ee--,be--)G+=`\n${De}_indices[${ee}] = ${Ge>1?`batch_indices[${be}]`:"batch_indices"};`;return ye.forEach(ee=>{G+=`\n${De}_indices[${ee}] = 0;`}),G+=`${De}_indices[${We-2}] = 0u;\n                     ${De}_indices[${We-1}] = 0u;`,G},Ie=()=>{let he=`var a_data: ${R.type.value};`;for(let ye=0;ye<g;ye++)he+=`\n              let b_data${ye} = b[(b_offset + (k + ${ye}) * uniforms.N + col) / ${h}];`;for(let ye=0;ye<b;ye++){he+=`a_data = a[(a_offset + (row + ${ye}) * uniforms.K + k) / ${g}];`;for(let We=0;We<g;We++)he+=`\n            values[${ye}] = fma(${V.type.value}(a_data${g===1?"":`[${We}]`}), b_data${We}, values[${ye}]);\n`}return he};return`\n  ${A.registerUniform("outputSize","u32").registerUniform("M","u32").registerUniform("N","u32").registerUniform("K","u32").registerInternalVariables(z).declareVariables(...Y,T)}\n  ${N}\n  ${A.mainStart()}\n    ${A.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n    let col = (global_idx % (uniforms.N / ${h})) * ${h};\n    var index1 = global_idx / (uniforms.N / ${h});\n    let stride1 = uniforms.M / ${b};\n    let row = (index1 % stride1) * ${b};\n    let batch = index1 / stride1;\n\n    ${r.length===2?"":`let batch_indices = ${z.offsetToIndices("batch")};`}\n    ${fe(R,Ee)}\n    let a_offset = ${R.indicesToOffset("a_indices")};\n    ${fe(V,Pe)}\n    let b_offset = ${V.indicesToOffset("b_indices")};\n    var values: array<${T.type.value}, ${b}>;\n    for (var k: u32 = 0u; k < uniforms.K; k = k + ${g}) {\n      ${Ie()}\n    }\n    for (var i = 0u; i < ${b}u; i++) {\n      var value = values[i];\n      ${K}\n      ${te}\n      let cur_indices = ${T.type.indices}(batch, row + i, col);\n      let offset = ${T.indicesToOffset("cur_indices")};\n      ${T.setByOffset(`offset / ${h}`,"value")};\n    }\n  }\n  `};return{name:"MatMulNaive",shaderCache:{hint:`${t.activationCacheKey}_${h}_${g}_${b}_${n}`,inputDependencies:y?["rank","rank","rank"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(w/64)},programUniforms:x}),getShaderSource:E}},cl=e=>{if(!e||e.length!==2)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.")},Li=e=>{cl(e.inputs);let t=dt.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error("Can\'t use matmul on the given tensors");let r=t[t.length-1],o=e.inputs[0].dims[e.inputs[0].dims.length-1];r<8&&o<8?e.compute(Ln(e.inputs,{activation:"",activationCacheKey:""},t)):e.compute(tn(e.inputs,{activation:"",activationCacheKey:""},t))}});var Hn,Fi,pl,ji,jn,ml,fl,qn,Gn=j(()=>{"use strict";$e();je();Hi();hr();Gi();It();Fn();jt();Hn=(e,t,r,o,n,s)=>{let u=e[0],l=e.slice(s?1:2,s?3:4),a=l.length,p=t[0],g=t.slice(2).map((y,_)=>y+(y-1)*(r[_]-1)),w=l.map((y,_)=>y+o[_]+o[_+a]).map((y,_)=>Math.floor((y-g[_]+n[_])/n[_]));return w.splice(0,0,u),w.splice(s?3:1,0,p),w},Fi=[2,3,1,0],pl=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support conv 1D and 2D");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],o=e[1].dims[1]*t.group;if(r!==o)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(e.length===3&&(e[2].dims.length!==1||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let n=e[0].dims.length-2;if(t.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(t.strides.length!==n)throw new Error(`strides should be ${n}D`);if(t.pads.length!==n*2)throw new Error(`pads should be ${n*2}D`);if(t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape")},ji=(e,t)=>{let r=e.kernelShape.slice();for(let s=2;s<t[1].dims.length;++s)r[s-2]===0&&(r[s-2]=t[1].dims[s]);let o=e.pads.slice();Bt.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,r,o,e.format==="NHWC",e.autoPad);let n=Object.assign({},e);return Object.assign(n,{kernelShape:r,pads:o,cacheKey:e.cacheKey}),n},jn=e=>{let t=Qr(e),r=e.format,o=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],n=e.dilations,s=e.group,u=e.kernel_shape,l=e.pads,a=e.strides,p=e.w_is_const();return ge({autoPad:o,format:r,dilations:n,group:s,kernelShape:u,pads:l,strides:a,wIsConst:p,...t})},ml=(e,t,r)=>{let o=ji(r,t),n=r.format==="NHWC";if(r.group!==1){e.compute(Wn(t,o));return}let s=t.length===3,u=t[0].dims[n?1:2],l=t[0].dims[n?2:3],a=t[0].dims[n?3:1],p=t[1].dims[2],h=t[1].dims[3],g=Hn(t[0].dims,t[1].dims,r.dilations,o.pads,r.strides,n),b=g[n?1:2],w=g[n?2:3],y=g[n?3:1],_=n&&p===u&&h===l&&r.pads[0]===0&&r.pads[1]===0;if(_||p===1&&h===1&&r.dilations[0]===1&&r.dilations[1]===1&&r.strides[0]===1&&r.strides[1]===1&&r.pads[0]===0&&r.pads[1]===0){let R=g[0],V,T,N,te=[];if(n){let Q=e.kernelCustomData.wT??e.compute(it(t[1],Fi),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];if(r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=Q),_){let Z=u*l*a;V=t[0].reshape([1,R,Z]),T=Q.reshape([1,Z,y]),N=[1,R,y]}else V=t[0].reshape([R,u*l,a]),T=Q.reshape([1,a,y]),N=[R,b*w,y];te.push(V),te.push(T)}else V=t[0].reshape([R,a,u*l]),T=t[1].reshape([1,y,a]),N=[R,y,b*w],te.push(T),te.push(V);s&&te.push(t[2]);let Y=N[2],K=te[0].dims[te[0].dims.length-1];Y<8&&K<8?e.compute(Ln(te,o,g,N,n),{inputs:te}):e.compute(tn(te,o,g,N,n),{inputs:te});return}let I=!0,$=e.kernelCustomData.wT??e.compute(it(t[1],Fi),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=$);let x=[t[0],$];s&&x.push(t[2]);let E=n?b*w:y,A=n?y:b*w,z=p*h*a;e.compute(Wi(x,o,g,E,A,z,s,I),{inputs:x})},fl=(e,t)=>{let r=t.format==="NHWC",o=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&o.push(e.inputs[2]);let n=[0,t.pads[0],0,t.pads[1]],s=[1].concat(t.strides),u=[1].concat(t.dilations),l=[1].concat(t.kernelShape),a=ji({...t,pads:n,strides:s,dilations:u,kernelShape:l},o);e.compute(Wn(o,a,p=>r?[p[0],p[2],p[3]]:[]))},qn=(e,t)=>{pl(e.inputs,t),e.inputs[0].dims.length===3?fl(e,t):ml(e,e.inputs,t)}});var hl,qi,Ki=j(()=>{"use strict";Ct();ve();It();Jr();Nn();hr();hl=(e,t=!1,r,o=4)=>{let n=Ke(o,"f32"),s=x=>{switch(x){case 1:return"return w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];";case 4:return`\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];\n            let v1 = w[getIndexFromCoords4D(coord1, vec4<i32>(uniforms.w_shape))];\n            let v2 = w[getIndexFromCoords4D(coord2, vec4<i32>(uniforms.w_shape))];\n            let v3 = w[getIndexFromCoords4D(coord3, vec4<i32>(uniforms.w_shape))];\n            return vec4<f32>(v0, v1, v2, v3);\n            `;default:throw new Error(`innerElementSize ${x} is not supported.`)}},u=e?`\n      let coord = vec4<i32>(batch, iXR, iXC, xCh);\n      `:`\n      let coord = vec4<i32>(batch, xCh, iXR, iXC);\n      `,l=e?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,a=e?"outBackprop[1]":"outBackprop[2]",p=e?"outBackprop[2]":"outBackprop[3]",h=e?"row":"col",g=e?"col":"row",b=`\n      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};\n      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n      let outRow = ${h} / outWidth;\n      let outCol = ${h} % outWidth;\n\n      let WRow = ${g} / (filterDims[1] * inChannels);\n      let WCol = ${g} / inChannels % filterDims[1];\n      let xR = f32(outRow - pads[0] + dilation[0] * WRow) / f32(strides[0]);\n      let xC = f32(outCol - pads[1] + dilation[1] * WCol) / f32(strides[1]);\n      if (xR < 0.0 || xR >= f32(${a}) || fract(xR) > 0.0) {\n        return ${n}(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(${p}) || fract(xC) > 0.0) {\n        return ${n}(0.0);\n      }\n      let iXR = i32(xR);\n      let iXC = i32(xC);\n      let xCh = ${g} % inChannels;\n      ${u}\n      return x[getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape))/${o}];`,w=e?`\n      let col = colIn * ${o};\n      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n        ${b}\n      }\n      return ${n}(0.0);`:`\n      let col = colIn * ${o};\n      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {\n        ${b}\n      }\n      return ${n}(0.0);`,y=`\n      let col = colIn * ${o};\n      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};\n      let coordX = filterDims.x - 1 - row / (filterDims[1] * inChannels);\n      let coordY = filterDims.y - 1 - (row / inChannels) % filterDims[1];\n      if (${e?"row < uniforms.dimInner && col < uniforms.dimBOuter":"row < uniforms.dimInner && col < uniforms.dimAOuter"}  && coordX >= 0 && coordY >= 0) {\n        let rowInner = row % inChannels;\n        let coord = vec4<i32>(coordX, coordY, col, rowInner);\n        ${s(o)}\n      }\n      return ${n}(0.0);\n      `,{activationFunction:_,applyActivation:I}=gt(r,n);return`\n      ${_}\n  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${n} {\n    ${e?w:y}\n  }\n\n  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${n} {\n    ${e?y:w}\n  }\n\n  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${n}) {\n    let col = colIn * ${o};\n    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {\n      var value = valueInput;\n      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n      ${l}\n      ${Xr(t)}\n      ${I}\n      result[getIndexFromCoords4D(coords, vec4<i32>(uniforms.result_shape))/${o}] = value;\n    }\n  }`},qi=(e,t,r,o,n,s,u,l)=>{let a=t.format==="NHWC",p=a?e[0].dims[3]:e[0].dims[1],h=r[0],g=a?r[2]:r[3],b=a?r[1]:r[2],w=a?r[3]:r[1],y=a?p%4===0&&w%4===0:g%4===0&&w%4===0,_=a?w:g*b,I=a?g*b:w,$=y?[8,8,1]:[_<=4||I<=4?4:16,_>4&&I<=4?4:16,1],x=y?[4,4,1]:[_<=4?1:4,_>4&&I<=4?1:4,1],E=[Math.ceil(_/$[0]/x[0]),Math.ceil(I/$[1]/x[1]),Math.ceil(h/$[2]/x[2])];Be("verbose",()=>`[conv_backprop_mm_webgpu] dispatch = ${E}`);let A=y?4:1,z=Math.max($[0]*A,$[1]),R=y?4:1,V=[{type:"int32",data:o},{type:"int32",data:n},{type:"int32",data:s}],T=M("x",e[0].dataType,e[0].dims.length,R),N=M("w",e[1].dataType,e[1].dims.length,1),te=F("result",e[0].dataType,r.length,R),Y=[T,N];V.push(...L(e[0].dims)),V.push(...L(e[1].dims));let K="";if(u){let Q=M("bias",e[2].dataType,e[2].dims.length,R);Y.push(Q),V.push(...L(e[2].dims)),K+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${y?"vec4<f32>":"f32"} {\n          return bias[coords.${a?"w":"y"}${y?"/ 4":""}];\n        }`}return V.push(...L(r)),{name:"Conv2DTransposeMatMul",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:E[0],y:E[1],z:E[2]},programUniforms:V}),getShaderSource:Q=>`\n        ${en("uniforms.result_strides")}\n        ${Q.registerUniform("dimAOuter","i32").registerUniform("dimBOuter","i32").registerUniform("dimInner","i32").declareVariables(...Y,te)};\n        const outBackprop : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\n        const filterDims : vec2<i32> = vec2<i32>(${t.kernelShape[a?1:2]}, ${t.kernelShape[a?2:3]});\n        const effectiveFilterDims : vec2<i32> = filterDims + vec2<i32>(\n              ${t.dilations[0]<=1?0:(t.kernelShape[a?1:2]-1)*(t.dilations[0]-1)},\n              ${t.dilations[1]<=1?0:(t.kernelShape[a?2:3]-1)*(t.dilations[1]-1)});\n        const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${t.pads[0]+t.pads[2]})/2,\n                                         i32(effectiveFilterDims[1]) - 1 - (${t.pads[1]+t.pads[3]})/2);\n        const strides : vec2<i32> = vec2<i32>(${t.strides[0]}, ${t.strides[1]});\n        const dilation : vec2<i32> = vec2<i32>(${t.dilations[0]}, ${t.dilations[1]});\n        const dimAOuter : i32 = ${o};\n        const dimBOuter : i32 = ${n};\n        const dimInner : i32 = ${s};\n        ${K}\n        ${hl(a,u,t,A)}\n        ${y?mr(x,$,"f32",void 0,!a,z):fr(x,$,"f32",void 0,!a,z,!1,void 0,l)}`}}});var gl,Kn,Yi=j(()=>{"use strict";Ct();$e();ve();gl=(e,t,r,o,n,s,u=!1,l)=>{let a=r.format==="NHWC",p=a?1:2,h=a?2:3,g=a?3:1,b=U.size(o),w=u?2:1,y=r.group,_=t[1].dims,I=_[0]/y,$=_[1],x=`\n  fn setOutputAtIndex(flatIndex : u32, value : ${u?`vec4<${l}>`:l}) {\n    result[flatIndex] = ${u?`vec4<${l}>`:l}(value);\n  }`;n&&(x+=`\n    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${u?`vec4<${l}>`:l} {\n      return bias[coords.${a?"w":"y"}${u?"/ 4":""}];\n    }`);let E=u?4:1,A=M("W",t[1].dataType,t[1].dims,E),z=M("Dy",t[0].dataType,t[0].dims,E),R=[z,A];n&&R.push(M("bias",t[2].dataType,[o[g]],E));let V=F("result",t[0].dataType,o,E),T=`{\n        let batch: u32 = ${s?"global_id.z":"workgroup_id.z"} / outShape[1];\n        let r = ${s?"global_id.z":"workgroup_id.z"} % outShape[1];\n        let c = ${s?"global_id.y":"workgroup_id.y"} * ${w};\n        let d1: u32 = ${s?"global_id.x":"workgroup_id.x"} * 4;\n\n        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(pads);\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd: array<vec4<${l}>, ${w}>;\n        for (var i = 0; i < ${w}; i++) {\n          dotProd[i] = vec4<${l}>(0.0);\n        }\n        for (var wR: u32 = 0; wR < filterDims[0]; wR = wR + 1) {\n          var dyR = (${l}(dyCorner.x) + ${l}(wR)) / ${l}(strides.x);\n          let wRPerm = filterDims[0] - 1 - wR;\n          if (dyR < 0.0 || dyR >= ${l}(outBackprop[1]) ||\n              fract(dyR) > 0.0 || wRPerm < 0) {\n            continue;\n          }\n          let idyR: u32 = u32(dyR);\n\n          for (var wC: u32 = 0; wC < filterDims[1]; wC = wC + 1) {\n            let dyC = (${l}(dyCorner.y) + ${l}(wC)) / ${l}(strides.y);\n            let dyC2 = (${l}(dyCorner.y) + 1.0 + ${l}(wC)) / ${l}(strides.y);\n            let wCPerm = filterDims[1] - 1 - wC;\n            if (wCPerm < 0) {\n              continue;\n            }\n            var bDyCVal = true;\n            var bDyCVal2 = true;\n            if (dyC < 0.0 || dyC >= ${l}(outBackprop[2]) ||\n                fract(dyC) > 0.0) {\n              bDyCVal = false;\n            }\n            if (dyC2 < 0.0 || dyC2 >= ${l}(outBackprop[2]) ||\n                fract(dyC2) > 0.0) {\n              bDyCVal2 = false;\n            }\n\n            let idyC: u32 = u32(dyC);\n            let idyC2: u32 = u32(dyC2);\n            if (bDyCVal && bDyCVal2) {\n              let d2Length = outBackprop[3];\n              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${A.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${A.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${A.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${A.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${z.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${l}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n\n                xValue =  ${z.get("batch","idyR","idyC2","d2")};\n\n                dotProd[1] = dotProd[1] + vec4<${l}>(dot(xValue, wValue0),\n                                                    dot(xValue, wValue1),\n                                                    dot(xValue, wValue2),\n                                                    dot(xValue, wValue3));\n              }\n            } else if (bDyCVal) {\n              let d2Length = outBackprop[${g}];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${A.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${A.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${A.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${A.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${z.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${l}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n              }\n            } else if (bDyCVal2) {\n              let d2Length = outBackprop[3];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${A.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${A.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${A.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${A.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${z.get("batch","idyR","idyC2","d2")};\n                let tmpval = vec4<${l}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[1] = dotProd[1] + tmpval;\n              }\n            }\n          }\n        }\n\n        for (var i: u32 = 0; i < ${w}; i = i + 1) {\n          let value = dotProd[i] + ${n?"bias[c+i]":`vec4<${l}>(0.0)`};\n          ${V.set("batch","r","c + i","d1","value")};\n        }\n      }`,N=`\n          let outputIndices = ${V.offsetToIndices("global_idx")};\n          let batch = ${V.indicesGet("outputIndices",0)};\n          let d1 = ${V.indicesGet("outputIndices",g)};\n          let r = ${V.indicesGet("outputIndices",p)};\n          let c = ${V.indicesGet("outputIndices",h)};\n          let dyCorner = vec2<i32>(i32(r), i32(c)) - pads;\n          let dyRCorner = dyCorner.x;\n          let dyCCorner = dyCorner.y;\n          let groupId = d1 / ${$};\n          let wOutChannel = d1 - groupId * ${$};\n          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n          // ? = to be determined. : = across all values in that axis.\n          var dotProd = ${l}(0.0);\n          for (var wR: u32 = 0; wR < effectiveFilterDims.x; wR = wR + 1) {\n            if (wR % dilations.x != 0) {\n              continue;\n            }\n            let dyR = (${l}(dyRCorner) + ${l}(wR)) / ${l}(strides[0]);\n            let wRPerm = filterDims.x - 1 - wR / dilations.x;\n            if (dyR < 0.0 || dyR >= ${l}(outBackprop[${p}]) || fract(dyR) > 0.0 ||\n                wRPerm < 0) {\n              continue;\n            }\n            let idyR: u32 = u32(dyR);\n\n            for (var wC: u32 = 0; wC < effectiveFilterDims.y; wC = wC + 1) {\n              if (wC % dilations.y != 0) {\n                continue;\n              }\n              let dyC = (${l}(dyCCorner) + ${l}(wC)) / ${l}(strides.y);\n              let wCPerm = filterDims.y - 1 - wC / dilations.y;\n              if (dyC < 0.0 || dyC >= ${l}(outBackprop[${h}]) ||\n                  fract(dyC) > 0.0 || wCPerm < 0) {\n                continue;\n              }\n              let idyC: u32 = u32(dyC);\n              var inputChannel = groupId * ${I};\n              for (var d2: u32 = 0; d2 < ${I}; d2 = d2 + 1) {\n                let xValue = ${a?z.get("batch","idyR","idyC","inputChannel"):z.get("batch","inputChannel","idyR","idyC")};\n                let wValue = ${A.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};\n                dotProd = dotProd + xValue * wValue;\n                inputChannel = inputChannel + 1;\n              }\n            }\n          }\n          let value = dotProd + ${n?"bias[d1]":`${l}(0.0)`};\n          ${V.setByOffset("global_idx","value")};\n        `;return`\n  ${e.declareVariables(...R,V)}\n  ${x}\n  const outShape : vec4<u32> = vec4<u32>(${o.join(",")});\n  const outBackprop : vec4<u32> = vec4<u32>(${t[0].dims.join(",")});\n  const strides : vec2<u32> = vec2<u32>(${r.strides[0]}, ${r.strides[1]});\n  const filterDims : vec2<u32> = vec2<u32>(${r.kernelShape[a?1:2]}, ${r.kernelShape[a?2:3]});\n  const dilations : vec2<u32> = vec2<u32>(${r.dilations[0]}, ${r.dilations[1]});\n  const effectiveFilterDims : vec2<u32> = filterDims + vec2<u32>(\n          ${r.dilations[0]<=1?0:(r.kernelShape[a?1:2]-1)*(r.dilations[0]-1)},\n          ${r.dilations[1]<=1?0:(r.kernelShape[a?2:3]-1)*(r.dilations[1]-1)});\n  const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${r.pads[0]+r.pads[2]})/2,\n                                     i32(effectiveFilterDims[1]) - 1 - (${r.pads[1]+r.pads[3]})/2);\n    ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(b)};\n  ${u?T:N}}`},Kn=(e,t,r)=>{let o=e.length>2,n=t.outputShape,s=U.size(n),u=[Math.ceil(s/64),1,1];Be("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${u}`);let l=Le(e[0].dataType);return{name:"ConvTranspose2D",shaderCache:{hint:t.cacheKey},getRunData:()=>({dispatchGroup:{x:u[0],y:u[1],z:u[2]},outputs:[{dims:r?r(n):n,dataType:e[0].dataType}]}),getShaderSource:a=>gl(a,e,t,n,o,u[1]===1&&u[2]===1,!1,l)}}});var yl,bl,wl,Zi,Qi,vl,$l,Sl,xl,Xi,Ji=j(()=>{"use strict";je();Ki();Yi();It();jt();yl=(e,t,r,o,n,s)=>(e-1)*t+r+(o-1)*n+1-s,bl=(e,t,r,o,n)=>{let s=Math.floor(e/2);t==="SAME_UPPER"?(r[o]=s,r[n]=e-s):t==="SAME_LOWER"&&(r[o]=e-s,r[n]=s)},wl=(e,t,r,o,n,s,u,l,a,p)=>{let h=e.length-2,g=p.length===0;if(a.length===0)for(let y=0;y<h;++y)a.push(0);let b=e[0],w=t[l?3:1]*n;for(let y=0,_=e.length-h-(l?1:0);y<h;++y,++_){let I=e[_],$=g?I*u[y]:p[y],x=yl(I,u[y],s[y],t[_],r[y],$);bl(x,o,s,y,y+h),g&&p.push(u[y]*(I-1)+a[y]+(t[_]-1)*r[y]+1-s[y]-s[y+h])}p.splice(0,0,b),p.splice(l?3:1,0,w)},Zi=(e,t)=>{let r=e.kernelShape.slice();if(e.kernelShape.length===0||e.kernelShape.reduce((b,w)=>b*w,1)===0){r.length=0;for(let b=2;b<t[1].dims.length;++b)r.push(t[1].dims[b])}let o=e.format==="NHWC";r.splice(0,0,t[1].dims[0]),r.splice(o?3:1,0,t[1].dims[1]);let n=e.pads.slice(),s=e.outputShape.slice(),u=e.outputPadding.slice(),l=t[0].dims,a=e.dilations.slice();if(a.reduce((b,w)=>b+w,0)===0){let b=t[0].dims.length-2;a=new Array(b).fill(1)}let p=e.strides.slice();if(p.reduce((b,w)=>b+w,0)===0){let b=t[0].dims.length-2;p=new Array(b).fill(1)}wl(l,r,a,e.autoPad,e.group,n,p,o,u,s);let h=Object.assign({},e),g=e.cacheKey+[r.join("n,"),n.join(","),p.join(","),u.join(","),s.join(","),a.join(",")].join("_");return Object.assign(h,{kernelShape:r,pads:n,outputPadding:u,outputShape:s,dilations:a,strides:p,cacheKey:g}),h},Qi=e=>{let t=Qr(e),r=e.format,o=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof e.autoPad>"u"?0:e.autoPad],n=e.dilations,s=e.group,u=e.kernelShape,l=e.pads,a=e.strides,p=e.wIsConst(),h=e.outputPadding,g=e.outputShape;return ge({autoPad:o,format:r,dilations:n,group:s,kernelShape:u,outputPadding:h,outputShape:g,pads:l,strides:a,wIsConst:p,...t})},vl=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],o=e[1].dims[0];if(r!==o)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let n=e[1].dims[1]*t.group;if(e.length===3&&(e[2].dims.length!==1||e[2].dims[0]!==n))throw new Error("invalid bias");let s=e[0].dims.length-2;if(t.dilations.reduce((h,g)=>h+g,0)>0&&t.dilations.length!==s)throw new Error(`dilations should be ${s}D`);if(t.strides.reduce((h,g)=>h+g,0)>0&&t.strides.length!==s)throw new Error(`strides should be ${s}D`);if(t.pads.reduce((h,g)=>h+g,0)>0&&t.pads.length!==s*2)throw new Error(`pads should be ${s*2}D`);if(t.outputPadding.length!==s&&t.outputPadding.length!==0)throw new Error(`output_padding should be ${s}D`);if(t.kernelShape.reduce((h,g)=>h+g,0)>0&&t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(t.outputShape.length!==0&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape")},$l=[2,3,1,0],Sl=(e,t,r)=>{let o=Zi(r,t),n=r.format==="NHWC",s=o.outputShape,u=s[n?3:1],l=t[0].dims[n?3:1];if(o.group!==1||u===1&&l===1){e.compute(Kn(t,o));return}let a=s[n?1:2],p=s[n?2:3],h=t[1].dims[2],g=t[1].dims[3],b=n?a*p:u,w=n?u:a*p,y=h*g*l,_=!0,I=e.kernelCustomData.wT??e.compute(it(t[1],$l),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=I);let $=[t[0],I],x=t.length===3;x&&(!n&&t[2].dims.length===1?$.push(t[2].reshape([t[2].dims[0],1,1])):$.push(t[2])),e.compute(qi($,o,s,b,w,y,x,_),{inputs:$})},xl=(e,t)=>{let r=t.format==="NHWC",o=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];o.length===3&&o.push(e.inputs[2]);let n=t.kernelShape;(n.length===0||n[0]===0)&&(n=[e.inputs[1].dims[2]]);let s=t.dilations;(s.length===0||s[0]===0)&&(s=[1]);let u=t.strides;(u.length===0||u[0]===0)&&(u=[1]);let l=t.pads;l.length===0&&(l=[0,0]),l=[0,l[0],0,l[1]],u=[1].concat(u),s=[1].concat(s),n=[1].concat(n);let a=Zi({...t,pads:l,strides:u,dilations:s,kernelShape:n},o);e.compute(Kn(o,a,p=>r?[p[0],p[2],p[3]]:[p[0],p[1],p[3]]))},Xi=(e,t)=>{vl(e.inputs,t),e.inputs[0].dims.length===3?xl(e,t):Sl(e,e.inputs,t)}});var _l,es,ts,rs=j(()=>{"use strict";Ne();$e();je();ve();_l=(e,t,r,o)=>{let n=U.size(t),s=t.length,u=M("input",e,s),l=F("output",e,s),a=r.dataType===6?r.getInt32Array()[0]:Number(r.getBigInt64Array()[0]),p=U.normalizeAxis(a,s),h=g=>{let b=` i32(${u.indicesGet("inputIndices","uniforms.axis")}) `,w=ce("uniforms.input_shape","uniforms.axis",s),y=o.reverse?b+(o.exclusive?" + 1":""):"0",_=o.reverse?w:b+(o.exclusive?"":" + 1");return`\n                ${g.registerUniform("outputSize","u32").registerUniform("axis","u32").declareVariables(u,l)}\n                ${g.mainStart()}\n                  ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n                  var inputIndices = ${l.offsetToIndices("global_idx")};\n                  var sum = ${l.type.value}(0);\n                  let first : i32 = ${y};\n                  let last : i32 = ${_};\n                  for (var i : i32 = first; i < last; i++) {\n                    ${u.indicesSet("inputIndices","uniforms.axis","u32(i)")};\n                    sum = sum + ${u.getByIndices("inputIndices")};\n                  }\n                  ${l.setByOffset("global_idx","sum")};\n                }`};return{name:"CumSum",shaderCache:{hint:o.cacheKey,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:t,dataType:e}],dispatchGroup:{x:Math.ceil(n/64)},programUniforms:[{type:"uint32",data:n},{type:"int32",data:p},...L(t),...L(t)]}),getShaderSource:h}},es=(e,t)=>{let r=e.inputs[0].dims,o=e.inputs[0].dataType,n=e.inputs[1];e.compute(_l(o,r,n,t),{inputs:[0]})},ts=e=>{let t=e.exclusive===1,r=e.reverse===1;return ge({exclusive:t,reverse:r})}});var Yn,rn,ns,Cl,Il,Zn,Qn,os,Al,as,is,ss=j(()=>{"use strict";$e();je();ve();Yn="[a-zA-Z]|\\\\.\\\\.\\\\.",rn="("+Yn+")+",ns="^"+rn+"$",Cl="("+rn+",)*"+rn,Il="^"+Cl+"$",Zn=class{constructor(t=-1){this.symbolToIndices=new Map,this.inputIndex=t}addSymbol(t,r){let o=this.symbolToIndices.get(t);o===void 0?o=[r]:o.push(r),this.symbolToIndices.set(t,o)}},Qn=class{constructor(t,r){this.equation=r;this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[o,n]=r.includes("->")?r.split("->",2):[r,""];if(!o.match(RegExp(Il)))throw new Error("Invalid LHS term");if(o.split(",").forEach((l,a)=>{let p=t[a].dims.slice();if(!l.match(RegExp(ns)))throw new Error("Invalid LHS term");let h=this.processTerm(l,!0,p,a);this.lhs.push(h)}),n==="")n+=[...this.symbolToInfo.entries()].filter(([l,a])=>a.count===1||l==="...").map(([l])=>l).join("");else if(!n.match(RegExp(rn)))throw new Error("Invalid RHS");n.match(RegExp(Yn,"g"))?.forEach(l=>{if(l==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let a=this.symbolToInfo.get(l);if(a===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(a.dimValue)}}),this.rhs=this.processTerm(n,!1,this.outputDims)}addSymbol(t,r,o){let n=this.symbolToInfo.get(t);if(n!==void 0){if(n.dimValue!==r&&n.count!==1)throw new Error("Dimension mismatch");n.count++,n.inputIndices.push(o)}else n={count:1,dimValue:r,inputIndices:[o]};this.symbolToInfo.set(t,n)}processTerm(t,r,o,n=-1){let s=o.length,u=!1,l=[],a=0;if(!t.match(RegExp(ns))&&!r&&t!=="")throw new Error("Invalid LHS term");let p=t.match(RegExp(Yn,"g")),h=new Zn(n);return p?.forEach((g,b)=>{if(g==="..."){if(u)throw new Error("Only one ellipsis is allowed per input term");u=!0;let w=s-p.length+1;if(w<0)throw new Error("Ellipsis out of bounds");if(l=o.slice(a,a+w),this.hasEllipsis){if(this.ellipsisDims.length!==l.length||this.ellipsisDims.toString()!==l.toString())throw new Error("Ellipsis dimensions mismatch")}else if(r)this.hasEllipsis=!0,this.ellipsisDims=l;else throw new Error("Ellipsis must be specified in the LHS");for(let y=0;y<l.length;y++){let _=String.fromCharCode("0".charCodeAt(0)+y);h.addSymbol(_,b+y),this.addSymbol(_,o[a++],n)}}else h.addSymbol(g,b+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(g,o[a++],n)}),h}},os=e=>e+"_max",Al=(e,t,r,o,n)=>{let u=t.map((w,y)=>e[y]?w.length:w).map((w,y)=>M(`input${y}`,r,w)),l=U.size(n),a=Re(n.length),p=a?n.length:n,h=F("output",r,p),g=[...o.symbolToInfo.keys()].filter(w=>!o.rhs.symbolToIndices.has(w)),b=w=>{let y=[],_="var prod = 1.0;",I="var sum = 0.0;",$="sum += prod;",x=[],E=[],A=[],z=[],R=o.symbolToInfo.size===o.rhs.symbolToIndices.size;o.symbolToInfo.forEach((T,N)=>{if(o.rhs.symbolToIndices.has(N)){let te=o.rhs.symbolToIndices.get(N)?.[0];te!==void 0&&o.lhs.forEach((Y,K)=>{if(T.inputIndices.includes(K)){let Q=Y.symbolToIndices.get(N);if(Q===void 0)throw new Error("Invalid symbol error");Q.forEach(Z=>{y.push(`${u[K].indicesSet(`input${K}Indices`,Z,h.indicesGet("outputIndices",te))}`)})}})}else o.lhs.forEach((te,Y)=>{if(T.inputIndices.includes(Y)){let K=te.symbolToIndices.get(N);if(K===void 0)throw new Error("Invalid symbol error");K.forEach(Q=>{x.push(`${u[Y].indicesSet(`input${Y}Indices`,Q,`${N}`)}`)}),z.push(`prod *= ${u[Y].getByIndices(`input${Y}Indices`)};`)}}),E.push(`for(var ${N}: u32 = 0; ${N} < uniforms.${os(N)}; ${N}++) {`),A.push("}")});let V=R?[...y,`let sum = ${u.map((T,N)=>T.getByIndices(`input${N}Indices`)).join(" * ")};`]:[...y,I,...E,...x,_,...z,$,...A];return`\n            ${w.registerUniforms(g.map(T=>({name:`${os(T)}`,type:"u32"}))).registerUniform("outputSize","u32").declareVariables(...u,h)}\n\n            ${w.mainStart()}\n            ${w.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n            var outputIndices = ${h.offsetToIndices("global_idx")};\n            ${u.map((T,N)=>`var input${N}Indices: ${u[N].type.indices};`).join(`\n`)}\n            ${V.join(`\n`)};\n            ${h.setByOffset("global_idx","sum")};\n          }`};return{name:"Einsum",shaderCache:{hint:o.equation,inputDependencies:e.map(w=>w?"rank":"dims")},getRunData:()=>{let w=g.filter(_=>o.symbolToInfo.has(_)).map(_=>({type:"uint32",data:o.symbolToInfo.get(_)?.dimValue||0}));w.push({type:"uint32",data:l});let y=t.filter((_,I)=>e[I]).map((_,I)=>[...L(_)]).reduce((_,I)=>_.concat(I),w);return a&&y.push(...L(n)),{outputs:[{dims:n,dataType:r}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:y}},getShaderSource:b}},as=(e,t)=>{let r=new Qn(e.inputs,t.equation),o=e.inputs.map((u,l)=>Re(u.dims.length)),n=r.outputDims,s=e.inputs.map((u,l)=>u.dims);e.compute(Al(o,s,e.inputs[0].dataType,r,n))},is=e=>{let t=e.equation.replace(/\\s+/g,"");return ge({equation:t})}});var Tl,us,El,Ol,ds,ls=j(()=>{"use strict";Ne();$e();ve();Tl=e=>{if(!e||e.length!==2)throw new Error("Expand requires 2 input.");let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),o=r.length<t.length?0:r.length-t.length,n=t.length<r.length?0:t.length-r.length;for(;o<r.length&&n<t.length;++o,++n)if(r[o]!==t[n]&&r[o]!==1&&t[n]!==1)throw new Error("Expand requires shape to be broadcastable to input")},us=(e,t)=>{let r=e.length-t.length,o=[];for(let n=0;n<r;++n)o.push(e[n]);for(let n=0;n<t.length;++n)o.push(t[n]===1?e[n+r]:t[n]);return o},El=(e,t)=>e.length>t.length?us(e,t):us(t,e),Ol=e=>{let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),o=El(t,r),n=e[0].dataType,s=n===9?4:1,u=Math.ceil(U.size(o)/s),l=Re(t.length),a=Re(o.length),p=g=>{let b=l?t.length:t,w=a?o.length:o,y=M("input",n,b,s),_=F("output",n,w,s),I;if(n===9){let $=(x,E,A="")=>`\n          let outputIndices${E} = ${_.offsetToIndices(`outputOffset + ${E}u`)};\n          let offset${E} = ${y.broadcastedIndicesToOffset(`outputIndices${E}`,_)};\n          let index${E} = offset${E} / 4u;\n          let component${E} = offset${E} % 4u;\n          ${x}[${E}] = ${A}(${y.getByOffset(`index${E}`)}[component${E}]);\n        `;I=`\n        let outputOffset = global_idx * ${s};\n        var data = vec4<u32>(0);\n        ${$("data",0,"u32")}\n        ${$("data",1,"u32")}\n        ${$("data",2,"u32")}\n        ${$("data",3,"u32")}\n        ${_.setByOffset("global_idx","data")}\n      }`}else I=`\n        let outputIndices = ${_.offsetToIndices("global_idx")};\n        let inputOffset = ${y.broadcastedIndicesToOffset("outputIndices",_)};\n        ${_.setByOffset("global_idx",y.getByOffset("inputOffset"))}\n      }`;return`\n    ${g.registerUniform("vec_size","u32").declareVariables(y,_)}\n    ${g.mainStart()}\n    ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n    ${I}`},h=[{type:"uint32",data:u}];return l&&h.push(...L(t)),a&&h.push(...L(o)),{name:"Expand",shaderCache:{hint:`${o.length}`,inputDependencies:[l?"rank":"dims"]},getShaderSource:p,getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:h})}},ds=e=>{Tl(e.inputs),e.compute(Ol(e.inputs),{inputs:[0]})}});var Pl,kl,cs,ps,ms=j(()=>{"use strict";Ne();$e();je();ve();Pl=e=>{if(!e||e.length!==2)throw new Error("Gather requires 2 inputs.")},kl=(e,t)=>{let r=e[0].dims,o=e[1].dims,n=r.length,s=U.normalizeAxis(t.axis,n),u=r.slice(0);u.splice(s,1,...o);let l=r[s],a=e[0].dataType===9?4:1,p=Math.ceil(U.size(u)/a),h=Re(e[0].dims.length),g=h?e[0].dims.length:e[0].dims,b=Re(e[1].dims.length),w=b?e[1].dims.length:e[1].dims,y=Re(u.length),_=y?u.length:u,I=[{type:"uint32",data:p},{type:"int32",data:l},{type:"uint32",data:s}];h&&I.push(...L(e[0].dims)),b&&I.push(...L(e[1].dims)),y&&I.push(...L(u));let $=[];$.push(h?"rank":"dims"),$.push(b?"rank":"dims");let x=E=>{let A=M("data",e[0].dataType,g,a),z=M("inputIndices",e[1].dataType,w),R=F("output",e[0].dataType,_,a),V=N=>{let te=o.length,Y=`var indicesIndices${N}  = ${z.type.indices}(0);`;for(let K=0;K<te;K++)Y+=`${te>1?`indicesIndices${N}[${K}]`:`indicesIndices${N}`} = ${u.length>1?`outputIndices${N}[uniforms.axis + ${K}]`:`outputIndices${N}`};`;Y+=`\n          var idx${N} = ${z.getByIndices(`indicesIndices${N}`)};\n          if (idx${N} < 0) {\n            idx${N} = idx${N} + uniforms.axisDimLimit;\n          }\n          var dataIndices${N} = ${A.type.indices}(0);\n        `;for(let K=0,Q=0;K<n;K++)K===s?(Y+=`${n>1?`dataIndices${N}[${K}]`:`dataIndices${N}`} = u32(idx${N});`,Q+=te):(Y+=`${n>1?`dataIndices${N}[${K}]`:`dataIndices${N}`} = ${u.length>1?`outputIndices${N}[${Q}]`:`outputIndices${N}`};`,Q++);return Y},T;if(e[0].dataType===9){let N=(te,Y,K="")=>`\n          let outputIndices${Y} = ${R.offsetToIndices(`outputOffset + ${Y}u`)};\n          ${V(Y)};\n          let offset${Y} = ${A.indicesToOffset(`dataIndices${Y}`)};\n          let index${Y} = offset${Y} / 4u;\n          let component${Y} = offset${Y} % 4u;\n          ${te}[${Y}] = ${K}(${A.getByOffset(`index${Y}`)}[component${Y}]);\n        `;T=`\n        let outputOffset = global_idx * ${a};\n        var value = vec4<u32>(0);\n        ${N("value",0,"u32")}\n        ${N("value",1,"u32")}\n        ${N("value",2,"u32")}\n        ${N("value",3,"u32")}\n        ${R.setByOffset("global_idx","value")}\n      `}else T=`\n      let outputIndices = ${R.offsetToIndices("global_idx")};\n      ${V("")};\n      let value = ${A.getByIndices("dataIndices")};\n      ${R.setByOffset("global_idx","value")};\n      `;return`\n      ${E.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(A,z,R)}\n      ${E.mainStart()}\n        ${E.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n        ${T}\n      }`};return{name:"Gather",shaderCache:{hint:t.cacheKey,inputDependencies:$},getRunData:()=>({outputs:[{dims:u,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:I}),getShaderSource:x}},cs=e=>ge({axis:e.axis}),ps=(e,t)=>{let r=e.inputs;Pl(r),e.compute(kl(e.inputs,t))}});var Rl,Bl,fs,hs,gs=j(()=>{"use strict";$e();je();ve();Rl=e=>{if(!e||e.length!==2)throw new Error("GatherElements requires 2 inputs.");if(e[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(e[0].dims.length!==e[1].dims.length)throw new Error(`GatherElements requires that the data input and\n                     indices input tensors be of same rank.`)},Bl=(e,t)=>{let r=e[0].dims,o=e[0].dataType,n=r.length,s=e[1].dims,u=e[1].dataType,l=U.normalizeAxis(t.axis,n),a=r[l],p=s.slice(0),h=U.size(p),g=M("input",o,n),b=M("indicesInput",u,s.length),w=F("output",o,p.length),y=[{type:"uint32",data:h},{type:"int32",data:a},{type:"uint32",data:l}];return y.push(...L(r)),y.push(...L(s)),y.push(...L(p)),{name:"GatherElements",shaderCache:{inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:p,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:y}),getShaderSource:$=>`\n      ${$.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(g,b,w)}\n      ${$.mainStart()}\n      ${$.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n      let outputIndices = ${w.offsetToIndices("global_idx")};\n\n      var idx = ${b.getByOffset("global_idx")};\n      if (idx < 0) {\n        idx = idx + uniforms.axisDimLimit;\n      }\n      var inputIndices = ${g.type.indices}(outputIndices);\n      ${g.indicesSet("inputIndices","uniforms.axis","u32(idx)")};\n      let value = ${g.getByIndices("inputIndices")};\n\n      ${w.setByOffset("global_idx","value")};\n  }`}},fs=e=>ge({axis:e.axis}),hs=(e,t)=>{let r=e.inputs;Rl(r),e.compute(Bl(e.inputs,t))}});var Dl,Ml,ys,bs,ws=j(()=>{"use strict";$e();ve();Dl=e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(e.length===3&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(e[0].dataType!==e[1].dataType||e.length===3&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")},Ml=(e,t)=>{let r=e[0].dims.slice(),o=e[1].dims.slice(),[n,s,u]=Hr.getShapeOfGemmResult(r,t.transA,o,t.transB,e.length===3?e[2].dims:void 0),l=[n,s];if(!l)throw new Error("Can\'t use gemm on the given tensors");let a=U.size(l),p=[{type:"uint32",data:a},{type:"uint32",data:n},{type:"uint32",data:s},{type:"uint32",data:u},{type:"float32",data:t.alpha},{type:"float32",data:t.beta}],h=["type","type"];e.length===3&&(p.push(...L(e[2].dims)),h.push("rank")),p.push(...L(l));let g=b=>{let w="";t.transA&&t.transB?w="value += a[k * uniforms.M + m] * b[n * uniforms.K + k];":t.transA&&!t.transB?w="value += a[k * uniforms.M + m] * b[k * uniforms.N + n];":!t.transA&&t.transB?w="value += a[m * uniforms.K + k] * b[n * uniforms.K + k];":!t.transA&&!t.transB&&(w="value += a[m * uniforms.K + k] * b[k * uniforms.N + n];");let y=t.alpha===1?"":"value *= uniforms.alpha;",_=M("a",e[0].dataType,e[0].dims),I=M("b",e[1].dataType,e[1].dims),$=_.type.value,x=null,E=[_,I];e.length===3&&(x=M("c",e[2].dataType,e[2].dims.length),E.push(x));let A=F("output",e[0].dataType,l.length);E.push(A);let z=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}];return`\n  ${b.registerUniforms(z).declareVariables(...E)}\n\n  ${b.mainStart()}\n    ${b.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let m = global_idx / uniforms.N;\n    let n = global_idx % uniforms.N;\n\n    var value = ${$}(0);\n    for (var k: u32 = 0u; k < uniforms.K; k++) {\n      ${w}\n    }\n\n    ${y}\n    ${(()=>x!=null?`let cOffset = ${x.broadcastedIndicesToOffset("vec2(m, n)",A)}; value += ${$}(uniforms.beta) * ${x.getByOffset("cOffset")};`:"")()}\n    output[global_idx] = value;\n  }`};return{name:"Gemm",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:h},getRunData:()=>({outputs:[{dims:l,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:p}),getShaderSource:g}},ys=e=>{let t=e.transA,r=e.transB,o=e.alpha,n=e.beta;return{transA:t,transB:r,alpha:o,beta:n,cacheKey:`${e.transA};${e.transB};${e.alpha===1}`}},bs=(e,t)=>{Dl(e.inputs),e.compute(Ml(e.inputs,t))}});var zl,Ul,Vl,vs,$s=j(()=>{"use strict";Ne();$e();ve();zl=(e,t)=>{let r=e[0].dims,o=r,n=2,s=U.sizeToDimension(r,n),u=U.sizeFromDimension(r,n),l=Fe(u),a=u/l,p=[r[0],r[1],a],h=["rank","type","type"],g=[{type:"uint32",data:u},{type:"uint32",data:a}];g.push(...L(p),...L(p));let b=w=>{let y=M("x",e[0].dataType,p.length,l),_=M("scale",e[1].dataType,e[1].dims),I=M("bias",e[2].dataType,e[2].dims),$=F("output",e[0].dataType,p.length,l),x=[y,_,I,$],E=y.type.value,A=l===1?"f32":`vec${l}<f32>`,z=64,R=[{name:"normSize",type:"u32"},{name:"normPackedSize",type:"u32"}];return`\n  var<workgroup> meanShared : f32;\n  var<workgroup> squaredNormShared : f32;\n  var<workgroup> workgroupShared : array<${A}, ${z}>;\n  const workgroupSize = ${z}u;\n  ${w.registerUniforms(R).declareVariables(...x)}\n  ${w.mainStart(z)}\n    let norm = global_idx / workgroupSize;\n    let batch = norm / uniforms.x_shape[1];\n    let channel = norm % uniforms.x_shape[1];\n    let localIndex = local_id.x;\n\n    // initialize workgroup memory\n    var initial = ${A}(0);\n    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {\n      initial = initial + ${A}(${y.get("batch","channel","h")});\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the mean of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      meanShared = ${Je("workgroupShared[0]",l)} / f32(uniforms.normSize);\n    }\n    workgroupBarrier();\n\n    // reinitialize workgroup memory.\n    initial = ${A}(0);\n    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {\n      let deviation =  ${A}(${y.get("batch","channel","h")}) - ${A}(meanShared);\n      initial = initial + deviation * deviation;\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the sum of square of deviation of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      squaredNormShared = ${Je("workgroupShared[0]",l)};\n    }\n    workgroupBarrier();\n\n    let invStdDev = inverseSqrt(squaredNormShared / f32(uniforms.normSize) + f32(${t.epsilon}));\n    let channelScale = invStdDev * f32(${_.getByOffset("channel")});\n    let channelShift = f32(${I.getByOffset("channel")}) - meanShared * channelScale;\n    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {\n      let value = ${y.get("batch","channel","h")} * ${E}(${A}(channelScale)) + ${E}(${A}(channelShift));\n      ${$.set("batch","channel","h","value")};\n    }\n  }`};return{name:"InstanceNormalization",shaderCache:{hint:`${t.epsilon};${l}`,inputDependencies:h},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:s},programUniforms:g}),getShaderSource:b}},Ul=(e,t,r,o,n,s,u,l)=>{let a=Fe(u),p=64,h=a===1?"vec2f":`mat2x${a}f`,g=a===1?"f32":`vec${a}f`,b=(R,V)=>`${h}(${R}, ${V})`,w=n*u/a,y=Math.ceil(s/p),_=["type"],I=[{type:"uint32",data:y},{type:"uint32",data:s},{type:"uint32",data:Math.floor(u/a)},{type:"uint32",data:Math.floor(s*u/a)}],$=R=>{let V=M("input",t.dataType,t.dims,a);return`\n  ${R.declareVariables(V)}\n  @group(0) @binding(1) var<storage, read_write> output : array<${h}>;\n  struct Uniforms {wg_size:u32, H:u32, C:u32, image_size:u32};\n  @group(0) @binding(2) var<uniform> uniforms: Uniforms;\n\n  ${R.mainStart(p)}\n    let currentImageNumber = global_idx / ${p} / uniforms.C;\n    let currentChannelNumber = (global_idx / ${p}) % uniforms.C;\n    let wgId = global_idx % ${p};\n    let wgOffset = wgId * uniforms.wg_size;\n    if (wgOffset >= uniforms.H) {\n        return;\n    }\n    let wgMax = min(wgOffset + uniforms.wg_size, uniforms.H);\n\n    let offset = currentImageNumber * uniforms.image_size + currentChannelNumber;\n    var sum = ${Ze("f32",a)};\n    var squaredSum = ${Ze("f32",a)};\n    for (var i: u32 = wgOffset; i < wgMax; i++) {\n        let value = ${g}(input[offset + i * uniforms.C]);\n        sum += value;\n        squaredSum += value * value;\n    }\n    output[global_idx] = ${b("sum","squaredSum")};\n  }`},x=e.compute({name:"InstanceNormComputeMean",shaderCache:{hint:`${a}`,inputDependencies:_},getRunData:()=>({outputs:[{dims:[n,u,p,2],dataType:1}],dispatchGroup:{x:n*u/a},programUniforms:I}),getShaderSource:$},{inputs:[t],outputs:[-1]})[0],E=[{type:"uint32",data:w},{type:"uint32",data:s},{type:"uint32",data:Math.floor(u/a)},{type:"uint32",data:Math.floor(p*u/a)}],A=["type","type","type"],z=R=>{let V=M("scale",r.dataType,r.dims,a),T=M("bias",o.dataType,o.dims,a);return`\n  @group(0) @binding(0) var<storage, read> input : array<${h}>;\n  @group(0) @binding(1) var<storage, read> scale : array<${V.type.storage}>;\n  @group(0) @binding(2) var<storage, read> bias : array<${T.type.storage}>;\n  @group(0) @binding(3) var<storage, read_write> output : array<${h}>;\n  struct Uniforms {units_of_work : u32, H: u32, C : u32, image_size : u32};\n  @group(0) @binding(4) var<uniform> uniforms: Uniforms;\n\n  ${R.mainStart()}\n    ${R.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.units_of_work")}\n    let currentImageNumber = global_idx / uniforms.C;\n    let currentChannelNumber = global_idx % uniforms.C;\n\n    let offset = currentImageNumber * uniforms.image_size;\n    var sum = ${Ze("f32",a)};\n    var squaredSum = ${Ze("f32",a)};\n    for (var i: u32 = 0; i < ${p}; i++) {\n        let value = input[offset + i + currentChannelNumber * ${p}];\n        sum += value[0];\n        squaredSum += value[1];\n    }\n    sum = sum / f32(uniforms.H);\n    squaredSum = squaredSum / f32(uniforms.H);\n    let invStdDev = inverseSqrt(squaredSum - sum * sum + f32(${l}));\n    let channelScale = invStdDev * ${g}(scale[currentChannelNumber]);\n    let channelShift = ${g}(bias[currentChannelNumber]) - sum * channelScale;\n\n    output[global_idx] = ${b("channelScale","channelShift")};\n  }`};return e.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:`${a};${l}`,inputDependencies:A},getRunData:()=>({outputs:[{dims:[n,u,2],dataType:1}],dispatchGroup:{x:Math.ceil(w/64)},programUniforms:E}),getShaderSource:z},{inputs:[x,r,o],outputs:[-1]})[0]},Vl=(e,t,r)=>{let o=t[0].dims,n=o,s=o[0],u=o[o.length-1],l=U.sizeFromDimension(o,1)/u,a=Fe(u),p=U.size(n)/a,h=[{type:"uint32",data:l},{type:"uint32",data:Math.floor(u/a)}],g=["type","type"],b=Ul(e,t[0],t[1],t[2],s,l,u,r.epsilon),w=y=>{let _=Le(t[0].dataType),I=a===1?"vec2f":`mat2x${a}f`,$=a===1?_:`vec${a}<${_}>`,x=M("input",t[0].dataType,t[0].dims,a),E=F("output",t[0].dataType,n,a);return`\n  @group(0) @binding(0) var<storage, read> input : array<${x.type.storage}>;\n  @group(0) @binding(1) var<storage, read> scaleInput : array<${I}>;\n  @group(0) @binding(2) var<storage, read_write> output : array<${E.type.storage}>;\n  struct Uniforms {H: u32, C : u32};\n  @group(0) @binding(3) var<uniform> uniforms: Uniforms;\n\n  ${y.mainStart()}\n    let currentImageNumber = global_idx / (uniforms.C * uniforms.H);\n    let currentChannelNumber = global_idx % uniforms.C;\n\n    let scaleOffset = currentImageNumber * uniforms.C + currentChannelNumber;\n    let scale = scaleInput[scaleOffset];\n    output[global_idx] = fma(input[global_idx], ${$}(scale[0]), ${$}(scale[1]));\n  }`};e.compute({name:"InstanceNormalizationNHWC",shaderCache:{hint:`${a}`,inputDependencies:g},getRunData:()=>({outputs:[{dims:n,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:h}),getShaderSource:w},{inputs:[t[0],b]})},vs=(e,t)=>{t.format==="NHWC"?Vl(e,e.inputs,t):e.compute(zl(e.inputs,t))}});var Nl,Wl,Ss,xs=j(()=>{"use strict";Ne();$e();ve();Nl=e=>{if(!e||e.length<2)throw new Error("layerNorm requires at least 2 inputs.")},Wl=(e,t,r)=>{let o=e[0].dims,n=e[1],s=e[2],u=o,l=U.normalizeAxis(t.axis,o.length),a=U.sizeToDimension(o,l),p=U.sizeFromDimension(o,l),h=U.size(n.dims),g=s?U.size(s.dims):0;if(h!==p||s&&g!==p)throw new Error(`Size of X.shape()[axis:] == ${p}.\n       Size of scale and bias (if provided) must match this.\n       Got scale size of ${h} and bias size of ${g}`);let b=[];for(let A=0;A<o.length;++A)A<l?b.push(o[A]):b.push(1);let w=Fe(p),y=["type","type"],_=[{type:"uint32",data:a},{type:"float32",data:p},{type:"uint32",data:Math.floor(p/w)},{type:"float32",data:t.epsilon}];s&&y.push("type");let I=r>1,$=r>2,x=A=>{let z=Le(e[0].dataType),R=[M("x",e[0].dataType,e[0].dims,w),M("scale",n.dataType,n.dims,w)];s&&R.push(M("bias",s.dataType,s.dims,w)),R.push(F("output",e[0].dataType,u,w)),I&&R.push(F("mean_data_output",1,b)),$&&R.push(F("inv_std_output",1,b));let V=[{name:"norm_count",type:"u32"},{name:"norm_size",type:"f32"},{name:"norm_size_vectorized",type:"u32"},{name:"epsilon",type:"f32"}];return`\n  ${A.registerUniforms(V).declareVariables(...R)}\n  ${A.mainStart()}\n    ${A.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}\n    let offset = global_idx * uniforms.norm_size_vectorized;\n    var meanVector = ${Ze("f32",w)};\n    var meanSquareVector = ${Ze("f32",w)};\n\n    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {\n      let value = ${at(z,w,"x[h + offset]")};\n      meanVector += value;\n      meanSquareVector += value * value;\n    }\n    let mean = ${Je("meanVector",w)} / uniforms.norm_size;\n    let invStdDev =\n        inverseSqrt(${Je("meanSquareVector",w)} / uniforms.norm_size - mean * mean + uniforms.epsilon);\n\n    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {\n      let f32input = ${at(z,w,"x[j + offset]")};\n      let f32scale = ${at(z,w,"scale[j]")};\n      output[j + offset] = ${R[0].type.value}((f32input - mean) * invStdDev * f32scale\n        ${s?`+ ${at(z,w,"bias[j]")}`:""}\n      );\n    }\n\n    ${I?"mean_data_output[global_idx] = mean":""};\n    ${$?"inv_std_output[global_idx] = invStdDev":""};\n  }`},E=[{dims:u,dataType:e[0].dataType}];return I&&E.push({dims:b,dataType:1}),$&&E.push({dims:b,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${w};${r}`,inputDependencies:y},getRunData:()=>({outputs:E,dispatchGroup:{x:Math.ceil(a/64)},programUniforms:_}),getShaderSource:x}},Ss=(e,t)=>{Nl(e.inputs),e.compute(Wl(e.inputs,t,e.outputCount))}});var Hl,Cs,_s,Gl,Xn,Is,As=j(()=>{"use strict";$e();je();Nr();Un();ve();jt();Hl=(e,t)=>{let r=e[0],o=e[1],n=e[2],s=e[3],u=e[4],l=e[5],a=e[6],p=e[7];if(r.dims.length!==3&&r.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let h=!1,g=r.dims[0],b=r.dims[1],w=r.dims.length===3?h?r.dims[2]/3:r.dims[2]:t.numHeads*r.dims[4],y=b,_=0,I=0,$=Math.floor(w/t.numHeads);if(a&&p){if(a.dims.length!==4)throw new Error(\'Input "past_key" is expected to have 4 dimensions\');if(p.dims.length!==4)throw new Error(\'Input "past_value" is expected to have 4 dimensions\');_=a.dims[2],I=a.dims[2]}else if(a||p)throw new Error(\'Input "past_key" and "past_value" shall be both present or both absent\');let x;if(o){if(r.dims.length!==3)throw new Error(\'Input "query" is expected to have 3 dimensions when key is given\');if(o.dims.length<3||o.dims.length>5)throw new Error(\'Input "key" is expected to have 3, 4, or 5 dimensions\');if(r.dims[0]!==o.dims[0])throw new Error(\'Input "query" and "key" shall have same dim 0 (batch size)\');if(o.dims.length===3){if(o.dims[2]!==r.dims[2])throw new Error(\'Input "query" and "key" shall have same dim 2 (hidden_size)\');x=2,y=o.dims[1]}else if(o.dims.length===5){if(o.dims[2]!==t.numHeads||o.dims[3]!==2||o.dims[4]!==$)throw new Error(\'Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv\');if(n)throw new Error(\'Expect "value" be none when "key" has packed kv format.\');x=5,y=o.dims[1]}else{if(o.dims[1]!==t.numHeads||o.dims[3]!==$)throw new Error(\'Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key\');x=0,y=o.dims[2]}}else{if(r.dims.length!==3&&r.dims.length!==5)throw new Error(\'Input "query" is expected to have 3 or 5 dimensions when key is empty\');if(r.dims.length===5&&(r.dims[2]!==t.numHeads||r.dims[3]!==3))throw new Error(\'Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv\');x=3}if(s){if(s.dims.length!==1)throw new Error(\'Input "bias" is expected to have 1 dimension\');if(n&&r.dims.length===5&&r.dims[3]===2)throw new Error("bias is not allowed for packed kv.")}let E=0;if(u){E=8;let T=u.dims;throw T.length===1?T[0]===g?E=1:T[0]===3*g+2&&(E=3):T.length===2&&T[0]===g&&T[1]===y&&(E=5),E===8?new Error(\'Input "key_padding_mask" shape shall be (batch_size) or (batch_size, kv_sequence_length)\'):new Error("Mask not supported")}let A=!1,z=w;if(n){if(n.dims.length!==3&&n.dims.length!==4)throw new Error(\'Input "value" is expected to have 3 or 4 dimensions\');if(r.dims[0]!==n.dims[0])throw new Error(\'Input "query" and "value" shall have same dim 0 (batch_size)\');if(n.dims.length===3){if(y!==n.dims[1])throw new Error(\'Input "key" and "value" shall have the same dim 1 (kv_sequence_length)\');z=n.dims[2]}else{if(y!==n.dims[2])throw new Error(\'Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)\');z=n.dims[1]*n.dims[3],A=!0}}let R=_+y,V=!1;if(u)throw new Error("Key padding mask is not supported");if(l)throw new Error("extraAddQk is not supported");if(a)throw new Error("pastKey is not supported");if(p)throw new Error("pastValue is not supported");return{batchSize:g,sequenceLength:b,pastSequenceLength:_,kvSequenceLength:y,totalSequenceLength:R,maxSequenceLength:I,inputHiddenSize:0,hiddenSize:w,vHiddenSize:z,headSize:$,vHeadSize:Math.floor(z/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:E,scale:t.scale,broadcastResPosBias:V,passPastInKv:A,qkvFormat:x}},Cs=e=>ge({...e}),_s=ge({perm:[0,2,1,3]}),Gl=(e,t,r,o,n,s,u)=>{let l=[o,n,s],a=U.size(l),p=[{type:"uint32",data:a},{type:"uint32",data:u},{type:"uint32",data:s}],h=g=>{let b=F("qkv_with_bias",t.dataType,l),w=M("qkv",t.dataType,l),y=M("bias",r.dataType,l),_=[{name:"output_size",type:"u32"},{name:"bias_offset",type:"u32"},{name:"hidden_size",type:"u32"}];return`\n  ${g.registerUniforms(_).declareVariables(w,y,b)}\n  ${g.mainStart()}\n    ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;\n\n    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];\n  }`};return e.compute({name:"MultiHeadAttentionAddBias",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:l,dataType:t.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:p}),getShaderSource:h},{inputs:[t,r],outputs:[-1]})[0]},Xn=(e,t,r,o,n,s,u,l)=>{let a=s;if(u){if(o===1)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return a=Gl(e,s,u,t,o,r*n,l),a=a.reshape([t,o,r,n]),e.compute(it(a,_s.perm),{inputs:[a],outputs:[-1]})[0]}else return s.dims.length===3&&(a=s.reshape([t,o,r,n])),e.compute(it(a,_s.perm),{inputs:[a],outputs:[-1]})[0]},Is=(e,t)=>{let r=Hl(e.inputs,t);if(e.inputs[0].dims.length===5)throw new Error("Packed QKV is not implemented");if(e.inputs[1]?.dims.length===5)throw new Error("Packed KV is not implemented");let o=e.inputs[1]&&e.inputs[2]&&e.inputs[1].dims.length===4&&e.inputs[2].dims.length===4,n=Xn(e,r.batchSize,r.numHeads,r.sequenceLength,r.headSize,e.inputs[0],e.inputs[3],0);if(o)return Kr(e,n,e.inputs[1],e.inputs[2],e.inputs[4],void 0,void 0,void 0,e.inputs[5],r,t);let s=Xn(e,r.batchSize,r.numHeads,r.kvSequenceLength,r.headSize,e.inputs[1],e.inputs[3],r.hiddenSize),u=Xn(e,r.batchSize,r.numHeads,r.kvSequenceLength,r.vHeadSize,e.inputs[2],e.inputs[3],2*r.hiddenSize);Kr(e,n,s,u,e.inputs[4],void 0,e.inputs[6],e.inputs[7],e.inputs[5],r,t)}});var Ll,Fl,jl,ql,Kl,Yl,Zl,Ql,Ts,Es=j(()=>{"use strict";Ne();$e();ve();Ll=e=>{if(!e||e.length<1)throw new Error("Too few inputs");if(e[0].dataType!==1)throw new Error("Input type must be float.");if(e.length>=2){let t=e[0].dims.length*2===e[1].dims[0];if(e.length===4&&(t=e[3].dims[0]*2===e[1].dims[0]),!t)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},Fl=(e,t,r)=>{let o="";for(let n=t-1;n>=0;--n)o+=`\n            k = i32(${e.indicesGet("indices",n)}) - ${ce("uniforms.pads",n,r)};\n            if (k < 0) {\n              break;\n            }\n            if (k >= i32(${ce("uniforms.x_shape",n,t)})) {\n              break;\n            }\n            offset += k * i32(${ce("uniforms.x_strides",n,t)});\n        `;return`\n          value = ${e.type.value}(uniforms.constant_value);\n          for (var i = 0; i < 1; i++) {\n            var offset = 0;\n            var k = 0;\n            ${o}\n            value = x[offset];\n          }\n      `},jl=(e,t,r)=>{let o="";for(let n=t-1;n>=0;--n)o+=`\n                k = i32(${e.indicesGet("indices",n)}) - ${ce("uniforms.pads",n,r)};\n                if (k < 0) {\n                  k = -k;\n                }\n                {\n                  let _2n_1 = 2 * (i32(${ce("uniforms.x_shape",n,t)}) - 1);\n                  k = k % _2n_1;\n                  if(k >= i32(${ce("uniforms.x_shape",n,t)})) {\n                    k = _2n_1 - k;\n                  }\n                }\n                offset += k * i32(${ce("uniforms.x_strides",n,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${o}\n              value = x[offset];\n          `},ql=(e,t,r)=>{let o="";for(let n=t-1;n>=0;--n)o+=`\n                k = i32(${e.indicesGet("indices",n)}) - ${ce("uniforms.pads",n,r)};\n                if (k < 0) {\n                  k = 0;\n                }\n                if (k >= i32(${ce("uniforms.x_shape",n,t)})) {\n                  k = i32(${ce("uniforms.x_shape",n,t)}) - 1;\n                }\n                offset += k * i32(${ce("uniforms.x_strides",n,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${o}\n              value = x[offset];\n          `},Kl=(e,t,r)=>{let o="";for(let n=t-1;n>=0;--n)o+=`\n                k = i32(${e.indicesGet("indices",n)}) - ${ce("uniforms.pads",n,r)};\n                if (k < 0)  {\n                  k += i32(${ce("uniforms.x_shape",n,t)}]);\n                }\n                if (k >= i32(${ce("uniforms.x_shape",n,t)})) {\n                  k -= i32(${ce("uniforms.x_shape",n,t)});\n                }\n                offset += k * i32(${ce("uniforms.x_strides",n,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${o}\n              value = x[offset];\n          `},Yl=(e,t,r)=>{switch(r.mode){case 0:return Fl(e,t,r.pads.length);case 1:return jl(e,t,r.pads.length);case 2:return ql(e,t,r.pads.length);case 3:return Kl(e,t,r.pads.length);default:throw new Error("Invalid mode")}},Zl=(e,t)=>{let r=U.padShape(e[0].dims.slice(),t.pads),o=e[0].dims,s=[{type:"uint32",data:U.size(r)},{type:"uint32",data:t.pads}];if(t.mode===0){let a=Xe(e[0].dataType);s.push({type:a,data:t.value})}s.push(...L(e[0].dims),...L(r));let u=["rank"],l=a=>{let p=F("output",e[0].dataType,r.length),h=M("x",e[0].dataType,o.length),g=h.type.value,b=Yl(p,o.length,t),w=[{name:"output_size",type:"u32"},{name:"pads",type:"i32",length:t.pads.length}];return t.mode===0&&w.push({name:"constant_value",type:g}),`\n            ${a.registerUniforms(w).declareVariables(h,p)}\n            ${a.mainStart()}\n            ${a.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n            let indices = ${p.offsetToIndices("global_idx")};\n\n            var value = ${g}(0);\n            ${b}\n            output[global_idx] = value;\n        }`};return{name:"Pad",shaderCache:{hint:`${t.mode}`,inputDependencies:u},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(U.size(r)/64)},programUniforms:s}),getShaderSource:l}},Ql=(e,t)=>{if(e.length>1){let r=e[1].getBigInt64Array(),o=e.length>=3&&e[2].data?e[2].getFloat32Array()[0]:0,n=e[0].dims.length,s=new Int32Array(2*n).fill(0);if(e.length>=4){let l=e[3].getBigInt64Array();for(let a=0;a<l.length;a++)s[Number(l[a])]=Number(r[a]),s[Number(l[a])+n]=Number(r[a+l.length])}else r.forEach((l,a)=>s[Number(a)]=Number(l));let u=[];return s.forEach(l=>u.push(l)),{mode:t.mode,value:o,pads:u}}else return t},Ts=(e,t)=>{Ll(e.inputs);let r=Ql(e.inputs,t);e.compute(Zl(e.inputs,r),{inputs:[0]})}});var nn,Os,Ps,ks,Rs,Xl,Jl,Bs,Ds,Ms,zs,Us,Vs,Ns,Ws,Hs,Gs,Ls,Fs,js=j(()=>{"use strict";Lt();$e();ve();nn=e=>{if(Gt.webgpu.validateInputContent&&(!e||e.length!==1))throw new Error("Pool ops requires 1 input.")},Os=(e,t,r)=>{let o=t.format==="NHWC",n=e.dims.slice();o&&n.splice(1,0,n.pop());let s=Object.hasOwnProperty.call(t,"dilations"),u=t.kernelShape.slice(),l=t.strides.slice(),a=s?t.dilations.slice():[],p=t.pads.slice();Bt.adjustPoolAttributes(r,n,u,l,a,p);let h=Bt.computePoolOutputShape(r,n,l,a,u,p,t.autoPad),g=Object.assign({},t);s?Object.assign(g,{kernelShape:u,strides:l,pads:p,dilations:a,cacheKey:t.cacheKey}):Object.assign(g,{kernelShape:u,strides:l,pads:p,cacheKey:t.cacheKey});let b=h.slice();return b.push(b.splice(1,1)[0]),[g,o?b:h]},Ps=(e,t)=>{let r=t.format==="NHWC",o=U.size(e),n=U.size(t.kernelShape),s=[{type:"uint32",data:o},{type:"uint32",data:n}],u=[{name:"outputSize",type:"u32"},{name:"kernelSize",type:"u32"}];if(t.kernelShape.length<=2){let l=t.kernelShape[t.kernelShape.length-1],a=t.strides[t.strides.length-1],p=t.pads[t.pads.length/2-1],h=t.pads[t.pads.length-1],g=!!(p+h);s.push({type:"uint32",data:l},{type:"uint32",data:a},{type:"uint32",data:p},{type:"uint32",data:h}),u.push({name:"kw",type:"u32"},{name:"sw",type:"u32"},{name:"pwStart",type:"u32"},{name:"pwEnd",type:"u32"});let b=!1;if(t.kernelShape.length===2){let w=t.kernelShape[t.kernelShape.length-2],y=t.strides[t.strides.length-2],_=t.pads[t.pads.length/2-2],I=t.pads[t.pads.length-2];b=!!(_+I),s.push({type:"uint32",data:w},{type:"uint32",data:y},{type:"uint32",data:_},{type:"uint32",data:I}),u.push({name:"kh",type:"u32"},{name:"sh",type:"u32"},{name:"phStart",type:"u32"},{name:"phEnd",type:"u32"})}return[s,u,!0,g,b]}else{if(r)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let l=U.computeStrides(t.kernelShape);s.push({type:"uint32",data:l},{type:"uint32",data:t.pads},{type:"uint32",data:t.strides}),u.push({name:"kernelStrides",type:"u32",length:l.length},{name:"pads",type:"u32",length:t.pads.length},{name:"strides",type:"u32",length:t.strides.length});let a=t.pads.reduce((p,h)=>p+h);return[s,u,!!a,!1,!1]}},ks=(e,t,r,o,n,s,u,l,a,p,h,g)=>{let b=n.format==="NHWC",w=t.type.value,y=F("output",t.type.tensor,o);if(n.kernelShape.length<=2){let _="",I="",$="",x=r-(b?2:1);if(h?_=`\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${x}] = indices[${x}] * uniforms.sw - uniforms.pwStart + i;\n                  if (xIndices[${x}] < 0 || xIndices[${x}]\n                      >= uniforms.x_shape[${x}]) {\n                    pad++;\n                    continue;\n                  }\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${s}\n                }`:_=`\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${x}] = indices[${x}] * uniforms.sw - uniforms.pwStart + i;\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${s}\n                }`,n.kernelShape.length===2){let A=r-(b?3:2);g?I=`\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${A}] = indices[${A}] * uniforms.sh - uniforms.phStart + j;\n                  if (xIndices[${A}] < 0 || xIndices[${A}] >= uniforms.x_shape[${A}]) {\n                    pad += i32(uniforms.kw);\n                    continue;\n                  }\n              `:I=`\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${A}] = indices[${A}] * uniforms.sh - uniforms.phStart + j;\n                `,$=`\n              }\n            `}return`\n            ${e.registerUniforms(a).declareVariables(t,y)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n              let indices = ${y.offsetToIndices("global_idx")};\n              var xIndices = ${y.offsetToIndices("global_idx")};\n\n              var value = ${w}(${l});\n              var pad = 0;\n              ${I}\n              ${_}\n              ${$}\n              ${u}\n\n              output[global_idx] = value;\n            }`}else{if(b)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let _=n.kernelShape.length,I=n.pads.length,$="";return p?$=`\n                if (xIndices[j] >= uniforms.x_shape[j]) {\n                  pad++;\n                  isPad = true;\n                  break;\n                }\n              }\n              if (!isPad) {\n                let x_val = x[${t.indicesToOffset("xIndices")}];\n                ${s}\n              }`:$=`\n              }\n              let x_val = x[${t.indicesToOffset("xIndices")}];\n              ${s}\n            `,`\n            ${e.registerUniforms(a).declareVariables(t,y)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n              let indices = ${y.offsetToIndices("global_idx")};\n              var xIndices = ${y.offsetToIndices("global_idx")};\n\n              var offsets: array<u32, ${_}>;\n\n              var value = ${w}(${l});\n              var pad = 0;\n              var isPad = false;\n\n              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {\n                var offset = i;\n                for (var j = 0u; j < ${_-1}u; j++) {\n                  offsets[j] = offset / ${ce("uniforms.kernelStrides","j",_)};\n                  offset -= offsets[j] * ${ce("uniforms.kernelStrides","j",_)};\n                }\n                offsets[${_-1}] = offset;\n\n                isPad = false;\n                for (var j = ${r-_}u; j < ${r}u; j++) {\n                  xIndices[j] = indices[j] * ${ce("uniforms.strides",`j - ${r-_}u`,_)}\n                    + offsets[j - ${r-_}u] - ${ce("uniforms.pads","j - 2u",I)};\n                  ${$}\n              }\n              ${u}\n\n              output[global_idx] = value;\n            }`}},Rs=e=>`${e.format};${e.ceilMode};${e.autoPad};${e.kernelShape.length}`,Xl=e=>`${Rs(e)};${e.countIncludePad}`,Jl=e=>`${Rs(e)};${e.storageOrder};${e.dilations}`,Bs=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),Ds=(e,t,r,o)=>{let[n,s]=Os(t,o,r),u=M("x",t.dataType,t.dims.length),l=u.type.value,a="value += x_val;",p="";n.countIncludePad?p+=`value /= ${l}(uniforms.kernelSize);`:p+=`value /= ${l}(i32(uniforms.kernelSize) - pad);`;let[h,g,b,w,y]=Ps(s,n);h.push(...L(t.dims),...L(s));let _=["rank"];return{name:e,shaderCache:{hint:`${o.cacheKey};${b};${w};${y}`,inputDependencies:_},getRunData:()=>({outputs:[{dims:s,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(U.size(s)/64)},programUniforms:h}),getShaderSource:I=>ks(I,u,t.dims.length,s.length,n,a,p,0,g,b,w,y)}},Ms=e=>{let t=e.count_include_pad!==0,r=Bs(e);if(r.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");let o={countIncludePad:t,...r,cacheKey:""};return{...o,cacheKey:Xl(o)}},zs=(e,t)=>{nn(e.inputs),e.compute(Ds("AveragePool",e.inputs[0],!1,t))},Us={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},Vs=e=>{let t=e.format;return{format:t,...Us,cacheKey:t}},Ns=(e,t)=>{nn(e.inputs),e.compute(Ds("GlobalAveragePool",e.inputs[0],!0,t))},Ws=(e,t,r,o)=>{let[n,s]=Os(t,o,r),u=`\n      value = max(x_val, value);\n    `,l="",a=M("x",t.dataType,t.dims.length),p=["rank"],[h,g,b,w,y]=Ps(s,n);return h.push(...L(t.dims),...L(s)),{name:e,shaderCache:{hint:`${o.cacheKey};${b};${w};${y}`,inputDependencies:p},getRunData:()=>({outputs:[{dims:s,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(U.size(s)/64)},programUniforms:h}),getShaderSource:_=>ks(_,a,t.dims.length,s.length,n,u,l,-1e5,g,b,w,y)}},Hs=(e,t)=>{nn(e.inputs),e.compute(Ws("MaxPool",e.inputs[0],!1,t))},Gs=e=>{let t=e.storage_order,r=e.dilations,o=Bs(e);if(t!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(o.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");let n={storageOrder:t,dilations:r,...o,cacheKey:""};return{...n,cacheKey:Jl(n)}},Ls=e=>{let t=e.format;return{format:t,...Us,cacheKey:t}},Fs=(e,t)=>{nn(e.inputs),e.compute(Ws("GlobalMaxPool",e.inputs[0],!0,t))}});var tc,rc,qs,Ks=j(()=>{"use strict";Lt();Ne();ve();tc=(e,t,r)=>{let o=e===t,n=e<t&&r<0,s=e>t&&r>0;if(o||n||s)throw new Error("Range these inputs\' contents are invalid.")},rc=(e,t,r,o)=>{let n=Math.abs(Math.ceil((t-e)/r)),s=[n],u=n,l=Xe(o),a=[{type:"uint32",data:u},{type:l,data:e},{type:l,data:r},...L(s)],p=h=>{let g=F("output",o,s.length),b=g.type.value,w=[{name:"outputSize",type:"u32"},{name:"start",type:b},{name:"delta",type:b}];return`\n        ${h.registerUniforms(w).declareVariables(g)}\n        ${h.mainStart()}\n        ${h.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n        output[global_idx] = uniforms.start + ${b}(global_idx) * uniforms.delta;\n      }`};return{name:"Range",shaderCache:{hint:`${o}`},getShaderSource:p,getRunData:()=>({outputs:[{dims:s,dataType:o}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:a})}},qs=e=>{let t=0,r=0,o=0;e.inputs[0].dataType===6?(t=e.inputs[0].getInt32Array()[0],r=e.inputs[1].getInt32Array()[0],o=e.inputs[2].getInt32Array()[0]):e.inputs[0].dataType===1&&(t=e.inputs[0].getFloat32Array()[0],r=e.inputs[1].getFloat32Array()[0],o=e.inputs[2].getFloat32Array()[0]),Gt.webgpu.validateInputContent&&tc(t,r,o),e.compute(rc(t,r,o,e.inputs[0].dataType),{inputs:[]})}});var nc,oc,ac,ic,sc,uc,dc,lc,cc,pc,mc,Ys,fc,hc,gc,yc,bc,Zs,Qs,Xs=j(()=>{"use strict";$e();je();ve();nc=(e,t)=>{if(e.every(r=>r>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),e.length>0){if(t.mode==="linear"){if(!(e.length===2||e.length===3||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1||e.length===5&&e[0]===1&&e[1]===1))throw new Error(`For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and\n            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`)}else if(t.mode==="cubic"&&!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},oc=(e,t,r)=>{t.every(n=>n>=0&&n<r||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let o=new Array(r).fill(1);return t.forEach((n,s)=>o[n]=e[s]),o},ac=(e,t,r,o,n,s)=>{let[u,l,a]=r>10?[1,2,3]:[-1,e.length>1?1:-1,-1],p=e[0].dims.length;if(u>0&&e.length>u&&e[u].dims.length>0)e[u].getFloat32Array().forEach(h=>s.push(h));else if(t.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(l>0&&e.length>l&&e[l].dims.length>0){if(e[l].getFloat32Array().forEach(h=>o.push(h)),o.length!==0&&o.length!==p&&r>=18&&o.length!==t.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");nc(o,t),t.axes.length>0&&oc(o,t.axes,p).forEach((h,g)=>o[g]=h)}if(a>0&&e.length>a&&(e[a].getBigInt64Array().forEach(h=>n.push(Number(h))),n.length!==p||r>=18&&n.length===t.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(t.axes.length>0){if(o.length!==t.axes.length)throw new Error(\'Resize requires "scales" input size to be of axes rank when axes attributes is specified\');if(n.length!==t.axes.length)throw new Error(\'Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified\')}if(typeof o<"u"&&typeof n<"u"&&o.length>0&&n.length>p)throw new Error("Resize requires only of scales or sizes to be specified")},ic=(e,t)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,\n     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${t} { `+(()=>{switch(e){case"asymmetric":return`return ${t}(xResized) / ${t}(xScale);`;case"pytorch_half_pixel":return`if (lengthResized > 1) {\n                    return (${t}(xResized) + 0.5) / ${t}(xScale) - 0.5;\n                  } else {\n                    return 0.0;\n                  }`;case"tf_half_pixel_for_nn":return`return (${t}(xResized) + 0.5) / ${t}(xScale);`;case"align_corners":return`if (lengthResized == 1) {\n                    return 0.0;\n                  } else {\n                    // The whole part and the fractional part are calculated separately due to inaccuracy of floating\n                    // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an\n                    // offset-by-one error later in floor().\n                    let whole = ${t}(xResized * (lengthOriginal - 1) / (lengthResized - 1));\n                    let fract =\n                        ${t}(xResized * (lengthOriginal - 1) % (lengthResized - 1)) / ${t}(lengthResized - 1);\n                    return whole + fract;\n                  }`;case"tf_crop_and_resize":return`if (lengthResized > 1) {\n                    return ${t}(roiStart) * ${t}(lengthOriginal - 1) +\n                        (${t}(xResized) * ${t}(roiEnd - roiStart) * ${t}(lengthOriginal - 1)) /\n                        ${t}(lengthResized - 1);\n                  } else {\n                    return 0.5 * ${t}(roiStart + roiEnd) * ${t}(lengthOriginal - 1);\n                  }`;case"half_pixel_symmetric":return`const outputWidth = ${t}xScale * ${t}(lengthResized);\n                  const adjustment = ${t}(lengthResized) / outputWidth;\n                  const center = ${t}(lengthOriginal) / 2;\n                  const offset = center * (1 - adjustment);\n                  return offset + ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;case"half_pixel":return`return ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+"}",sc=(e,t,r)=>`fn getNearestPixelFromOriginal(xOriginal: ${r}, isDownSample: bool) -> ${r} {`+(()=>{switch(e){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(t<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${e} is not supported`)}})()+"}",uc=(e,t,r)=>{let o=new Array(r).fill(0).concat(new Array(r).fill(1)),n=e.length===0?o:e.slice();return t.length>0?(t.forEach((s,u)=>{o[s]=n[u],o[u+r]=n[t.length+u]}),o):n},dc=(e,t,r,o)=>{let n=[];if(r.length>0)if(o.length>0){if(e.forEach(s=>n.push(s)),Math.max(...o)>e.length)throw new Error("axes is out of bound");o.forEach((s,u)=>n[s]=r[u])}else r.forEach(s=>n.push(s));else{if(t.length===0)throw new Error("Resize requires either scales or sizes.");n=e.map((s,u)=>Math.round(s*t[u]))}return n},lc=(e,t,r)=>{let o=(()=>{switch(r.keepAspectRatioPolicy){case"not_larger":return r.axes.length>0?Math.min(...r.axes.map(s=>t[s]),Number.MAX_VALUE):Math.min(...t,Number.MAX_VALUE);case"not_smaller":return r.axes.length>0?Math.max(...r.axes.map(s=>t[s]),Number.MIN_VALUE):Math.max(...t,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${r.keepAspectRatioPolicy} is not supported`)}})();t.fill(1,0,t.length);let n=e.slice();return r.axes.length>0?(r.axes.forEach(s=>t[s]=o),r.axes.forEach(s=>n[s]=Math.round(e[s]*t[s]))):(t.fill(o,0,t.length),n.forEach((s,u)=>n[u]=Math.round(s*t[u]))),n},cc=(e,t,r,o,n)=>`\n    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${e.type.indices}) -> array<${e.type.value}, ${r.length}> {\n      var original_indices: array<${e.type.value}, ${r.length}>;\n      for (var i:u32 = 0; i < ${r.length}; i++) {\n        var output_index = ${e.indicesGet("output_indices","i")};\n        var scale = ${ce("uniforms.scales","i",o)};\n        var roi_low = ${ce("uniforms.roi","i",n)};\n        var roi_hi = ${ce("uniforms.roi",`i + ${t.length}`,n)};\n        if (scale == 1.0) {\n          original_indices[i] = ${e.type.value}(output_index);\n        } else {\n          var input_shape_i = ${ce("uniforms.input_shape","i",t.length)};\n          var output_shape_i = ${ce("uniforms.output_shape","i",r.length)};\n          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                           input_shape_i, roi_low, roi_hi);\n        }\n      }\n      return original_indices;\n    }`,pc=(e,t,r,o,n,s,u)=>`\n    fn calculateInputIndicesFromOutputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\n      var input_indices: ${e.type.indices};\n      for (var i:u32 = 0; i < ${o.length}; i++) {\n        var output_index = ${t.indicesGet("output_indices","i")};\n        var input_index: u32;\n        var scale = ${ce("uniforms.scales","i",n)};\n        if (scale == 1.0) {\n          input_index = output_index;\n        } else {\n          var roi_low = ${ce("uniforms.roi","i",s)};\n          var roi_hi = ${ce("uniforms.roi",`i + ${r.length}`,s)};\n          var input_shape_i = ${ce("uniforms.input_shape","i",r.length)};\n          var output_shape_i = ${ce("uniforms.output_shape","i",o.length)};\n          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                        input_shape_i, roi_low, roi_hi);\n          if (!${u} || (original_idx >= 0 && original_idx < ${t.type.value}(input_shape_i))) {\n            if (original_idx < 0) {\n              input_index = 0;\n            } else if (original_idx > ${t.type.value}(input_shape_i - 1)) {\n              input_index = input_shape_i - 1;\n            } else {\n              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));\n            }\n          } else {\n            input_index = u32(original_idx);\n          }\n        }\n        ${e.indicesSet("input_indices","i"," input_index")}\n      }\n      return input_indices;\n    }`,mc=(e,t)=>`\n    fn checkInputIndices(input_indices: ${e.type.indices}) -> bool {\n      for (var i:u32 = 0; i < ${t.length}; i++) {\n        var input_index = ${e.indicesGet("input_indices","i")};\n        if (input_index < 0 || input_index >= ${ce("uniforms.input_shape","i",t.length)}) {\n          return false;\n        }\n      }\n      return true;\n    }`,Ys=(e,t,r,o)=>e.rank>o?`\n    ${e.indicesSet("input_indices",t,"channel")};\n    ${e.indicesSet("input_indices",r,"batch")};\n`:"",fc=(e,t,r,o,n)=>{let[u,l,a,p]=r.length===2?[-1,0,1,-1]:[0,2,3,1],h=e.type.value;return`\n    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${h} {\n      var input_indices: ${e.type.indices};\n      ${e.indicesSet("input_indices",l,`max(0, min(row, ${r[l]} - 1))`)};\n      ${e.indicesSet("input_indices",a,`max(0, min(col, ${r[a]} - 1))`)};\n      ${Ys(e,p,u,2)}\n      return ${e.getByIndices("input_indices")};\n    }\n\n    fn bilinearInterpolation(output_indices: ${t.type.indices}) -> ${h} {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\n      var row:${h} = originalIndices[${l}];\n      var col:${h} = originalIndices[${a}];\n      ${o?`if (row < 0 || row > (${r[l]} - 1) || col < 0 || col > (${r[a]} - 1)) {\n        return ${n};\n      }`:""};\n      row = max(0, min(row, ${r[l]} - 1));\n      col = max(0, min(col, ${r[a]} - 1));\n      var row1: u32 = u32(row);\n      var col1: u32 = u32(col);\n      var row2: u32 = u32(row + 1);\n      var col2: u32 = u32(col + 1);\n      var channel: u32 = ${r.length>2?`u32(originalIndices[${p}])`:"0"};\n      var batch: u32 =  ${r.length>2?`u32(originalIndices[${u}])`:"0"};\n      var x11: ${h} = getInputValue(batch, channel, row1, col1);\n      var x12: ${h} = getInputValue(batch, channel, row1, col2);\n      var x21: ${h} = getInputValue(batch, channel, row2, col1);\n      var x22: ${h} = getInputValue(batch, channel, row2, col2);\n      var dx1: ${h} = abs(row - ${h}(row1));\n      var dx2: ${h} = abs(${h}(row2) - row);\n      var dy1: ${h} = abs(col - ${h}(col1));\n      var dy2: ${h} = abs(${h}(col2) - col);\n      if (row1 == row2) {\n        dx1 = 0.5;\n        dx2 = 0.5;\n      }\n      if (col1 == col2) {\n        dy1 = 0.5;\n        dy2 = 0.5;\n      }\n      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);\n    }`},hc=(e,t,r,o,n,s,u,l,a,p)=>{let h=r.length===2,g=!0,[b,w]=h?[0,1]:g?[2,3]:[1,2],y=e.type.value,_=I=>{let $=I===b?"row":"col";return`\n      fn ${$}CubicInterpolation(input_indices: ${e.type.indices}, output_indices: ${t.type.indices}) -> ${y} {\n        var output_index = ${t.indicesGet("output_indices",I)};\n        var originalIdx: ${y} = getOriginalCoordinateFromResizedCoordinate(output_index, ${n[I]},\n        ${o[I]}, ${r[I]}, ${s[I]}, ${s[I]} + ${r.length});\n        var fractOriginalIdx: ${y} = originalIdx - floor(originalIdx);\n        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);\n\n        if (${l} && (originalIdx < 0 || originalIdx > (${r[I]} - 1))) {\n          return ${a};\n        }\n        var data: array<${y}, 4> = array<${y}, 4>(0.0, 0.0, 0.0, 0.0);\n        for (var i: i32 = -1; i < 3; i++) {\n          var ${$}: ${y} = originalIdx + ${y}(i);\n          if (${$} < 0 || ${$} >= ${r[I]}) {\n            ${(()=>p?`coefs[i + 1] = 0.0;\n                        continue;`:l?`return ${a};`:`${$} = max(0, min(${$}, ${r[I]} - 1));`)()};\n          }\n        var input_indices_copy: ${e.type.indices} = input_indices;\n          ${e.indicesSet("input_indices_copy",I,`u32(${$})`)};\n          data[i + 1] = ${I===b?e.getByIndices("input_indices_copy"):"rowCubicInterpolation(input_indices_copy, output_indices)"};\n        }\n        return cubicInterpolation1D(data, coefs);\n      }`};return`\n    ${_(b)};\n    ${_(w)};\n  fn getCubicInterpolationCoefs(s: ${y}) -> array<${y}, 4> {\n    var absS = abs(s);\n    var coeffs: array<${y}, 4> = array<${y}, 4>(0.0, 0.0, 0.0, 0.0);\n    var oneMinusAbsS: ${y} = 1.0 - absS;\n    var twoMinusAbsS: ${y} = 2.0 - absS;\n    var onePlusAbsS: ${y} = 1.0 + absS;\n    coeffs[0] = ((${u} * onePlusAbsS - 5 * ${u}) * onePlusAbsS + 8 * ${u}) * onePlusAbsS - 4 * ${u};\n    coeffs[1] = ((${u} + 2) * absS - (${u} + 3)) * absS * absS + 1;\n    coeffs[2] = ((${u} + 2) * oneMinusAbsS - (${u} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;\n    coeffs[3] = ((${u} * twoMinusAbsS - 5 * ${u}) * twoMinusAbsS + 8 * ${u}) * twoMinusAbsS - 4 * ${u};\n    return coeffs;\n  }\n\n  fn cubicInterpolation1D(x: array<${y}, 4>, coefs: array<${y}, 4>) -> ${y} {\n    var coefsSum: ${y} = coefs[0] + coefs[1] + coefs[2] + coefs[3];\n    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;\n  }\n\n  fn bicubicInterpolation(output_indices: ${t.type.indices}) -> ${y} {\n    var input_indices: ${e.type.indices} = output_indices;\n    return colCubicInterpolation(input_indices, output_indices);\n  }\n    `},gc=(e,t,r,o,n)=>{let[u,l,a,p,h]=r.length===3?[-1,0,1,2,-1]:[0,2,3,4,1],g=e.type.value;return`\n    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${g} {\n      var input_indices: ${e.type.indices};\n      ${e.indicesSet("input_indices",l,`max(0, min(depth, ${r[l]} - 1))`)};\n      ${e.indicesSet("input_indices",a,`max(0, min(height, ${r[a]} - 1))`)};\n      ${e.indicesSet("input_indices",p,`max(0, min(width, ${r[p]} - 1))`)};\n      ${Ys(e,h,u,3)}\n      return ${e.getByIndices("input_indices")};\n    }\n\n    fn trilinearInterpolation(output_indices: ${t.type.indices}) -> ${g} {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\n      var depth:${g} = originalIndices[${l}];\n      var height:${g} = originalIndices[${a}];\n      var width:${g} = originalIndices[${p}];\n      ${o?`if (depth < 0 || depth > (${r[l]} - 1) || height < 0 || height > (${r[a]} - 1) || width < 0 || (width > ${r[p]} - 1)) {\n      return ${n};\n        }`:""};\n\n    depth = max(0, min(depth, ${r[l]} - 1));\n      height = max(0, min(height, ${r[a]} - 1));\n      width = max(0, min(width, ${r[p]} - 1));\n      var depth1: u32 = u32(depth);\n      var height1: u32 = u32(height);\n      var width1: u32 = u32(width);\n      var depth2: u32 = u32(depth + 1);\n      var height2: u32 = u32(height + 1);\n      var width2: u32 = u32(width + 1);\n      var channel: u32 = ${r.length>3?`u32(originalIndices[${h}])`:"0"};\n      var batch: u32 =  ${r.length>3?`u32(originalIndices[${u}])`:"0"};\n\n      var x111: ${g} = getInputValue(batch, channel, depth1, height1, width1);\n      var x112: ${g} = getInputValue(batch, channel, depth1, height1, width2);\n      var x121: ${g} = getInputValue(batch, channel, depth1, height2, width1);\n      var x122: ${g} = getInputValue(batch, channel, depth1, height2, width2);\n      var x211: ${g} = getInputValue(batch, channel, depth2, height1, width1);\n      var x212: ${g} = getInputValue(batch, channel, depth2, height1, width2);\n      var x221: ${g} = getInputValue(batch, channel, depth2, height2, width1);\n      var x222: ${g} = getInputValue(batch, channel, depth2, height2, width2);\n      var dx1: ${g} = abs(depth - ${g}(depth1));\n      var dx2: ${g} = abs(${g}(depth2) - depth);\n      var dy1: ${g} = abs(height - ${g}(height1));\n      var dy2: ${g} = abs(${g}(height2) - height);\n      var dz1: ${g} = abs(width - ${g}(width1));\n      var dz2: ${g} = abs(${g}(width2) - width);\n      if (depth1 == depth2) {\n        dx1 = 0.5;\n        dx2 = 0.5;\n      }\n      if (height1 == height2) {\n        dy1 = 0.5;\n        dy2 = 0.5;\n      }\n      if (width1 == width2) {\n        dz1 = 0.5;\n        dz2 = 0.5;\n      }\n      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +\n              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);\n    }`},yc=(e,t,r,o,n,s)=>{let u=e.dims,l=uc(s,t.axes,u.length),a=dc(u,o,n,t.axes),p=o.slice();o.length===0&&(p=u.map((x,E)=>x===0?1:a[E]/x),t.keepAspectRatioPolicy!=="stretch"&&(a=lc(u,p,t)));let h=F("output",e.dataType,a.length),g=M("input",e.dataType,u.length),b=U.size(a),w=u.length===a.length&&u.every((x,E)=>x===a[E]),y=t.coordinateTransformMode==="tf_crop_and_resize",_=t.extrapolationValue,I=g.type.value,$=x=>`\n      ${w?"":`\n      ${ic(t.coordinateTransformMode,I)};\n      ${(()=>{switch(t.mode){case"nearest":return`\n              ${mc(g,u)};\n              ${sc(t.nearestMode,r,I)};\n              ${pc(g,h,u,a,p.length,l.length,y)};\n              `;case"linear":return`\n              ${cc(h,u,a,p.length,l.length)};\n              ${(()=>{if(u.length===2||u.length===4)return`${fc(g,h,u,y,_)}`;if(u.length===3||u.length===5)return`${gc(g,h,u,y,_)}`;throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.")})()};\n            `;case"cubic":return`\n            ${(()=>{if(u.length===2||u.length===4)return`${hc(g,h,u,a,p,l,t.cubicCoeffA,y,t.extrapolationValue,t.excludeOutside)}`;throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.")})()};\n            `;default:throw Error("Invalid resize mode")}})()};\n      `}\n      ${x.registerUniform("output_size","u32").registerUniform("scales","f32",p.length).registerUniform("roi","f32",l.length).declareVariables(g,h)}\n      ${x.mainStart()}\n        ${x.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n        ${w?"output[global_idx] = input[global_idx];":`\n        let output_indices = ${h.offsetToIndices("global_idx")};\n        var input_indices: ${g.type.indices};\n        ${(()=>{switch(t.mode){case"nearest":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);\n                if (checkInputIndices(input_indices)) {\n                  output[global_idx] = ${g.getByIndices("input_indices")};\n                } else {\n                  output[global_idx] = ${t.extrapolationValue};\n                }`;case"linear":return`output[global_idx] = ${u.length===2||u.length===4?"bilinearInterpolation":"trilinearInterpolation"}(output_indices);`;case"cubic":return"output[global_idx] = bicubicInterpolation(output_indices);";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};\n`}\n      }`;return{name:"Resize",shaderCache:{hint:`${t.cacheKey}|${r}|${p.length>0?p:""}|${n.length>0?n:""}|${l.length>0?l:""}|${w}|${u}`,inputDependencies:["rank"]},getShaderSource:$,getRunData:()=>({outputs:[{dims:a,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(b/64)},programUniforms:[{type:"uint32",data:b},{type:"float32",data:p},{type:"float32",data:l},...L(u),...L(a)]})}},bc=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},Zs=(e,t)=>{let r=[],o=[],n=[],s=bc(e);if(t.antialias!==0)throw Error("Only default value (0) for Antialias attribute is supported");ac(e.inputs,t,s,r,o,n),e.compute(yc(e.inputs[0],t,s,r,o,n),{inputs:[0]})},Qs=e=>{let t=e.antialias,r=e.axes,o=e.coordinateTransformMode,n=e.cubicCoeffA,s=e.excludeOutside!==0,u=e.extrapolationValue,l=e.keepAspectRatioPolicy,a=e.mode,p=e.nearestMode===""?"simple":e.nearestMode;return ge({antialias:t,axes:r,coordinateTransformMode:o,cubicCoeffA:n,excludeOutside:s,extrapolationValue:u,keepAspectRatioPolicy:l,mode:a,nearestMode:p})}});var wc,vc,Js,eu,tu=j(()=>{"use strict";Ne();$e();je();ve();wc=e=>{if(!e||e.length<3)throw new Error("layerNorm requires at least 3 inputs.");let t=e[0],r=e[1],o=e[2];if(t.dataType!==r.dataType||t.dataType!==o.dataType)throw new Error("All inputs must have the same data type");if(t.dims.length!==3&&t.dims.length!==2)throw new Error("Input must be 2D or 3D");if(r.dims.length!==3&&r.dims.length!==2)throw new Error("Skip must be 2D or 3D");let n=t.dims[t.dims.length-1],s=t.dims[t.dims.length-2];if(r.dims[r.dims.length-1]!==n)throw new Error("Skip must have the same hidden size as input");if(r.dims[r.dims.length-2]!==s)throw new Error("Skip must have the same sequence length as input");if(o.dims.length!==1)throw new Error("Gamma must be 1D");if(o.dims[o.dims.length-1]!==n)throw new Error("Gamma must have the same hidden size as input");if(e.length>3){let u=e[3];if(u.dims.length!==1)throw new Error("Beta must be 1D");if(u.dims[u.dims.length-1]!==n)throw new Error("Beta must have the same hidden size as input")}if(e.length>4){let u=e[4];if(u.dims.length!==1)throw new Error("Bias must be 1D");if(u.dims[u.dims.length-1]!==n)throw new Error("Bias must have the same hidden size as input")}},vc=(e,t,r,o)=>{let n=e[0].dims,s=U.size(n),u=n,l=s,a=n.slice(-1)[0],p=o?n.slice(0,-1).concat(1):[],h=e.length>3,g=e.length>4,b=o&&r>1,w=o&&r>2,y=r>3,_=Fe(a),I=[M("x",e[0].dataType,e[0].dims,_),M("skip",e[1].dataType,e[1].dims,_),M("gamma",e[2].dataType,e[2].dims,_)];h&&I.push(M("beta",e[3].dataType,e[3].dims,_)),g&&I.push(M("bias",e[4].dataType,e[4].dims,_)),I.push(F("output",e[0].dataType,u,_)),b&&I.push(F("meanOutput",1,p)),w&&I.push(F("invStdOutput",1,p)),y&&I.push(F("inputSkipBiasSum",e[0].dataType,u,_));let $=Le(e[0].dataType),x=A=>`\n      const hiddenSize: f32 = ${a};\n      const hiddenSizeVectorized: u32 = ${a/_};\n      const epsilon: f32 = ${t.epsilon};\n\n      ${A.declareVariables(...I)}\n\n      ${A.mainStart()}\n        ${A.guardAgainstOutOfBoundsWorkgroupSizes(l/a)}\n        let offset = global_idx * hiddenSizeVectorized;\n        var sum = ${Ze("f32",_)};\n        var squareSum = ${Ze("f32",_)};\n        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {\n          let skipValue = skip[offset + i];\n          let biasValue = ${g?"bias[i]":"0.0"};\n          let inputValue = x[offset + i];\n          let value = inputValue + skipValue + biasValue;\n          ${y?"inputSkipBiasSum[offset + i] = value;":""}\n          output[offset + i] = value;\n          let f32Value = ${at($,_,"value")};\n          sum += f32Value;\n          squareSum += f32Value * f32Value;\n        }\n        let mean = ${Je("sum",_)} / hiddenSize;\n        let invStdDev = inverseSqrt(${Je("squareSum",_)} / hiddenSize - mean * mean + epsilon);\n        ${b?"meanOutput[global_idx] = mean;":""}\n        ${w?"invStdOutput[global_idx] = invStdDev;":""}\n        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {\n          output[offset + i] = (output[offset + i] - ${$}(mean)) * ${$}(invStdDev) * gamma[i]\n           + ${h?"beta[i]":"0.0"};\n        }\n      }`,E=[{dims:u,dataType:e[0].dataType}];return r>1&&E.push({dims:p,dataType:1}),r>2&&E.push({dims:p,dataType:1}),r>3&&E.push({dims:n,dataType:e[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:t.cacheKey},getShaderSource:x,getRunData:()=>({outputs:E,dispatchGroup:{x:Math.ceil(l/a/64)}})}},Js=(e,t)=>{wc(e.inputs);let o=[0];e.outputCount>1&&o.push(-3),e.outputCount>2&&o.push(-3),e.outputCount>3&&o.push(3),e.compute(vc(e.inputs,t,e.outputCount,!1),{outputs:o})},eu=e=>{let t=e.epsilon;return ge({epsilon:t})}});var $c,on,Sc,ru,xc,_c,nu,ou,au=j(()=>{"use strict";Ne();$e();je();ve();$c=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");if(t.axes.length!==0){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(t.starts.length!==t.ends.length)throw new Error("starts and ends must have the same length");e.slice(1).forEach((r,o)=>{if(e[o+1].dataType!==6&&e[o+1].dataType!==7)throw new Error(`Input ${o} must be an array of int32 or int64`)})},on=(e,t)=>{let r=[];if(e.length>t)if(e[t].dataType===7)e[t].getBigInt64Array().forEach(o=>r.push(Number(o)));else if(e[t].dataType===6)e[t].getInt32Array().forEach(o=>r.push(Number(o)));else throw new Error(`Input ${t} must be an array of int32 or int64`);return r},Sc=(e,t)=>{if(e.length>1){let r=on(e,1),o=on(e,2),n=on(e,3);return n.length===0&&(n=[...Array(e[0].dims.length).keys()]),ge({starts:r,ends:o,axes:n})}else return t},ru=(e,t,r,o,n)=>{let s=e;return e<0&&(s+=r[o[t]]),n[t]<0?Math.max(0,Math.min(s,r[o[t]]-1)):Math.max(0,Math.min(s,r[o[t]]))},xc=(e,t,r)=>`fn calculateInputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\n          var input_indices: ${e.type.indices};\n          var carry = 0u;\n          for (var i = ${r.length}; i >= 0; i--) {\n            let input_shape_i = ${ce("uniforms.input_shape","i",r.length)};\n            let steps_i = ${ce("uniforms.steps","i",r.length)};\n            let signs_i = ${ce("uniforms.signs","i",r.length)};\n            let starts_i = ${ce("uniforms.starts","i",r.length)};\n            var output_index = ${t.indicesGet("output_indices","i")};\n            var input_index = output_index * steps_i + starts_i + carry;\n            carry = input_index / input_shape_i;\n            input_index = input_index % input_shape_i;\n            if (signs_i < 0) {\n              input_index = input_shape_i - input_index - 1u + starts_i;\n            }\n            ${e.indicesSet("input_indices","i","input_index")};\n          }\n          return input_indices;\n      }`,_c=(e,t)=>{let r=e[0].dims,o=U.size(r),n=t.axes.length>0?U.normalizeAxes(t.axes,r.length):[...Array(r.length).keys()],s=on(e,4);s.forEach($=>$!==0||(()=>{throw new Error("step cannot be 0")})),s.length===0&&(s=Array(n.length).fill(1));let u=t.starts.map(($,x)=>ru($,x,r,n,s)),l=t.ends.map(($,x)=>ru($,x,r,n,s));if(n.length!==u.length||n.length!==l.length)throw new Error("start, ends and axes should have the same number of elements");if(n.length!==r.length)for(let $=0;$<r.length;++$)n.includes($)||(u.splice($,0,0),l.splice($,0,r[$]),s.splice($,0,1));let a=s.map($=>Math.sign($));s.forEach(($,x,E)=>{if($<0){let A=(l[x]-u[x])/$,z=u[x],R=z+A*s[x];u[x]=R,l[x]=z,E[x]=-$}});let p=r.slice(0);n.forEach(($,x)=>{p[$]=Math.ceil((l[$]-u[$])/s[$])});let h={dims:p,dataType:e[0].dataType},g=F("output",e[0].dataType,p.length),b=M("input",e[0].dataType,e[0].dims.length),w=U.size(p),y=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:u.length},{name:"signs",type:"i32",length:a.length},{name:"steps",type:"u32",length:s.length}],_=[{type:"uint32",data:w},{type:"uint32",data:u},{type:"int32",data:a},{type:"uint32",data:s},...L(e[0].dims),...L(p)],I=$=>`\n      ${$.registerUniforms(y).declareVariables(b,g)}\n        ${xc(b,g,r)}\n        ${$.mainStart()}\n          ${$.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n          let output_indices = ${g.offsetToIndices("global_idx")};\n          let input_indices = calculateInputIndices(output_indices);\n          ${g.setByOffset("global_idx",b.getByIndices("input_indices"))}\n      }`;return{name:"Slice",shaderCache:{hint:`${a.length}_${u.length}_${s.length}`,inputDependencies:["rank"]},getShaderSource:I,getRunData:()=>({outputs:[h],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:_})}},nu=(e,t)=>{$c(e.inputs,t);let r=Sc(e.inputs,t);e.compute(_c(e.inputs,r),{inputs:[0]})},ou=e=>{let t=e.starts,r=e.ends,o=e.axes;return ge({starts:t,ends:r,axes:o})}});var Cc,Ic,iu,su,uu=j(()=>{"use strict";$e();je();ve();Cc=e=>{if(!e||e.length!==1)throw new Error("Softmax op requires 1 input.")},Ic=(e,t)=>{let r=e.dims,o=U.size(r),n=64,s=t.axis;if(s<0&&(s=r.length+s),s<r.length-1)throw new Error("softmax only supports last axis for now.");let u=r[s],l=o/u,a=Fe(u),p=u/a,h=(I,$)=>$===4?`max(max(${I}.x, ${I}.y), max(${I}.z, ${I}.w))`:$===2?`max(${I}.x, ${I}.y)`:$===3?`max(max(${I}.x, ${I}.y), ${I}.z)`:I,g=M("x",e.dataType,e.dims,a),b=F("result",e.dataType,e.dims,a),w=g.type.value,y=Le(e.dataType)==="f32"?`var threadMax = ${w}(-3.402823e+38f);`:`var threadMax = ${w}(-65504.0h);`,_=I=>`\n      var<workgroup> rowMaxShared : ${w};\n      var<workgroup> rowSumShared : ${w};\n      var<workgroup> threadShared : array<${w}, ${n}>;\n\n      fn getValue(row: i32, col: i32, row_stride: i32) -> ${w} {\n        let index = row * row_stride + col;\n        return x[index];\n      }\n\n      fn setValue(row: i32, col: i32, row_stride: i32, value: ${w}) {\n        let index = row * row_stride + col;\n        result[index] = value;\n      }\n      ${I.registerUniform("packedCols","i32").declareVariables(g,b)}\n      ${I.mainStart()}\n        let gindex = i32(global_idx);\n        let lindex = i32(local_idx);\n        const wg = ${n};\n        let row = gindex / wg;\n        let cols = uniforms.packedCols;\n        let row_stride : i32 = uniforms.packedCols;\n\n        // find the rows max\n        ${y}\n        for (var col = lindex; col < cols; col += wg) {\n          let value = getValue(row, col, row_stride);\n          threadMax = max(threadMax, value);\n        }\n        if (lindex < cols) {\n          threadShared[lindex] = threadMax;\n        }\n        workgroupBarrier();\n\n        var reduceSize = min(cols, wg);\n        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n          reduceSize = currSize + (reduceSize & 1);\n          if (lindex < currSize) {\n            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowMaxShared = ${w}(${h("threadShared[0]",a)});\n        }\n        workgroupBarrier();\n\n        // find the rows sum\n        var threadSum = ${w}(0.0);\n        for (var col = lindex; col < cols; col += wg) {\n          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);\n          threadSum += subExp;\n        }\n        threadShared[lindex] = threadSum;\n        workgroupBarrier();\n\n        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {\n          if (lindex < currSize) {\n            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowSumShared = ${w}(${Je("threadShared[0]",a)});\n        }\n        workgroupBarrier();\n\n        // calculate final value for each element in the row\n        for (var col = lindex; col < cols; col += wg) {\n          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;\n          setValue(row, col, row_stride, value);\n        }\n      }`;return{name:"Softmax",shaderCache:{hint:`${a}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:r,dataType:e.dataType}],dispatchGroup:{x:l},programUniforms:[{type:"uint32",data:p}]}),getShaderSource:_}},iu=(e,t)=>{Cc(e.inputs),e.compute(Ic(e.inputs[0],t))},su=e=>ge({axis:e.axis})});var Ac,Tc,Ec,Oc,Pc,du,lu,cu=j(()=>{"use strict";$e();je();ve();Ac=e=>{if(!e||e.length<1)throw new Error("too few inputs")},Tc=(e,t)=>{let r=[],o=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach(n=>r.push(Number(n))),o=r.length),ge({numOutputs:o,axis:t.axis,splitSizes:r})},Ec=e=>`\nfn calculateOutputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\n    if (index < ${ce("uniforms.size_in_split_axis","i",e)}) {\n        return i;\n    }\n    }\n    return ${e}u;\n}`,Oc=e=>{let t=e.length,r=[];for(let o=0;o<t;++o){let n=e[o].setByIndices("indices","input[global_idx]");t===1?r.push(n):o===0?r.push(`if (output_number == ${o}u) { ${n} }`):o===t-1?r.push(`else { ${n} }`):r.push(`else if (output_number == ${o}) { ${n} }`)}return`\n      fn writeBufferData(output_number: u32, indices: ${e[0].type.indices}, global_idx: u32) {\n        ${r.join(`\n`)}\n      }`},Pc=(e,t)=>{let r=e[0].dims,o=U.size(r),n=e[0].dataType,s=U.normalizeAxis(t.axis,r.length),u=new Array(t.numOutputs),l=M("input",n,r),a=new Array(t.numOutputs),p=[],h=[],g=0,b=[{type:"uint32",data:o}];for(let y=0;y<t.numOutputs;y++){g+=t.splitSizes[y],a[y]=g;let _=r.slice();_[t.axis]=t.splitSizes[y],h.push(_),u[y]=F(`output${y}`,n,_),p.push({dims:h[y],dataType:e[0].dataType})}b.push({type:"uint32",data:a}),b.push(...L(r)),h.forEach(y=>b.push(...L(y)));let w=y=>`\n  ${y.registerUniform("input_size","u32").registerUniform("size_in_split_axis","u32",a.length).declareVariables(l,...u)}\n  ${Ec(a.length)}\n  ${Oc(u)}\n\n  ${y.mainStart()}\n    ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}\n\n    var indices = ${l.offsetToIndices("global_idx")};\n    var index = ${l.indicesGet("indices",s)};\n    let output_number = calculateOutputIndex(index);\n    if (output_number != 0) {\n      index -= ${ce("uniforms.size_in_split_axis","output_number - 1u",a.length)};\n      ${l.indicesSet("indices",s,"index")};\n    }\n    writeBufferData(output_number, indices, global_idx);\n  }`;return{name:"Split",shaderCache:{hint:t.cacheKey,inputDependencies:["rank"]},getShaderSource:w,getRunData:()=>({outputs:p,dispatchGroup:{x:Math.ceil(o/64)},programUniforms:b})}},du=(e,t)=>{Ac(e.inputs);let r=e.inputs.length===1?t:Tc(e.inputs,t);e.compute(Pc(e.inputs,r),{inputs:[0]})},lu=e=>{let t=e.axis,r=e.splitSizes,o=e.numOutputs<0?r.length:e.numOutputs;if(o!==r.length)throw new Error("numOutputs and splitSizes lengh must be equal");return ge({axis:t,numOutputs:o,splitSizes:r})}});var pu,kc,Rc,Bc,mu,fu=j(()=>{"use strict";Ne();$e();ve();pu=e=>Array.from(e.getBigInt64Array(),Number),kc=e=>{if(!e||e.length!==2)throw new Error("Tile requires 2 inputs.");if(e[0].dataType!==1&&e[0].dataType!==6&&e[0].dataType!==12)throw new Error("Tile only support float, int32, and uint32 data types");if(e[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(e[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(pu(e[1]).length!==e[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},Rc=(e,t)=>{let r=[];for(let o=0;o<e.length;++o)r.push(e[o]*t[o]);return r},Bc=e=>{let t=e[0].dims,r=pu(e[1]),o=Rc(t,r),n=U.size(o),s=e[0].dataType,u=M("input",s,t.length),l=F("output",s,o.length),a=p=>`\n      const inputShape = ${u.indices(...t)};\n      ${p.registerUniform("output_size","u32").declareVariables(u,l)}\n      ${p.mainStart()}\n      ${p.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n      let output_indices = ${l.offsetToIndices("global_idx")};\n      var input_indices: ${u.type.indices};\n      for (var i = 0; i < ${t.length}; i++) {\n        let input_dim_i = ${u.indicesGet("uniforms.input_shape","i")};\n        let input_dim_value = ${l.indicesGet("output_indices","i")}  % input_dim_i;\n\n        ${u.indicesSet("input_indices","i","input_dim_value")}\n      }\n      ${l.setByOffset("global_idx",u.getByIndices("input_indices"))}\n    }`;return{name:"Tile",shaderCache:{hint:`${r}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(n/64)},programUniforms:[{type:"uint32",data:n},...L(e[0].dims),...L(o)]}),getShaderSource:a}},mu=e=>{kc(e.inputs),e.compute(Bc(e.inputs),{inputs:[0]})}});var Dc,Mc,hu,gu=j(()=>{"use strict";Ne();$e();ve();Dc=(e,t,r,o,n)=>{let s=F("output_data",n,r.length,4),u=M("a_data",t[1].dataType,t[1].dims.length,4),l=M("b_data",t[2].dataType,t[2].dims.length,4),a=M("c_data",t[0].dataType,t[0].dims.length,4),p,h=(g,b,w)=>`select(${b}, ${g}, ${w})`;if(!o)p=s.setByOffset("global_idx",h(u.getByOffset("global_idx"),l.getByOffset("global_idx"),a.getByOffset("global_idx")));else{let g=(b,w,y="")=>{let _=`a_data[index_a${w}][component_a${w}]`,I=`b_data[index_b${w}][component_b${w}]`,$=`bool(c_data[index_c${w}] & ${4278190080>>>(3-w)*8}u)`;return`\n            let output_indices${w} = ${s.offsetToIndices(`global_idx * 4u + ${w}u`)};\n            let offset_a${w} = ${u.broadcastedIndicesToOffset(`output_indices${w}`,s)};\n            let offset_b${w} = ${l.broadcastedIndicesToOffset(`output_indices${w}`,s)};\n            let offset_c${w} = ${a.broadcastedIndicesToOffset(`output_indices${w}`,s)};\n            let index_a${w} = offset_a${w} / 4u;\n            let index_b${w} = offset_b${w} / 4u;\n            let index_c${w} = offset_c${w} / 4u;\n            let component_a${w} = offset_a${w} % 4u;\n            let component_b${w} = offset_b${w} % 4u;\n            ${b}[${w}] = ${y}(${h(_,I,$)});\n          `};n===9?p=`\n            var data = vec4<u32>(0);\n            ${g("data",0,"u32")}\n            ${g("data",1,"u32")}\n            ${g("data",2,"u32")}\n            ${g("data",3,"u32")}\n            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:p=`\n            ${g("output_data[global_idx]",0)}\n            ${g("output_data[global_idx]",1)}\n            ${g("output_data[global_idx]",2)}\n            ${g("output_data[global_idx]",3)}\n          `}return`\n        ${e.registerUniform("vec_size","u32").declareVariables(a,u,l,s)}\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n        ${p}\n      }`},Mc=e=>{let t=e[1].dims,r=e[2].dims,o=e[0].dims,n=e[1].dataType,s=!(U.areEqual(t,r)&&U.areEqual(r,o)),u=t,l=U.size(t);if(s){let p=dt.calcShape(dt.calcShape(t,r,!1),o,!1);if(!p)throw new Error("Can\'t perform where op on the given tensors");u=p,l=U.size(u)}let a=Math.ceil(l/4);return{name:"Where",shaderCache:{inputDependencies:["rank","rank","rank"]},getShaderSource:p=>Dc(p,e,u,s,n),getRunData:()=>({outputs:[{dims:u,dataType:n}],dispatchGroup:{x:Math.ceil(l/64/4)},programUniforms:[{type:"uint32",data:a},...L(o),...L(t),...L(r),...L(u)]})}},hu=e=>{e.compute(Mc(e.inputs))}});var yu,bu=j(()=>{"use strict";Wa();Un();La();ja();Ci();Mi();Vi();Gn();Ji();rs();ss();ls();ms();gs();ws();$s();xs();Fn();As();Es();js();Ks();jr();Xs();tu();au();uu();cu();fu();jt();Vn();gu();yu=new Map([["Abs",[qa]],["Acos",[Ka]],["Acosh",[Ya]],["Add",[Ii]],["ArgMax",[Na,zn]],["ArgMin",[Va,zn]],["Asin",[Za]],["Asinh",[Qa]],["Atan",[Xa]],["Atanh",[Ja]],["Attention",[Ha]],["AveragePool",[zs,Ms]],["BatchNormalization",[Ga]],["BiasAdd",[Fa]],["BiasSplitGelu",[_i]],["Cast",[ti,ei]],["Ceil",[ni]],["Clip",[ri]],["Concat",[zi,Ui]],["Conv",[qn,jn]],["ConvTranspose",[Xi,Qi]],["Cos",[oi]],["Cosh",[ai]],["CumSum",[es,ts]],["Div",[Ai]],["Einsum",[as,is]],["Elu",[ii,Yr]],["Equal",[Ti]],["Erf",[si]],["Exp",[ui]],["Expand",[ds]],["Floor",[di]],["FusedConv",[qn,jn]],["Gather",[ps,cs]],["GatherElements",[hs,fs]],["Gelu",[li]],["Gemm",[bs,ys]],["GlobalAveragePool",[Ns,Vs]],["GlobalMaxPool",[Fs,Ls]],["Greater",[ki]],["GreaterOrEqual",[Bi]],["InstanceNormalization",[vs]],["LayerNormalization",[Ss]],["LeakyRelu",[ci,Yr]],["Less",[Ri]],["LessOrEqual",[Di]],["Log",[xi]],["MatMul",[Li]],["MaxPool",[Hs,Gs]],["Mul",[Ei]],["MultiHeadAttention",[Is,Cs]],["Neg",[mi]],["Not",[pi]],["Pad",[Ts]],["Pow",[Oi]],["Range",[qs]],["Reciprocal",[fi]],["ReduceMin",[Ra]],["ReduceMean",[Ta]],["ReduceMax",[ka]],["ReduceSum",[Da]],["ReduceProd",[Ba]],["ReduceL1",[Ea]],["ReduceL2",[Oa]],["ReduceLogSum",[za]],["ReduceLogSumExp",[Pa]],["ReduceSumSquare",[Ma]],["Relu",[hi]],["Resize",[Zs,Qs]],["Sigmoid",[gi]],["Sin",[yi]],["Sinh",[bi]],["Slice",[nu,ou]],["SkipLayerNormalization",[Js,eu]],["Split",[du,lu]],["Sqrt",[wi]],["Softmax",[iu,su]],["Sub",[Pi]],["Tan",[vi]],["Tanh",[$i]],["ThresholdedRelu",[Si,Yr]],["Tile",[mu]],["Transpose",[ha,ga]],["Where",[hu]]])});var an,wu=j(()=>{"use strict";Lt();Ct();ve();an=class{constructor(t){this.backend=t;this.repo=new Map,this.attributesBound=!1}getArtifact(t){return this.repo.get(t)}setArtifact(t,r){this.repo.set(t,r)}run(t,r,o,n,s){kt(t.programInfo.name);let u=this.backend.device,l=this.backend.getComputePassEncoder();this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2),l.setPipeline(t.computePipeline);let a=[];for(let h of r)a.push({binding:a.length,resource:{buffer:h.buffer}});for(let h of o)a.push({binding:a.length,resource:{buffer:h.buffer}});s&&a.push({binding:a.length,resource:s});let p=u.createBindGroup({layout:t.computePipeline.getBindGroupLayout(0),entries:a,label:t.programInfo.name});l.setBindGroup(0,p),l.dispatchWorkgroups(...n),this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||this.backend.queryType==="at-passes")&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),Rt(t.programInfo.name)}dispose(){}build(t,r){kt(t.name);let o=this.backend.device,n=[];o.features.has("shader-f16")&&n.push("enable f16;");let s=ma(r),u=t.getShaderSource(s),l=`${n.join(`\n`)}\n${s.additionalImplementations}\n${u}`,a=o.createShaderModule({code:l,label:t.name});Be("verbose",()=>`[WebGPU] ${t.name} shader code: ${l}`);let p=o.createComputePipeline({compute:{module:a,entryPoint:"main"},layout:"auto",label:t.name});return Rt(t.name),{programInfo:t,computePipeline:p}}normalizeDispatchGroupSize(t){let r=typeof t=="number"?t:t.x,o=typeof t=="number"?1:t.y||1,n=typeof t=="number"?1:t.z||1,s=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(r<=s&&o<=s&&n<=s)return[r,o,n];let u=r*o*n,l=Math.ceil(Math.sqrt(u));if(l>s){if(l=Math.ceil(Math.cbrt(u)),l>s)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[l,l,l]}else return[l,l,1]}}});var zc,Uc,sn,vu=j(()=>{"use strict";Lt();Ne();Ct();ua();pa();bu();wu();zc=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let r=[];for(let o=0;o<e.length;++o){let n=e[o].dataType;switch(t[o]){case"none":{r.push("");break}case"type":{r.push(`${n}`);break}case"rank":{let s=e[o].dims.length;r.push(`${n};${s}`);break}case"dims":{let s=e[o].dims.join(",");r.push(`${n};${s}`);break}default:throw new Error(`unsupported input dependency: ${t[o]}`)}}return r.join("|")},Uc=(e,t,r)=>{let o=e.name;return e.shaderCache?.hint&&(o+="["+e.shaderCache.hint+"]"),o+=":"+r+`:${zc(t,e.shaderCache?.inputDependencies??new Array(t.length).fill("dims"))}`,o},sn=class{constructor(){this.currentKernelId=null;this.commandEncoder=null;this.computePassEncoder=null;this.maxDispatchNumber=16;this.pendingDispatchNumber=0;this.pendingKernels=[];this.pendingQueries=new Map;this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let t=this.kernelCustomData.get(this.currentKernelId);return t||(t={},this.kernelCustomData.set(this.currentKernelId,t)),t}async initialize(t,r){this.env=t;let o=[],n={requiredLimits:{maxComputeWorkgroupStorageSize:r.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.limits.maxStorageBufferBindingSize,maxBufferSize:r.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:r.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:r.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:r.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:r.limits.maxComputeWorkgroupSizeZ},requiredFeatures:o};r.features.has("chromium-experimental-timestamp-query-inside-passes")?o.push("chromium-experimental-timestamp-query-inside-passes"):r.features.has("timestamp-query")&&o.push("timestamp-query"),r.features.has("shader-f16")&&o.push("shader-f16"),this.device=await r.requestDevice(n),this.gpuDataManager=ca(this),this.programManager=new an(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,ia(t.logLevel,!!t.debug),this.device.onuncapturederror=s=>{s.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${s.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device}),this.setQueryType()}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder(),this.setQueryType(),this.queryType!=="none"&&typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.maxDispatchNumber*2}),this.queryResolveBuffer=this.device.createBuffer({size:this.maxDispatchNumber*2*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE}))),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let t={};this.queryType==="at-passes"&&(t.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:this.pendingDispatchNumber*2,endOfPassWriteIndex:this.pendingDispatchNumber*2+1}),this.computePassEncoder=this.getCommandEncoder().beginComputePass(t)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;kt(),this.endComputePass();let t;this.queryType!=="none"&&(this.commandEncoder.resolveQuerySet(this.querySet,0,this.pendingDispatchNumber*2,this.queryResolveBuffer,0),t=this.device.createBuffer({size:this.pendingDispatchNumber*2*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(t,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,t,0,this.pendingDispatchNumber*2*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,this.queryType!=="none"&&t.mapAsync(GPUMapMode.READ).then(()=>{let r=new BigUint64Array(t.getMappedRange()),o=this.pendingQueries.get(t);for(let n=0;n<r.length/2;n++){let s=o[n],u=s.kernelId,l=this.kernels.get(u),a=l.kernelType,p=l.kernelName,h=s.programName,g=s.inputTensorViews,b=s.outputTensorViews,w=r[n*2],y=r[n*2+1];typeof this.queryTimeBase>"u"&&(this.queryTimeBase=w);let _=Number(w-this.queryTimeBase),I=Number(y-this.queryTimeBase);if(!Number.isSafeInteger(_)||!Number.isSafeInteger(I))throw new RangeError("incorrect timestamp range");if(this.env.webgpu.profiling?.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:g.map($=>({dims:$.dims,dataType:Xe($.dataType)})),outputsMetadata:b.map($=>({dims:$.dims,dataType:Xe($.dataType)})),kernelId:u,kernelType:a,kernelName:p,programName:h,startTime:_,endTime:I});else{let $="";g.forEach((E,A)=>{$+=`input[${A}]: [${E.dims}] | ${Xe(E.dataType)}, `});let x="";b.forEach((E,A)=>{x+=`output[${A}]: [${E.dims}] | ${Xe(E.dataType)}, `}),console.log(`[profiling] kernel "${u}|${a}|${p}|${h}" ${$}${x}execution time: ${I-_} ns`)}An("GPU",`${h}::${w}::${y}`)}t.unmap(),this.pendingQueries.delete(t)}),Rt()}run(t,r,o,n,s){kt(t.name);let u=[];for(let x=0;x<r.length;++x){let E=this.gpuDataManager.get(r[x].data);if(!E)throw new Error(`no GPU data for input: ${r[x].data}`);u[x]=E}let{outputs:l,dispatchGroup:a,programUniforms:p}=t.getRunData(r),h=o.length===0?l.map((x,E)=>E):o;if(h.length!==l.length)throw new Error(`Output size ${h.length} must be equal to ${l.length}.`);let g=[],b=[];for(let x=0;x<l.length;++x){if(!Number.isInteger(h[x])||h[x]<-3||h[x]>=l.length)throw new Error(`Invalid output index: ${h[x]}`);if(h[x]===-3)continue;let E=h[x]===-1,A=h[x]===-2,z=E||A?s(l[x].dataType,l[x].dims):n(h[x],l[x].dataType,l[x].dims),R=this.gpuDataManager.get(z.data);if(!R)throw new Error(`no GPU data for output: ${z.data}`);if(E&&this.temporaryData.push(R),A){let V=this.kernelPersistentData.get(this.currentKernelId);V||(V=[],this.kernelPersistentData.set(this.currentKernelId,V)),V.push(R)}g.push(z),b.push(R)}let w;if(p){let x=0,E=[];p.forEach(V=>{let T=typeof V.data=="number"?[V.data]:V.data;if(T.length===0)return;let N=T.length<=2?T.length*4:16;x=Math.ceil(x/N)*N,E.push(x),x+=T.length>4?Math.ceil(T.length/4)*16:T.length*4});let A=16;x=Math.ceil(x/A)*A;let z=new ArrayBuffer(x);p.forEach((V,T)=>{let N=E[T],te=typeof V.data=="number"?[V.data]:V.data;V.type==="int32"?new Int32Array(z,N,te.length).set(te):V.type==="uint32"?new Uint32Array(z,N,te.length).set(te):new Float32Array(z,N,te.length).set(te)});let R=this.gpuDataManager.create(x,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(R.buffer,0,z,0,x),this.gpuDataManager.release(R.id),w={offset:0,size:x,buffer:R.buffer}}let y=this.programManager.normalizeDispatchGroupSize(a),_=y[1]===1&&y[2]===1,I=Uc(t,r,_),$=this.programManager.getArtifact(I);if($||($=this.programManager.build(t,y),this.programManager.setArtifact(I,$),Be("info",()=>`[artifact] key: ${I}, programName: ${t.name}`)),Be("info",()=>`[ProgramManager] run "${t.name}" (key=${I}) with ${y[0]}x${y[1]}x${y[2]}`),this.queryType!=="none"){let x={kernelId:this.currentKernelId,programName:$.programInfo.name,inputTensorViews:r,outputTensorViews:g};this.pendingKernels.push(x)}return this.programManager.run($,u,b,y,w),Rt(t.name),g}upload(t,r){this.gpuDataManager.upload(t,r)}memcpy(t,r){this.gpuDataManager.memcpy(t,r)}async download(t,r){await this.gpuDataManager.download(t,r)}alloc(t){return this.gpuDataManager.create(t).id}free(t){return this.gpuDataManager.release(t)}createKernel(t,r,o,n){let s=yu.get(t);if(!s)throw new Error(`kernel not implemented: ${t}`);let u={kernelType:t,kernelName:n,kernelEntry:s[0],attributes:[s[1],o]};this.kernels.set(r,u)}releaseKernel(t){let r=this.kernelPersistentData.get(t);if(r){for(let o of r)this.gpuDataManager.release(o.id);this.kernelPersistentData.delete(t)}this.kernelCustomData.delete(t),this.kernels.delete(t)}computeKernel(t,r,o){let n=this.kernels.get(t);if(!n)throw new Error(`kernel not created: ${t}`);let s=n.kernelType,u=n.kernelName,l=n.kernelEntry,a=n.attributes;if(this.currentKernelId!==null)throw new Error(`kernel "[${s}] ${u}" is not allowed to be called recursively`);this.currentKernelId=t,a[0]&&(a[1]=a[0](a[1]),a[0]=void 0),Be("info",()=>`[WebGPU] Start to run kernel "[${s}] ${u}"...`);let p=this.env.debug;this.temporaryData=[];try{return p&&this.device.pushErrorScope("validation"),l(r,a[1]),0}catch(h){return o.push(Promise.resolve(`[WebGPU] Kernel "[${s}] ${u}" failed. ${h}`)),1}finally{p&&o.push(this.device.popErrorScope().then(h=>h?`GPU validation error for kernel "[${s}] ${u}": ${h.message}`:null));for(let h of this.temporaryData)this.gpuDataManager.release(h.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(t,r,o,n){let s=this.sessionExternalDataMapping.get(t);s||(s=new Map,this.sessionExternalDataMapping.set(t,s));let u=s.get(r),l=this.gpuDataManager.registerExternalBuffer(o,n,u?.[1]);return s.set(r,[l,o]),l}unregisterBuffers(t){let r=this.sessionExternalDataMapping.get(t);r&&(r.forEach(o=>this.gpuDataManager.unregisterExternalBuffer(o[1])),this.sessionExternalDataMapping.delete(t))}getBuffer(t){let r=this.gpuDataManager.get(t);if(!r)throw new Error(`no GPU data for buffer: ${t}`);return r.buffer}createDownloader(t,r,o){return async()=>{let n=await On(this,t,r);return sa(n.buffer,o)}}writeTimestamp(t){this.queryType==="inside-passes"&&this.computePassEncoder.writeTimestamp(this.querySet,t)}setQueryType(){this.queryType="none",(this.env.webgpu.profiling?.mode==="default"||this.env.wasm.trace)&&(this.device.features.has("chromium-experimental-timestamp-query-inside-passes")?this.queryType="inside-passes":this.device.features.has("timestamp-query")&&(this.queryType="at-passes"))}}});var $u={};Br($u,{init:()=>Vc});var gr,Jn,Vc,Su=j(()=>{"use strict";Ne();vu();Ct();$e();gr=class e{constructor(t,r,o,n){this.module=t;this.dataType=r;this.data=o;this.dims=n}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let t=U.size(this.dims);return t===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,t)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let t=U.size(this.dims);return t===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,t)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let t=U.size(this.dims);return t===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,t)}reshape(t){if(U.size(t)!==U.size(this.dims))throw new Error("Invalid new shape");return new e(this.module,this.dataType,this.data,t)}},Jn=class{constructor(t,r,o){this.module=t;this.backend=r;this.customDataOffset=0;this.customDataSize=0;let n=t.HEAPU32,s=o>>>2;this.opKernelContext=n[s++];let u=n[s++];this.outputCount=n[s++],this.customDataOffset=n[s++],this.customDataSize=n[s++];let l=[];for(let a=0;a<u;a++){let p=n[s++],h=n[s++],g=n[s++],b=[];for(let w=0;w<g;w++)b.push(n[s++]);l.push(new gr(t,p,h,b))}this.inputs=l}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(t,r){let o=r?.inputs?.map(l=>typeof l=="number"?this.inputs[l]:l)??this.inputs,n=r?.outputs??[],s=(l,a,p)=>new gr(this.module,a,this.output(l,p),p),u=(l,a)=>{let p=cr(l);if(!p)throw new Error(`Unsupported data type: ${l}`);let h=p*U.size(a);return new gr(this.module,l,this.backend.gpuDataManager.create(h).id,a)};return this.backend.run(t,o,n,s,u)}output(t,r){let o=this.module.stackSave();try{let n=this.module.stackAlloc((1+r.length)*4),s=n>>2;this.module.HEAPU32[s++]=r.length;for(let u=0;u<r.length;u++)this.module.HEAPU32[s++]=r[u];return this.module._JsepOutput(this.opKernelContext,t,n)}catch(n){throw new Error(`Failed to generate kernel\'s output[${t}] with dims [${r}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${n}`)}finally{this.module.stackRestore(o)}}},Vc=async(e,t,r)=>{let o=e.jsepInit;if(!o)throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");let n=new sn;await n.initialize(t,r),o(n,s=>n.alloc(s),s=>n.free(s),(s,u,l,a=!1)=>{if(a)Be("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${s}, dst=${u}, size=${l}`),n.memcpy(s,u);else{Be("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${s}, gpuDataId=${u}, size=${l}`);let p=e.HEAPU8.subarray(s>>>0,(s>>>0)+l);n.upload(u,p)}},async(s,u,l)=>{Be("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${s}, dataOffset=${u}, size=${l}`),await n.download(s,()=>e.HEAPU8.subarray(u>>>0,(u>>>0)+l))},(s,u,l)=>n.createKernel(s,u,l,e.UTF8ToString(e._JsepGetNodeName(u))),s=>n.releaseKernel(s),(s,u,l,a)=>{Be("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${l}, kernel=${s}, contextDataOffset=${u}`);let p=new Jn(e,n,u);return n.computeKernel(s,p,a)})}});var Mo;Mo=Io();var Ju=Ro(),Sn,xn=!1,Dr=!1,Do=!1,ed=e=>{if(e===1)return!1;if(typeof SharedArrayBuffer>"u")return typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+e+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),!1;typeof process<"u"&&process.versions&&process.versions.node&&console.warn("env.wasm.numThreads is set to "+e+", however, currently onnxruntime-web does not support multi-threads in Node.js. Please consider using onnxruntime-node for performance critical scenarios.");try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},td=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},rd=(e,t)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":t?"ort-wasm-threaded.wasm":"ort-wasm.wasm",zo=async e=>{if(xn)return Promise.resolve();if(Dr)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(Do)throw new Error("previous call to \'initializeWebAssembly()\' failed.");Dr=!0;let t=e.initTimeout,r=e.numThreads,o=e.simd,n=ed(r),s=o&&td(),u=e.wasmPaths,l=typeof u=="string"?u:void 0,a=rd(s,n),p=typeof u=="object"?u[a]:void 0,h=!1,g=[];if(t>0&&g.push(new Promise(b=>{setTimeout(()=>{h=!0,b()},t)})),g.push(new Promise((b,w)=>{let y=n?Ju:Mo,_={locateFile:(I,$)=>{if(n&&I.endsWith(".worker.js")&&typeof Blob<"u")return URL.createObjectURL(new Blob([Bo()],{type:"text/javascript"}));if(I.endsWith(".wasm")){if(p)return p;let x=l??$;return a==="ort-wasm-simd.wasm"?x+"ort-wasm-simd.jsep.wasm":a==="ort-wasm-simd-threaded.wasm"?x+"ort-wasm-simd-threaded.jsep.wasm":x+a}return $+I}};if(n)if(_.numThreads=r,typeof Blob>"u")_.mainScriptUrlOrBlob=(void 0)(__dirname,"ort-wasm-threaded.js");else{let I=`var ortWasmThreaded=${y.toString()};`;_.mainScriptUrlOrBlob=new Blob([I],{type:"text/javascript"})}y(_).then(I=>{Dr=!1,xn=!0,Sn=I,b()},I=>{Dr=!1,Do=!0,w(I)})})),await Promise.race(g),h)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},Ve=()=>{if(xn&&Sn)return Sn;throw new Error("WebAssembly is not initialized yet.")};var He=(e,t)=>{let r=Ve(),o=r.lengthBytesUTF8(e)+1,n=r._malloc(o);return r.stringToUTF8(e,n,o),t.push(n),n},lr=(e,t,r,o)=>{if(typeof e=="object"&&e!==null){if(r.has(e))throw new Error("Circular reference in options");r.add(e)}Object.entries(e).forEach(([n,s])=>{let u=t?t+n:n;if(typeof s=="object")lr(s,u+".",r,o);else if(typeof s=="string"||typeof s=="number")o(u,s.toString());else if(typeof s=="boolean")o(u,s?"1":"0");else throw new Error(`Can\'t handle extra config type: ${typeof s}`)})},ke=e=>{let t=Ve(),r=t.stackSave();try{let o=t.stackAlloc(8);t._OrtGetLastError(o,o+4);let n=t.HEAP32[o/4],s=t.HEAPU32[o/4+1],u=s?t.UTF8ToString(s):"";throw new Error(`${e} ERROR_CODE: ${n}, ERROR_MESSAGE: ${u}`)}finally{t.stackRestore(r)}};var Uo=e=>{let t=Ve(),r=0,o=[],n=e||{};try{if(e?.logSeverityLevel===void 0)n.logSeverityLevel=2;else if(typeof e.logSeverityLevel!="number"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)n.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!="number"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(n.terminate=!1);let s=0;return e?.tag!==void 0&&(s=He(e.tag,o)),r=t._OrtCreateRunOptions(n.logSeverityLevel,n.logVerbosityLevel,!!n.terminate,s),r===0&&ke("Can\'t create run options."),e?.extra!==void 0&&lr(e.extra,"",new WeakSet,(u,l)=>{let a=He(u,o),p=He(l,o);t._OrtAddRunConfigEntry(r,a,p)!==0&&ke(`Can\'t set a run config entry: ${u} - ${l}.`)}),[r,o]}catch(s){throw r!==0&&t._OrtReleaseRunOptions(r),o.forEach(u=>t._free(u)),s}};var nd=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},od=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},ad=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(r=>(typeof r=="string"?r:r.name)==="webgpu")&&(e.enableMemPattern=!1)},id=(e,t,r)=>{for(let o of t){let n=typeof o=="string"?o:o.name;switch(n){case"webnn":if(n="WEBNN",typeof o!="string"){let u=o;if(u?.deviceType){let l=He("deviceType",r),a=He(u.deviceType,r);Ve()._OrtAddSessionConfigEntry(e,l,a)!==0&&ke(`Can\'t set a session config entry: \'deviceType\' - ${u.deviceType}.`)}if(u?.numThreads){let l=u.numThreads;(typeof l!="number"||!Number.isInteger(l)||l<0)&&(l=0);let a=He("numThreads",r),p=He(l.toString(),r);Ve()._OrtAddSessionConfigEntry(e,a,p)!==0&&ke(`Can\'t set a session config entry: \'numThreads\' - ${u.numThreads}.`)}if(u?.powerPreference){let l=He("powerPreference",r),a=He(u.powerPreference,r);Ve()._OrtAddSessionConfigEntry(e,l,a)!==0&&ke(`Can\'t set a session config entry: \'powerPreference\' - ${u.powerPreference}.`)}}break;case"webgpu":if(n="JS",typeof o!="string"){let u=o;if(u?.preferredLayout){if(u.preferredLayout!=="NCHW"&&u.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either \'NCHW\' or \'NHWC\': ${u.preferredLayout}`);let l=He("preferredLayout",r),a=He(u.preferredLayout,r);Ve()._OrtAddSessionConfigEntry(e,l,a)!==0&&ke(`Can\'t set a session config entry: \'preferredLayout\' - ${u.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${n}`)}let s=He(n,r);Ve()._OrtAppendExecutionProvider(e,s)!==0&&ke(`Can\'t append execution provider: ${n}.`)}},Vo=e=>{let t=Ve(),r=0,o=[],n=e||{};ad(n);try{let s=nd(n.graphOptimizationLevel??"all"),u=od(n.executionMode??"sequential"),l=typeof n.logId=="string"?He(n.logId,o):0,a=n.logSeverityLevel??2;if(!Number.isInteger(a)||a<0||a>4)throw new Error(`log serverity level is not valid: ${a}`);let p=n.logVerbosityLevel??0;if(!Number.isInteger(p)||p<0||p>4)throw new Error(`log verbosity level is not valid: ${p}`);let h=typeof n.optimizedModelFilePath=="string"?He(n.optimizedModelFilePath,o):0;if(r=t._OrtCreateSessionOptions(s,!!n.enableCpuMemArena,!!n.enableMemPattern,u,!!n.enableProfiling,0,l,a,p,h),r===0&&ke("Can\'t create session options."),n.executionProviders&&id(r,n.executionProviders,o),n.freeDimensionOverrides)for(let[g,b]of Object.entries(n.freeDimensionOverrides)){if(typeof g!="string")throw new Error(`free dimension override name must be a string: ${g}`);if(typeof b!="number"||!Number.isInteger(b)||b<0)throw new Error(`free dimension override value must be a non-negative integer: ${b}`);let w=He(g,o);t._OrtAddFreeDimensionOverride(r,w,b)!==0&&ke(`Can\'t set a free dimension override: ${g} - ${b}.`)}return n.extra!==void 0&&lr(n.extra,"",new WeakSet,(g,b)=>{let w=He(g,o),y=He(b,o);t._OrtAddSessionConfigEntry(r,w,y)!==0&&ke(`Can\'t set a session config entry: ${g} - ${b}.`)}),[r,o]}catch(s){throw r!==0&&t._OrtReleaseSessionOptions(r),o.forEach(u=>t._free(u)),s}};Ne();var Wo=async e=>{if(typeof e=="string")if(typeof process<"u"&&process.versions&&process.versions.node)try{return new Uint8Array(await(void 0)(e))}catch(t){if(t.code==="ERR_FS_FILE_TOO_LARGE"){let r=(void 0)(e),o=[];for await(let n of r)o.push(n);return new Uint8Array(Buffer.concat(o))}throw t}else{let t=await fetch(e);if(!t.ok)throw new Error(`failed to load external data file: ${e}`);let r=t.headers.get("Content-Length"),o=r?parseInt(r,10):0;if(o<1073741824)return new Uint8Array(await t.arrayBuffer());{if(!t.body)throw new Error(`failed to load external data file: ${e}, no response body.`);let n=t.body.getReader(),s;try{s=new ArrayBuffer(o)}catch(l){if(l instanceof RangeError){let a=Math.ceil(o/65536);s=new WebAssembly.Memory({initial:a,maximum:a}).buffer}else throw l}let u=0;for(;;){let{done:l,value:a}=await n.read();if(l)break;let p=a.byteLength;new Uint8Array(s,u,p).set(a),u+=p}return new Uint8Array(s,0,o)}}else return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e)};var Nc=(e,t)=>{Ve()._OrtInit(e,t)!==0&&ke("Can\'t initialize onnxruntime.")},_u=async e=>{Nc(e.wasm.numThreads,pr(e.logLevel))},Cu=async(e,t)=>{if(t==="webgpu"){if(typeof navigator>"u"||!navigator.gpu)throw new Error("WebGPU is not supported in current environment");let r=await navigator.gpu.requestAdapter();if(!r)throw new Error(\'Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.\');if(!e.wasm.simd)throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using `webgpu` EP");let o=(Su(),Ht($u)).init;await o(Ve(),e,r)}},yr=new Map,Wc=e=>{let t=Ve(),r=t.stackSave();try{let o=t.stackAlloc(8);return t._OrtGetInputOutputCount(e,o,o+4)!==0&&ke("Can\'t get session input/output count."),[t.HEAP32[o/4],t.HEAP32[o/4+1]]}finally{t.stackRestore(r)}},eo=e=>{let t=Ve(),r=t._malloc(e.byteLength);if(r===0)throw new Error(`Can\'t create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,r),[r,e.byteLength]},Iu=async(e,t)=>{let r,o,n=Ve();Array.isArray(e)?[r,o]=e:e.buffer===n.HEAPU8.buffer?[r,o]=[e.byteOffset,e.byteLength]:[r,o]=eo(e);let s=0,u=0,l=0,a=[],p=[],h=[];try{if([u,a]=Vo(t),t?.externalData&&n.mountExternalData){let $=[];for(let x of t.externalData){let E=typeof x=="string"?x:x.path;$.push(Wo(typeof x=="string"?x:x.data).then(A=>{n.mountExternalData(E,A)}))}await Promise.all($)}s=n._OrtCreateSession(r,o,u),s===0&&ke("Can\'t create a session.");let[g,b]=Wc(s),w=[],y=[],_=[];for(let $=0;$<g;$++){let x=n._OrtGetInputName(s,$);x===0&&ke("Can\'t get an input name."),p.push(x),w.push(n.UTF8ToString(x))}for(let $=0;$<b;$++){let x=n._OrtGetOutputName(s,$);x===0&&ke("Can\'t get an output name."),h.push(x);let E=n.UTF8ToString(x);y.push(E);{let A=typeof t?.preferredOutputLocation=="string"?t.preferredOutputLocation:t?.preferredOutputLocation?.[E]??"cpu";if(A!=="cpu"&&A!=="cpu-pinned"&&A!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${A}.`);_.push(A)}}let I=null;return _.some($=>$==="gpu-buffer")&&(l=n._OrtCreateBinding(s),l===0&&ke("Can\'t create IO binding."),I={handle:l,outputPreferredLocations:_,outputPreferredLocationsEncoded:_.map($=>Cn($))}),yr.set(s,[s,p,h,I]),[s,w,y]}catch(g){throw p.forEach(b=>n._OrtFree(b)),h.forEach(b=>n._OrtFree(b)),l!==0&&n._OrtReleaseBinding(l),s!==0&&n._OrtReleaseSession(s),g}finally{n._free(r),u!==0&&n._OrtReleaseSessionOptions(u),a.forEach(g=>n._free(g)),n.unmountExternalData?.()}},Au=e=>{let t=Ve(),r=yr.get(e);if(!r)throw new Error(`cannot release session. invalid session id: ${e}`);let[o,n,s,u]=r;u&&t._OrtReleaseBinding(u.handle),t.jsepUnregisterBuffers?.(e),n.forEach(l=>t._OrtFree(l)),s.forEach(l=>t._OrtFree(l)),t._OrtReleaseSession(o),yr.delete(e)},xu=(e,t,r,o,n)=>{if(!e){t.push(0);return}let s=Ve(),u=e[0],l=e[1],a=e[3],p,h;if(u==="string"&&a==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(a==="gpu-buffer"){let w=e[2].gpuBuffer,y=cr(_n(u));h=l.reduce((_,I)=>_*I,1)*y,p=s.jsepRegisterBuffer(o,n,w,h)}else{let w=e[2];if(Array.isArray(w)){h=4*w.length,p=s._malloc(h),r.push(p);let y=p/4;for(let _=0;_<w.length;_++){if(typeof w[_]!="string")throw new TypeError(`tensor data at index ${_} is not a string`);s.HEAPU32[y++]=He(w[_],r)}}else h=w.byteLength,p=s._malloc(h),r.push(p),s.HEAPU8.set(new Uint8Array(w.buffer,w.byteOffset,h),p)}let g=s.stackSave(),b=s.stackAlloc(4*l.length);try{let w=b/4;l.forEach(_=>s.HEAP32[w++]=_);let y=s._OrtCreateTensor(_n(u),p,h,b,l.length,Cn(a));y===0&&ke(`Can\'t create tensor for input/output. session=${o}, index=${n}.`),t.push(y)}finally{s.stackRestore(g)}},Tu=async(e,t,r,o,n,s)=>{let u=Ve(),l=yr.get(e);if(!l)throw new Error(`cannot run inference. invalid session id: ${e}`);let[a,p,h,g]=l,b=t.length,w=o.length,y=0,_=[],I=[],$=[],x=[],E=u.stackSave(),A=u.stackAlloc(b*4),z=u.stackAlloc(b*4),R=u.stackAlloc(w*4),V=u.stackAlloc(w*4);try{[y,_]=Uo(s);for(let Z=0;Z<b;Z++)xu(r[Z],I,x,e,t[Z]);for(let Z=0;Z<w;Z++)xu(n[Z],$,x,e,b+o[Z]);let T=A/4,N=z/4,te=R/4,Y=V/4;for(let Z=0;Z<b;Z++)u.HEAPU32[T++]=I[Z],u.HEAPU32[N++]=p[t[Z]];for(let Z=0;Z<w;Z++)u.HEAPU32[te++]=$[Z],u.HEAPU32[Y++]=h[o[Z]];if(g){let{handle:Z,outputPreferredLocations:Ee,outputPreferredLocationsEncoded:Pe}=g;if(p.length!==b)throw new Error(`input count from feeds (${b}) is expected to be always equal to model\'s input count (${p.length}).`);for(let fe=0;fe<b;fe++){let Ie=t[fe];await u._OrtBindInput(Z,p[Ie],I[fe])!==0&&ke(`Can\'t bind input[${fe}] for session=${e}.`)}for(let fe=0;fe<w;fe++){let Ie=o[fe];n[fe]?.[3]?u._OrtBindOutput(Z,h[Ie],$[fe],0)!==0&&ke(`Can\'t bind pre-allocated output[${fe}] for session=${e}.`):u._OrtBindOutput(Z,h[Ie],0,Pe[Ie])!==0&&ke(`Can\'t bind output[${fe}] to ${Ee[fe]} for session=${e}.`)}}let K;g?K=await u._OrtRunWithBinding(a,g.handle,w,R,y):K=await u._OrtRun(a,z,A,b,V,w,R,y),K!==0&&ke("failed to call OrtRun().");let Q=[];for(let Z=0;Z<w;Z++){let Ee=u.HEAPU32[R/4+Z];if(Ee===$[Z]){Q.push(n[Z]);continue}let Pe=u.stackSave(),fe=u.stackAlloc(4*4),Ie=!1,he,ye=0;try{u._OrtGetTensorData(Ee,fe,fe+4,fe+8,fe+12)!==0&&ke(`Can\'t access output tensor data on index ${Z}.`);let De=fe/4,Ge=u.HEAPU32[De++];ye=u.HEAPU32[De++];let G=u.HEAPU32[De++],ee=u.HEAPU32[De++],be=[];for(let Ue=0;Ue<ee;Ue++)be.push(u.HEAPU32[G/4+Ue]);u._OrtFree(G);let et=be.reduce((Ue,Me)=>Ue*Me,1);he=Xe(Ge);let ze=g?.outputPreferredLocations[o[Z]];if(he==="string"){if(ze==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let Ue=[],Me=ye/4;for(let wt=0;wt<et;wt++){let rt=u.HEAPU32[Me++],Dt=wt===et-1?void 0:u.HEAPU32[Me]-rt;Ue.push(u.UTF8ToString(rt,Dt))}Q.push([he,be,Ue,"cpu"])}else if(ze==="gpu-buffer"&&et>0){let Ue=u.jsepGetBuffer(ye),Me=cr(Ge);if(Me===void 0||!No(he))throw new Error(`Unsupported data type: ${he}`);Ie=!0,Q.push([he,be,{gpuBuffer:Ue,download:u.jsepCreateDownloader(Ue,et*Me,he),dispose:()=>{u._OrtReleaseTensor(Ee)}},"gpu-buffer"])}else{let Ue=Mr(he),Me=new Ue(et);new Uint8Array(Me.buffer,Me.byteOffset,Me.byteLength).set(u.HEAPU8.subarray(ye,ye+Me.byteLength)),Q.push([he,be,Me,"cpu"])}}finally{u.stackRestore(Pe),he==="string"&&ye&&u._free(ye),Ie||u._OrtReleaseTensor(Ee)}}return g&&u._OrtClearBoundOutputs(g.handle),Q}finally{u.stackRestore(E),I.forEach(T=>u._OrtReleaseTensor(T)),$.forEach(T=>u._OrtReleaseTensor(T)),x.forEach(T=>u._free(T)),y!==0&&u._OrtReleaseRunOptions(y),_.forEach(T=>u._free(T))}},Eu=e=>{let t=Ve(),r=yr.get(e);if(!r)throw new Error("invalid session id");let o=r[0],n=t._OrtEndProfiling(o);n===0&&ke("Can\'t get an profile file name."),t._OrtFree(n)},Ou=e=>{let t=[];for(let r of e){let o=r[2];!Array.isArray(o)&&"buffer"in o&&t.push(o.buffer)}return t};self.onmessage=e=>{let{type:t,in:r}=e.data;try{switch(t){case"init-wasm":zo(r.wasm).then(()=>{_u(r).then(()=>{postMessage({type:t})},o=>{postMessage({type:t,err:o})})},o=>{postMessage({type:t,err:o})});break;case"init-ep":{let{epName:o,env:n}=r;Cu(n,o).then(()=>{postMessage({type:t})},s=>{postMessage({type:t,err:s})});break}case"copy-from":{let{buffer:o}=r,n=eo(o);postMessage({type:t,out:n});break}case"create":{let{model:o,options:n}=r;Iu(o,n).then(s=>{postMessage({type:t,out:s})},s=>{postMessage({type:t,err:s})});break}case"release":Au(r),postMessage({type:t});break;case"run":{let{sessionId:o,inputIndices:n,inputs:s,outputIndices:u,options:l}=r;Tu(o,n,s,u,new Array(u.length).fill(null),l).then(a=>{a.some(p=>p[3]!=="cpu")?postMessage({type:t,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:t,out:a},Ou(a))},a=>{postMessage({type:t,err:a})});break}case"end-profiling":Eu(r),postMessage({type:t});break;default:}}catch(o){postMessage({type:t,err:o})}};})();\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n'}),on,bt,Rn,mr,gr,Di,va,_n,wn,ud,_r,Ph,Dh,Nh,Lh,Fh,Uh,Wh,Vh=Y(()=>{Dt(),h0(),Mr(),on=()=>!!Ne.wasm.proxy&&typeof document<"u",Rn=!1,mr=!1,gr=!1,va=new Map,_n=(t,e)=>{let n=va.get(t);n?n.push(e):va.set(t,[e])},wn=()=>{if(Rn||!mr||gr||!bt)throw new Error("worker not ready")},ud=t=>{switch(t.data.type){case"init-wasm":Rn=!1,t.data.err?(gr=!0,Di[1](t.data.err)):(mr=!0,Di[0]());break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let e=va.get(t.data.type);t.data.err?e.shift()[1](t.data.err):e.shift()[0](t.data.out);break}}},_r=typeof document<"u"?document?.currentScript?.src:void 0,Ph=async()=>{if(!mr){if(Rn)throw new Error("multiple calls to 'initWasm()' detected.");if(gr)throw new Error("previous call to 'initWasm()' failed.");if(Rn=!0,on())return Ne.wasm.wasmPaths===void 0&&_r&&_r.indexOf("blob:")!==0&&(Ne.wasm.wasmPaths=_r.substr(0,+_r.lastIndexOf("/")+1)),new Promise((t,e)=>{bt?.terminate();let n=URL.createObjectURL(new Blob([f0()],{type:"text/javascript"}));bt=new Worker(n,{name:"ort-wasm-proxy-worker"}),bt.onerror=a=>e(a),bt.onmessage=ud,URL.revokeObjectURL(n),Di=[t,e];let r={type:"init-wasm",in:Ne};bt.postMessage(r)});try{await ac(Ne.wasm),await Ih(Ne),mr=!0}catch(t){throw gr=!0,t}finally{Rn=!1}}},Dh=async t=>{if(on())return wn(),new Promise((e,n)=>{_n("init-ep",[e,n]);let r={type:"init-ep",in:{epName:t,env:Ne}};bt.postMessage(r)});await Ah(Ne,t)},Nh=async t=>on()?(wn(),new Promise((e,n)=>{_n("copy-from",[e,n]);let r={type:"copy-from",in:{buffer:t}};bt.postMessage(r,[t.buffer])})):ns(t),Lh=async(t,e)=>{if(on()){if(e?.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return wn(),new Promise((n,r)=>{_n("create",[n,r]);let a={type:"create",in:{model:t,options:e}},i=[];t instanceof Uint8Array&&i.push(t.buffer),bt.postMessage(a,i)})}else return Mh(t,e)},Fh=async t=>{if(on())return wn(),new Promise((e,n)=>{_n("release",[e,n]);let r={type:"release",in:t};bt.postMessage(r)});Oh(t)},Uh=async(t,e,n,r,a,i)=>{if(on()){if(n.some(s=>s[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(a.some(s=>s))throw new Error("pre-allocated output tensor is not supported for proxy.");return wn(),new Promise((s,o)=>{_n("run",[s,o]);let l=n,d={type:"run",in:{sessionId:t,inputIndices:e,inputs:l,outputIndices:r,options:i}};bt.postMessage(d,Bh(l))})}else return zh(t,e,n,r,a,i)},Wh=async t=>{if(on())return wn(),new Promise((e,n)=>{_n("end-profiling",[e,n]);let r={type:"end-profiling",in:t};bt.postMessage(r)});Rh(t)}}),Ni,dd,Gh,m0=Y(()=>{Dt(),Vh(),Ye(),oc(),Ni=(t,e)=>{switch(t.location){case"cpu":return[t.type,t.dims,t.data,"cpu"];case"gpu-buffer":return[t.type,t.dims,{gpuBuffer:t.gpuBuffer},"gpu-buffer"];default:throw new Error(`invalid data location: ${t.location} for ${e()}`)}},dd=t=>{switch(t[3]){case"cpu":return new ct(t[0],t[2],t[1]);case"gpu-buffer":{let e=t[0];if(!vs(e))throw new Error(`not supported data type: ${e} for deserializing GPU tensor`);let{gpuBuffer:n,download:r,dispose:a}=t[2];return ct.fromGpuBuffer(n,{dataType:e,dims:t[1],download:r,dispose:a})}default:throw new Error(`invalid data location: ${t[3]}`)}},Gh=class{async fetchModelAndCopyToWasmMemory(t){return Nh(await Oa(t))}async loadModel(t,e){Bt();let n;typeof t=="string"?typeof process<"u"&&process.versions&&process.versions.node?n=await Oa(t):n=await this.fetchModelAndCopyToWasmMemory(t):n=t,[this.sessionId,this.inputNames,this.outputNames]=await Lh(n,e),Pt()}async dispose(){return Fh(this.sessionId)}async run(t,e,n){Bt();let r=[],a=[];Object.entries(t).forEach(u=>{let f=u[0],m=u[1],_=this.inputNames.indexOf(f);if(_===-1)throw new Error(`invalid input '${f}'`);r.push(m),a.push(_)});let i=[],s=[];Object.entries(e).forEach(u=>{let f=u[0],m=u[1],_=this.outputNames.indexOf(f);if(_===-1)throw new Error(`invalid output '${f}'`);i.push(m),s.push(_)});let o=r.map((u,f)=>Ni(u,()=>`input "${this.inputNames[a[f]]}"`)),l=i.map((u,f)=>u?Ni(u,()=>`output "${this.outputNames[s[f]]}"`):null),d=await Uh(this.sessionId,a,o,s,l,n),p={};for(let u=0;u<d.length;u++)p[this.outputNames[s[u]]]=i[u]??dd(d[u]);return Pt(),p}startProfiling(){}endProfiling(){Wh(this.sessionId)}}}),cd,Hh,g0=Y(()=>{Dt(),Vh(),m0(),cd=()=>{if((typeof Ne.wasm.initTimeout!="number"||Ne.wasm.initTimeout<0)&&(Ne.wasm.initTimeout=0),typeof Ne.wasm.simd!="boolean"&&(Ne.wasm.simd=!0),typeof Ne.wasm.proxy!="boolean"&&(Ne.wasm.proxy=!1),typeof Ne.wasm.trace!="boolean"&&(Ne.wasm.trace=!1),typeof Ne.wasm.numThreads!="number"||!Number.isInteger(Ne.wasm.numThreads)||Ne.wasm.numThreads<=0){(typeof self<"u"&&!self.crossOriginIsolated||typeof process<"u"&&process.versions&&process.versions.node)&&(Ne.wasm.numThreads=1);let t=typeof navigator>"u"?(void 0)().length:navigator.hardwareConcurrency;Ne.wasm.numThreads=Math.min(4,Math.ceil((t||1)/2))}},Hh=class{async init(t){cd(),await Ph(),await Dh(t)}async createInferenceSessionHandler(t,e){let n=new Gh;return await n.loadModel(t,e),Promise.resolve(n)}}}),qh={};Wn(qh,{wasmBackend:()=>jh});var jh,_0=Y(()=>{g0(),jh=new Hh});Dt();Dt();Dt();var w0="1.17.1",y0=Yd;{let t=(_0(),$n(qh)).wasmBackend;Dn("webgpu",t,5),Dn("cpu",t,10),Dn("wasm",t,10)}Object.defineProperty(Ne.versions,"web",{value:w0,enumerable:!0});/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v0=Object.freeze(Object.defineProperty({__proto__:null,get InferenceSession(){return fs},get TRACE(){return kr},get TRACE_FUNC_BEGIN(){return Bt},get TRACE_FUNC_END(){return Pt},get Tensor(){return ct},get TrainingSession(){return ms},default:y0,get env(){return Ne},get registerBackend(){return Dn}},Symbol.toStringTag,{value:"Module"})),b0=(t,e)=>{const n=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);n.width=t.dims[3],n.height=t.dims[2];const r=n.getContext("2d");if(r!=null){let a,i;e?.tensorLayout!==void 0&&e.tensorLayout==="NHWC"?(a=t.dims[2],i=t.dims[3]):(a=t.dims[3],i=t.dims[2]);const s=e?.format!==void 0?e.format:"RGB",o=e?.norm;let l,d;o===void 0||o.mean===void 0?l=[255,255,255,255]:typeof o.mean=="number"?l=[o.mean,o.mean,o.mean,o.mean]:(l=[o.mean[0],o.mean[1],o.mean[2],0],o.mean[3]!==void 0&&(l[3]=o.mean[3])),o===void 0||o.bias===void 0?d=[0,0,0,0]:typeof o.bias=="number"?d=[o.bias,o.bias,o.bias,o.bias]:(d=[o.bias[0],o.bias[1],o.bias[2],0],o.bias[3]!==void 0&&(d[3]=o.bias[3]));const p=i*a;let u=0,f=p,m=p*2,_=-1;s==="RGBA"?(u=0,f=p,m=p*2,_=p*3):s==="RGB"?(u=0,f=p,m=p*2):s==="RBG"&&(u=0,m=p,f=p*2);for(let v=0;v<i;v++)for(let $=0;$<a;$++){const b=(t.data[u++]-d[0])*l[0],S=(t.data[f++]-d[1])*l[1],T=(t.data[m++]-d[2])*l[2],E=_===-1?255:(t.data[_++]-d[3])*l[3];r.fillStyle="rgba("+b+","+S+","+T+","+E+")",r.fillRect($,v,1,1)}if("toDataURL"in n)return n.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},$0=(t,e)=>{const n=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d");let r;if(n!=null){let a,i,s;e?.tensorLayout!==void 0&&e.tensorLayout==="NHWC"?(a=t.dims[2],i=t.dims[1],s=t.dims[3]):(a=t.dims[3],i=t.dims[2],s=t.dims[1]);const o=e!==void 0&&e.format!==void 0?e.format:"RGB",l=e?.norm;let d,p;l===void 0||l.mean===void 0?d=[255,255,255,255]:typeof l.mean=="number"?d=[l.mean,l.mean,l.mean,l.mean]:(d=[l.mean[0],l.mean[1],l.mean[2],255],l.mean[3]!==void 0&&(d[3]=l.mean[3])),l===void 0||l.bias===void 0?p=[0,0,0,0]:typeof l.bias=="number"?p=[l.bias,l.bias,l.bias,l.bias]:(p=[l.bias[0],l.bias[1],l.bias[2],0],l.bias[3]!==void 0&&(p[3]=l.bias[3]));const u=i*a;if(e!==void 0&&(e.format!==void 0&&s===4&&e.format!=="RGBA"||s===3&&e.format!=="RGB"&&e.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");const f=4;let m=0,_=1,v=2,$=3,b=0,S=u,T=u*2,E=-1;o==="RGBA"?(b=0,S=u,T=u*2,E=u*3):o==="RGB"?(b=0,S=u,T=u*2):o==="RBG"&&(b=0,T=u,S=u*2),r=n.createImageData(a,i);for(let I=0;I<i*a;m+=f,_+=f,v+=f,$+=f,I++)r.data[m]=(t.data[b++]-p[0])*d[0],r.data[_]=(t.data[S++]-p[1])*d[1],r.data[v]=(t.data[T++]-p[2])*d[2],r.data[$]=E===-1?255:(t.data[E++]-p[3])*d[3]}else throw new Error("Can not access image data");return r},Li=(t,e)=>{if(t===void 0)throw new Error("Image buffer must be defined");if(e.height===void 0||e.width===void 0)throw new Error("Image height and width must be defined");if(e.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");const{height:n,width:r}=e,a=e.norm??{mean:255,bias:0};let i,s;typeof a.mean=="number"?i=[a.mean,a.mean,a.mean,a.mean]:i=[a.mean[0],a.mean[1],a.mean[2],a.mean[3]??255],typeof a.bias=="number"?s=[a.bias,a.bias,a.bias,a.bias]:s=[a.bias[0],a.bias[1],a.bias[2],a.bias[3]??0];const o=e.format!==void 0?e.format:"RGBA",l=e.tensorFormat!==void 0&&e.tensorFormat!==void 0?e.tensorFormat:"RGB",d=n*r,p=l==="RGBA"?new Float32Array(d*4):new Float32Array(d*3);let u=4,f=0,m=1,_=2,v=3,$=0,b=d,S=d*2,T=-1;o==="RGB"&&(u=3,f=0,m=1,_=2,v=-1),l==="RGBA"?T=d*3:l==="RBG"?($=0,S=d,b=d*2):l==="BGR"&&(S=0,b=d,$=d*2);for(let I=0;I<d;I++,f+=u,_+=u,m+=u,v+=u)p[$++]=(t[f]+s[0])/i[0],p[b++]=(t[m]+s[1])/i[1],p[S++]=(t[_]+s[2])/i[2],T!==-1&&v!==-1&&(p[T++]=(t[v]+s[3])/i[3]);return l==="RGBA"?new Gt("float32",p,[1,4,n,r]):new Gt("float32",p,[1,3,n,r])},x0=async(t,e)=>{const n=typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement,r=typeof ImageData<"u"&&t instanceof ImageData,a=typeof ImageBitmap<"u"&&t instanceof ImageBitmap,i=typeof t=="string";let s,o=e??{};const l=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},d=p=>p instanceof HTMLCanvasElement||p instanceof OffscreenCanvas?p.getContext("2d"):null;if(n){const p=l();p.width=t.width,p.height=t.height;const u=d(p);if(u!=null){let f=t.height,m=t.width;if(e!==void 0&&e.resizedHeight!==void 0&&e.resizedWidth!==void 0&&(f=e.resizedHeight,m=e.resizedWidth),e!==void 0){if(o=e,e.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");o.tensorFormat="RGBA",o.height=f,o.width=m}else o.tensorFormat="RGBA",o.height=f,o.width=m;u.drawImage(t,0,0),s=u.getImageData(0,0,m,f).data}else throw new Error("Can not access image data")}else if(r){let p,u;if(e!==void 0&&e.resizedWidth!==void 0&&e.resizedHeight!==void 0?(p=e.resizedHeight,u=e.resizedWidth):(p=t.height,u=t.width),e!==void 0&&(o=e),o.format="RGBA",o.height=p,o.width=u,e!==void 0){const f=l();f.width=u,f.height=p;const m=d(f);if(m!=null)m.putImageData(t,0,0),s=m.getImageData(0,0,u,p).data;else throw new Error("Can not access image data")}else s=t.data}else if(a){if(e===void 0)throw new Error("Please provide image config with format for Imagebitmap");const p=l();p.width=t.width,p.height=t.height;const u=d(p);if(u!=null){const f=t.height,m=t.width;return u.drawImage(t,0,0,m,f),s=u.getImageData(0,0,m,f).data,o.height=f,o.width=m,Li(s,o)}else throw new Error("Can not access image data")}else{if(i)return new Promise((p,u)=>{const f=l(),m=d(f);if(!t||!m)return u();const _=new Image;_.crossOrigin="Anonymous",_.src=t,_.onload=()=>{f.width=_.width,f.height=_.height,m.drawImage(_,0,0,f.width,f.height);const v=m.getImageData(0,0,f.width,f.height);o.height=f.height,o.width=f.width,p(Li(v.data,o))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(s!==void 0)return Li(s,o);throw new Error("Input data provided is not supported - aborted tensor creation")},S0=(t,e)=>{const{width:n,height:r,download:a,dispose:i}=e,s=[1,r,n,4];return new Gt({location:"texture",type:"float32",texture:t,dims:s,download:a,dispose:i})},E0=(t,e)=>{const{dataType:n,dims:r,download:a,dispose:i}=e;return new Gt({location:"gpu-buffer",type:n??"float32",gpuBuffer:t,dims:r,download:a,dispose:i})},k0=(t,e,n)=>new Gt({location:"cpu-pinned",type:t,data:e,dims:n??[e.length]}),Na=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["float16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),rs=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);let pd=!1;const T0=()=>{if(!pd){pd=!0;const t=typeof BigInt64Array<"u"&&typeof BigInt64Array.from=="function",e=typeof BigUint64Array<"u"&&typeof BigUint64Array.from=="function";t&&(Na.set("int64",BigInt64Array),rs.set(BigInt64Array,"int64")),e&&(Na.set("uint64",BigUint64Array),rs.set(BigUint64Array,"uint64"))}},C0=t=>{let e=1;for(let n=0;n<t.length;n++){const r=t[n];if(typeof r!="number"||!Number.isSafeInteger(r))throw new TypeError(`dims[${n}] must be an integer, got: ${r}`);if(r<0)throw new RangeError(`dims[${n}] must be a non-negative integer, got: ${r}`);e*=r}return e},I0=(t,e)=>{switch(t.location){case"cpu":return new Gt(t.type,t.data,e);case"cpu-pinned":return new Gt({location:"cpu-pinned",data:t.data,type:t.type,dims:e});case"texture":return new Gt({location:"texture",texture:t.texture,type:t.type,dims:e});case"gpu-buffer":return new Gt({location:"gpu-buffer",gpuBuffer:t.gpuBuffer,type:t.type,dims:e});default:throw new Error(`tensorReshape: tensor location ${t.location} is not supported`)}};let Gt=class{constructor(e,n,r){T0();let a,i;if(typeof e=="object"&&"location"in e)switch(this.dataLocation=e.location,a=e.type,i=e.dims,e.location){case"cpu-pinned":{const o=Na.get(a);if(!o)throw new TypeError(`unsupported type "${a}" to create tensor from pinned buffer`);if(!(e.data instanceof o))throw new TypeError(`buffer should be of type ${o.name}`);this.cpuData=e.data;break}case"texture":{if(a!=="float32")throw new TypeError(`unsupported type "${a}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break}case"gpu-buffer":{if(a!=="float32"&&a!=="float16"&&a!=="int32"&&a!=="int64"&&a!=="uint32"&&a!=="bool")throw new TypeError(`unsupported type "${a}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let o,l;if(typeof e=="string")if(a=e,l=r,e==="string"){if(!Array.isArray(n))throw new TypeError("A string tensor's data must be a string array.");o=n}else{const d=Na.get(e);if(d===void 0)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(n)){if(e==="float16")throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");e==="uint64"||e==="int64"?o=d.from(n,BigInt):o=d.from(n)}else if(n instanceof d)o=n;else throw new TypeError(`A ${a} tensor's data must be type of ${d}`)}else if(l=n,Array.isArray(e)){if(e.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");const d=typeof e[0];if(d==="string")a="string",o=e;else if(d==="boolean")a="bool",o=Uint8Array.from(e);else throw new TypeError(`Invalid element type of data array: ${d}.`)}else{const d=rs.get(e.constructor);if(d===void 0)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);a=d,o=e}if(l===void 0)l=[o.length];else if(!Array.isArray(l))throw new TypeError("A tensor's dims must be a number array");i=l,this.cpuData=o,this.dataLocation="cpu"}const s=C0(i);if(this.cpuData&&s!==this.cpuData.length)throw new Error(`Tensor's size(${s}) does not match data length(${this.cpuData.length}).`);this.type=a,this.dims=i,this.size=s}static async fromImage(e,n){return x0(e,n)}static fromTexture(e,n){return S0(e,n)}static fromGpuBuffer(e,n){return E0(e,n)}static fromPinnedBuffer(e,n,r){return k0(e,n,r)}toDataURL(e){return b0(this,e)}toImageData(e){return $0(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;const n=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=n,e&&this.disposer&&(this.disposer(),this.disposer=void 0),n}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return I0(this,e)}};const A0=Gt,M0=typeof navigator<"u"&&"gpu"in navigator,O0=typeof process<"u"&&process?.release?.name==="node",br=[];let as,Cr;O0?(Cr=Ke??Gm,br.push("cpu"),as=["cpu"]):(Cr=v0,M0&&br.push("webgpu"),br.push("wasm"),as=["wasm"]);const z0=Cr.InferenceSession;function R0(t){let e=as;if(t){if(!br.includes(t))throw new Error(`Unsupported device: "${t}". Should be one of: ${br.join(", ")}.`);e=[t]}return e}async function B0(t,e){const n={...e};return await z0.create(t,n)}function Kh(t){return t instanceof Cr.Tensor}const bn=Cr?.env;bn?.wasm&&(bn.wasm.wasmPaths="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.17.1/dist/",bn.wasm.proxy=!0,(typeof crossOriginIsolated>"u"||!crossOriginIsolated)&&(bn.wasm.numThreads=1),typeof navigator<"u"&&/iP(hone|od|ad).+16_4.+AppleWebKit/.test(navigator.userAgent)&&(bn.wasm.simd=!1));function P0(){return bn?.wasm?.proxy}ot.backends.onnx=bn;const hd=Object.freeze({float32:Float32Array,float16:Uint16Array,float64:Float64Array,string:Array,int8:Int8Array,uint8:Uint8Array,int16:Int16Array,uint16:Uint16Array,int32:Int32Array,uint32:Uint32Array,int64:BigInt64Array,uint64:BigUint64Array,bool:Uint8Array});class le{get dims(){return this.ort_tensor.dims}set dims(e){this.ort_tensor.dims=e}get type(){return this.ort_tensor.type}get data(){return this.ort_tensor.data}get size(){return this.ort_tensor.size}ort_tensor;constructor(...e){return Kh(e[0])?this.ort_tensor=e[0]:this.ort_tensor=new A0(e[0],e[1],e[2]),new Proxy(this,{get:(n,r)=>{if(typeof r=="string"){let a=Number(r);if(Number.isInteger(a))return n._getitem(a)}return n[r]},set:(n,r,a)=>n[r]=a})}dispose(){this.ort_tensor.dispose()}*[Symbol.iterator](){const[e,...n]=this.dims;if(n.length>0){const r=n.reduce((a,i)=>a*i);for(let a=0;a<e;++a)yield this._subarray(a,r,n)}else yield*this.data}_getitem(e){const[n,...r]=this.dims;if(e=dn(e,n),r.length>0){const a=r.reduce((i,s)=>i*s);return this._subarray(e,a,r)}else return new le(this.type,[this.data[e]],r)}indexOf(e){for(let n=0;n<this.data.length;++n)if(this.data[n]==e)return n;return-1}_subarray(e,n,r){const a=e*n,i=(e+1)*n,s="subarray"in this.data?this.data.subarray(a,i):this.data.slice(a,i);return new le(this.type,s,r)}item(){if(this.data.length!==1)throw new Error(`a Tensor with ${this.data.length} elements cannot be converted to Scalar`);return this.data[0]}tolist(){return D0(this.data,this.dims)}sigmoid(){return this.clone().sigmoid_()}sigmoid_(){for(let e=0;e<this.data.length;++e)this.data[e]=1/(1+Math.exp(-this.data[e]));return this}mul(e){return this.clone().mul_(e)}mul_(e){for(let n=0;n<this.data.length;++n)this.data[n]*=e;return this}add(e){return this.clone().add_(e)}add_(e){for(let n=0;n<this.data.length;++n)this.data[n]+=e;return this}clone(){return new le(this.type,this.data.slice(),this.dims.slice())}slice(...e){let n=[],r=[];for(let l=0;l<this.dims.length;++l){let d=e[l];if(d==null)r.push([0,this.dims[l]]),n.push(this.dims[l]);else if(typeof d=="number")d=dn(d,this.dims[l],l),r.push([d,d+1]);else if(Array.isArray(d)&&d.length===2){if(d[0]>d[1])throw new Error(`Invalid slice: ${d}`);let p=[Math.max(d[0],0),Math.min(d[1],this.dims[l])];r.push(p),n.push(p[1]-p[0])}else throw new Error(`Invalid slice: ${d}`)}let a=r.map(([l,d])=>d-l),i=a.reduce((l,d)=>l*d),s=new this.data.constructor(i);const o=this.stride();for(let l=0;l<i;++l){let d=0;for(let p=a.length-1,u=l;p>=0;--p){const f=a[p];d+=(u%f+r[p][0])*o[p],u=Math.floor(u/f)}s[l]=this.data[d]}return new le(this.type,s,n)}permute(...e){return N0(this,e)}transpose(...e){return this.permute(...e)}sum(e=null,n=!1){return this.norm(1,e,n)}norm(e="fro",n=null,r=!1){if(e==="fro")e=2;else if(typeof e=="string")throw Error(`Unsupported norm: ${e}`);if(n===null){let s=this.data.reduce((o,l)=>o+l**e,0)**(1/e);return new le(this.type,[s],[])}n=dn(n,this.dims.length);const a=this.dims.slice();a[n]=1;const i=new this.data.constructor(this.data.length/this.dims[n]);for(let s=0;s<this.data.length;++s){let o=0;for(let l=this.dims.length-1,d=s,p=1;l>=0;--l){const u=this.dims[l];if(l!==n){const f=d%u;o+=f*p,p*=a[l]}d=Math.floor(d/u)}i[o]+=this.data[s]**e}if(e!==1)for(let s=0;s<i.length;++s)i[s]=i[s]**(1/e);return r||a.splice(n,1),new le(this.type,i,a)}normalize_(e=2,n=1){n=dn(n,this.dims.length);const r=this.norm(e,n,!0);for(let a=0;a<this.data.length;++a){let i=0;for(let s=this.dims.length-1,o=a,l=1;s>=0;--s){const d=this.dims[s];if(s!==n){const p=o%d;i+=p*l,l*=this.dims[s]}o=Math.floor(o/d)}this.data[a]/=r.data[i]}return this}normalize(e=2,n=1){return this.clone().normalize_(e,n)}stride(){return W0(this.dims)}squeeze(e=null){return new le(this.type,this.data,fd(this.dims,e))}squeeze_(e=null){return this.dims=fd(this.dims,e),this}unsqueeze(e=null){return new le(this.type,this.data,md(this.dims,e))}unsqueeze_(e=null){return this.dims=md(this.dims,e),this}flatten_(e=0,n=-1){n=(n+this.dims.length)%this.dims.length;let r=this.dims.slice(0,e),a=this.dims.slice(e,n+1),i=this.dims.slice(n+1);return this.dims=[...r,a.reduce((s,o)=>s*o,1),...i],this}flatten(e=0,n=-1){return this.clone().flatten_(e,n)}view(...e){let n=-1;for(let r=0;r<e.length;++r)if(e[r]===-1){if(n!==-1)throw new Error("Only one dimension can be inferred");n=r}if(n!==-1){const r=e.reduce((a,i,s)=>s!==n?a*i:a,1);e[n]=this.data.length/r}return new le(this.type,this.data,e)}neg_(){for(let e=0;e<this.data.length;++e)this.data[e]=-this.data[e];return this}neg(){return this.clone().neg_()}clamp_(e,n){for(let r=0;r<this.data.length;++r)this.data[r]=Math.min(Math.max(this.data[r],e),n);return this}clamp(e,n){return this.clone().clamp_(e,n)}round_(){for(let e=0;e<this.data.length;++e)this.data[e]=Math.round(this.data[e]);return this}round(){return this.clone().round_()}to(e){if(this.type===e)return this;if(!hd.hasOwnProperty(e))throw new Error(`Unsupported type: ${e}`);return new le(e,hd[e].from(this.data),this.dims)}}function D0(t,e){const n=t.length,r=e.reduce((i,s)=>i*s);if(n!==r)throw Error(`cannot reshape array of size ${n} into shape (${e})`);let a=t;for(let i=e.length-1;i>=0;i--)a=a.reduce((s,o)=>{let l=s[s.length-1];return l.length<e[i]?l.push(o):s.push([o]),s},[[]]);return a[0]}function N0(t,e){const[n,r]=tg(t.data,t.dims,e);return new le(t.type,n,r)}function n1(t,[e,n],r="bilinear",a=!1){const i=t.dims.at(-3)??1,s=t.dims.at(-2),o=t.dims.at(-1);let l=eg(t.data,[i,s,o],[e,n],r,a);return new le(t.type,l,[i,e,n])}function r1(t,e){let n=[t.dims[0],t.dims[2]],r=new t.data.constructor(n[0]*n[1]),[a,i,s]=t.dims,o=0;for(let l=0;l<a;++l){let d=l*s*i;for(let p=0;p<s;++p){let u=0,f=0,m=l*i,_=d+p;for(let $=0;$<i;++$){let b=Number(e.data[m+$]);f+=b,u+=t.data[_+$*s]*b}let v=u/f;r[o++]=v}}return new le(t.type,r,n)}function fd(t,e){return t=t.slice(),e===null?t=t.filter(n=>n!==1):typeof e=="number"?t[e]===1&&t.splice(e,1):Array.isArray(e)&&(t=t.filter((n,r)=>n!==1||!e.includes(r))),t}function md(t,e){return e=dn(e,t.length+1),t=t.slice(),t.splice(e,0,1),t}function dn(t,e,n=null){if(t<-e||t>=e)throw new Error(`IndexError: index ${t} is out of bounds for dimension${n===null?"":" "+n} with size ${e}`);return t<0&&(t=(t%e+e)%e),t}function Ms(t,e=0){e=dn(e,t[0].dims.length);const n=t[0].dims.slice();n[e]=t.reduce((s,o)=>s+o.dims[e],0);const r=n.reduce((s,o)=>s*o,1),a=new t[0].data.constructor(r),i=t[0].type;if(e===0){let s=0;for(let o of t)a.set(o.data,s),s+=o.data.length}else{let s=0;for(let o=0;o<t.length;++o){let l=t[o];for(let d=0;d<l.data.length;++d){let p=0;for(let u=l.dims.length-1,f=d,m=1;u>=0;--u){const _=l.dims[u];let v=f%_;u===e&&(v+=s),p+=v*m,m*=n[u],f=Math.floor(f/_)}a[p]=l.data[d]}s+=l.dims[e]}}return new le(i,a,n)}function L0(t,e=0){return Ms(t.map(n=>n.unsqueeze(e)),e)}function F0(t,e=null,n=1,r=!1){if(e===null){const d=t.data.reduce((m,_)=>m+_,0)/t.data.length,p=Math.sqrt(t.data.reduce((m,_)=>m+(_-d)**2,0)/(t.data.length-n)),u=new le(t.type,[d],[]);return[new le(t.type,[p],[]),u]}e=dn(e,t.dims.length);const a=Yh(t,e,r),i=t.dims.slice();i[e]=1;const s=new t.data.constructor(t.data.length/t.dims[e]);for(let l=0;l<t.data.length;++l){let d=0;for(let p=t.dims.length-1,u=l,f=1;p>=0;--p){const m=t.dims[p];if(p!==e){const _=u%m;d+=_*f,f*=i[p]}u=Math.floor(u/m)}s[d]+=(t.data[l]-a.data[d])**2}for(let l=0;l<s.length;++l)s[l]=Math.sqrt(s[l]/(t.dims[e]-n));return r||i.splice(e,1),[new le(t.type,s,i),a]}function Yh(t,e=null,n=!1){if(e===null){let i=t.data.reduce((s,o)=>s+o,0);return new le(t.type,[i/t.data.length],[])}e=dn(e,t.dims.length);const r=t.dims.slice();r[e]=1;const a=new t.data.constructor(t.data.length/t.dims[e]);for(let i=0;i<t.data.length;++i){let s=0;for(let o=t.dims.length-1,l=i,d=1;o>=0;--o){const p=t.dims[o];if(o!==e){const u=l%p;s+=u*d,d*=r[o]}l=Math.floor(l/p)}a[s]+=t.data[i]}if(t.dims[e]!==1)for(let i=0;i<a.length;++i)a[i]=a[i]/t.dims[e];return n||r.splice(e,1),new le(t.type,a,r)}function U0(t){const[e,n]=t.dims,r=[e+1,n+1],a=new le("float32",new Float32Array(r[0]*r[1]).fill(1/0),r),i=new le("float32",new Float32Array(r[0]*r[1]).fill(-1),r);a[0].data[0]=0;for(let p=1;p<n+1;++p)for(let u=1;u<e+1;++u){const f=a[u-1][p-1].item(),m=a[u-1][p].item(),_=a[u][p-1].item();let v,$;f<m&&f<_?(v=f,$=0):m<f&&m<_?(v=m,$=1):(v=_,$=2),a[u].data[p]=t[u-1][p-1].item()+v,i[u].data[p]=$}let s=e,o=n;i.data.fill(2,0,r[1]);for(let p=0;p<r[0];++p)i[p].data[0]=1;let l=[],d=[];for(;s>0||o>0;)switch(l.push(s-1),d.push(o-1),i[s][o].item()){case 0:--s,--o;break;case 1:--s;break;case 2:--o;break;default:throw new Error(`Internal error in dynamic time warping. Unexpected trace[${s}, ${o}]. Please file a bug report.`)}return l.reverse(),d.reverse(),[l,d]}function W0(t){const e=new Array(t.length);for(let n=t.length-1,r=1;n>=0;--n)e[n]=r,r*=t[n];return e}function V0(t){const e=t.reduce((n,r)=>n*r,1);return new le("int64",new BigInt64Array(e).fill(1n),t)}function G0(t){return V0(t.dims)}class H0{constructor(e=(n,r)=>n>r){this._heap=[],this._comparator=e}get size(){return this._heap.length}isEmpty(){return this.size===0}peek(){return this._heap[0]}push(...e){return this.extend(e)}extend(e){for(const n of e)this._heap.push(n),this._siftUp();return this.size}pop(){const e=this.peek(),n=this.size-1;return n>0&&this._swap(0,n),this._heap.pop(),this._siftDown(),e}replace(e){const n=this.peek();return this._heap[0]=e,this._siftDown(),n}_parent(e){return(e+1>>>1)-1}_left(e){return(e<<1)+1}_right(e){return e+1<<1}_greater(e,n){return this._comparator(this._heap[e],this._heap[n])}_swap(e,n){const r=this._heap[e];this._heap[e]=this._heap[n],this._heap[n]=r}_siftUp(){let e=this.size-1;for(;e>0&&this._greater(e,this._parent(e));)this._swap(e,this._parent(e)),e=this._parent(e)}_siftDown(){let e=0;for(;this._left(e)<this.size&&this._greater(this._left(e),e)||this._right(e)<this.size&&this._greater(this._right(e),e);){const n=this._right(e)<this.size&&this._greater(this._right(e),this._left(e))?this._right(e):this._left(e);this._swap(e,n),e=n}}}class q0{constructor(){this.root=La.default()}extend(e){for(let n of e)this.push(n)}push(e){let n=this.root;for(let r of e){let a=n.children.get(r);a===void 0&&(a=La.default(),n.children.set(r,a)),n=a}n.isLeaf=!0}*commonPrefixSearch(e){let n=this.root,r="";for(let a=0;a<e.length&&n!==void 0;++a){const i=e[a];r+=i,n=n.children.get(i),n!==void 0&&n.isLeaf&&(yield r)}}}class La{constructor(e,n){this.isLeaf=e,this.children=n}static default(){return new La(!1,new Map)}}class j0{constructor(e,n,r){this.sentence=e,this.len=e.length,this.bosTokenId=n,this.eosTokenId=r,this.nodes=[],this.beginNodes=Array.from({length:this.len+1},()=>[]),this.endNodes=Array.from({length:this.len+1},()=>[]);const a=new $r(this.bosTokenId,0,0,0,0),i=new $r(this.eosTokenId,1,this.len,0,0);this.nodes.push(a.clone()),this.nodes.push(i.clone()),this.beginNodes[this.len].push(i),this.endNodes[0].push(a)}insert(e,n,r,a){const i=this.nodes.length,s=new $r(a,i,e,n,r);this.beginNodes[e].push(s),this.endNodes[e+n].push(s),this.nodes.push(s)}viterbi(){const e=this.len;let n=0;for(;n<=e;){if(this.beginNodes[n].length==0)return[];for(let o of this.beginNodes[n]){o.prev=null;let l=0,d=null;for(let p of this.endNodes[n]){const u=p.backtraceScore+o.score;(d===null||u>l)&&(d=p.clone(),l=u)}if(d!==null)o.prev=d,o.backtraceScore=l;else return[]}++n}const r=[],i=this.beginNodes[e][0].prev;if(i===null)return[];let s=i.clone();for(;s.prev!==null;)r.push(s.clone()),s=s.clone().prev.clone();return r.reverse(),r}piece(e){return this.sentence.slice(e.pos,e.pos+e.length)}tokens(){return this.viterbi().map(n=>this.piece(n))}tokenIds(){return this.viterbi().map(n=>n.tokenId)}}class $r{constructor(e,n,r,a,i){this.tokenId=e,this.nodeId=n,this.pos=r,this.length=a,this.score=i,this.prev=null,this.backtraceScore=0}clone(){const e=new $r(this.tokenId,this.nodeId,this.pos,this.length,this.score);return e.prev=this.prev,e.backtraceScore=this.backtraceScore,e}}var D=Object.freeze({Text:"Text",NumericLiteral:"NumericLiteral",BooleanLiteral:"BooleanLiteral",StringLiteral:"StringLiteral",Identifier:"Identifier",Equals:"Equals",OpenParen:"OpenParen",CloseParen:"CloseParen",OpenStatement:"OpenStatement",CloseStatement:"CloseStatement",OpenExpression:"OpenExpression",CloseExpression:"CloseExpression",OpenSquareBracket:"OpenSquareBracket",CloseSquareBracket:"CloseSquareBracket",OpenCurlyBracket:"OpenCurlyBracket",CloseCurlyBracket:"CloseCurlyBracket",Comma:"Comma",Dot:"Dot",Colon:"Colon",Pipe:"Pipe",CallOperator:"CallOperator",AdditiveBinaryOperator:"AdditiveBinaryOperator",MultiplicativeBinaryOperator:"MultiplicativeBinaryOperator",ComparisonBinaryOperator:"ComparisonBinaryOperator",UnaryOperator:"UnaryOperator",Set:"Set",If:"If",For:"For",In:"In",Is:"Is",NotIn:"NotIn",Else:"Else",EndIf:"EndIf",ElseIf:"ElseIf",EndFor:"EndFor",And:"And",Or:"Or",Not:"UnaryOperator"}),gd=Object.freeze({set:D.Set,for:D.For,in:D.In,is:D.Is,if:D.If,else:D.Else,endif:D.EndIf,elif:D.ElseIf,endfor:D.EndFor,and:D.And,or:D.Or,not:D.Not,"not in":D.NotIn,true:D.BooleanLiteral,false:D.BooleanLiteral}),yn=class{constructor(t,e){this.value=t,this.type=e}};function _d(t){return/\w/.test(t)}function Fi(t){return/[0-9]/.test(t)}var K0=[["{%",D.OpenStatement],["%}",D.CloseStatement],["{{",D.OpenExpression],["}}",D.CloseExpression],["(",D.OpenParen],[")",D.CloseParen],["{",D.OpenCurlyBracket],["}",D.CloseCurlyBracket],["[",D.OpenSquareBracket],["]",D.CloseSquareBracket],[",",D.Comma],[".",D.Dot],[":",D.Colon],["|",D.Pipe],["<=",D.ComparisonBinaryOperator],[">=",D.ComparisonBinaryOperator],["==",D.ComparisonBinaryOperator],["!=",D.ComparisonBinaryOperator],["<",D.ComparisonBinaryOperator],[">",D.ComparisonBinaryOperator],["+",D.AdditiveBinaryOperator],["-",D.AdditiveBinaryOperator],["*",D.MultiplicativeBinaryOperator],["/",D.MultiplicativeBinaryOperator],["%",D.MultiplicativeBinaryOperator],["=",D.Equals]],Y0=new Map([["n",`
`],["t","	"],["r","\r"],["b","\b"],["f","\f"],["v","\v"],["'","'"],['"','"'],["\\","\\"]]);function X0(t,e={}){return t.endsWith(`
`)&&(t=t.slice(0,-1)),t=t.replace(/{#.*?#}/gs,"{##}"),e.lstrip_blocks&&(t=t.replace(/^[ \t]*({[#%])/gm,"$1")),e.trim_blocks&&(t=t.replace(/([#%]})\n/g,"$1")),t.replace(/{##}/g,"").replace(/-%}\s*/g,"%}").replace(/\s*{%-/g,"{%").replace(/-}}\s*/g,"}}").replace(/\s*{{-/g,"{{")}function Q0(t,e={}){const n=[],r=X0(t,e);let a=0;const i=s=>{let o="";for(;s(r[a]);){if(r[a]==="\\"){if(++a,a>=r.length)throw new SyntaxError("Unexpected end of input");const l=r[a++],d=Y0.get(l);if(d===void 0)throw new SyntaxError(`Unexpected escaped character: ${l}`);o+=d;continue}if(o+=r[a++],a>=r.length)throw new SyntaxError("Unexpected end of input")}return o};e:for(;a<r.length;){const s=n.at(-1)?.type;if(s===void 0||s===D.CloseStatement||s===D.CloseExpression){let l="";for(;a<r.length&&!(r[a]==="{"&&(r[a+1]==="%"||r[a+1]==="{"));)l+=r[a++];if(l.length>0){n.push(new yn(l,D.Text));continue}}i(l=>/\s/.test(l));const o=r[a];if(o==="-"||o==="+"){const l=n.at(-1)?.type;if(l===D.Text||l===void 0)throw new SyntaxError(`Unexpected character: ${o}`);switch(l){case D.Identifier:case D.NumericLiteral:case D.BooleanLiteral:case D.StringLiteral:case D.CloseParen:case D.CloseSquareBracket:break;default:{++a;const d=i(Fi);n.push(new yn(`${o}${d}`,d.length>0?D.NumericLiteral:D.UnaryOperator));continue}}}for(const[l,d]of K0)if(r.slice(a,a+l.length)===l){n.push(new yn(l,d)),a+=l.length;continue e}if(o==="'"||o==='"'){++a;const l=i(d=>d!==o);n.push(new yn(l,D.StringLiteral)),++a;continue}if(Fi(o)){const l=i(Fi);n.push(new yn(l,D.NumericLiteral));continue}if(_d(o)){const l=i(_d),d=Object.hasOwn(gd,l)?gd[l]:D.Identifier;d===D.In&&n.at(-1)?.type===D.Not?(n.pop(),n.push(new yn("not in",D.NotIn))):n.push(new yn(l,d));continue}throw new SyntaxError(`Unexpected character: ${o}`)}return n}var zr=class{type="Statement"},Z0=class extends zr{constructor(t){super(),this.body=t}type="Program"},wd=class extends zr{constructor(t,e,n){super(),this.test=t,this.body=e,this.alternate=n}type="If"},J0=class extends zr{constructor(t,e,n){super(),this.loopvar=t,this.iterable=e,this.body=n}type="For"},e_=class extends zr{constructor(t,e){super(),this.assignee=t,this.value=e}type="Set"},jt=class extends zr{type="Expression"},t_=class extends jt{constructor(t,e,n){super(),this.object=t,this.property=e,this.computed=n}type="MemberExpression"},n_=class extends jt{constructor(t,e){super(),this.callee=t,this.args=e}type="CallExpression"},Bn=class extends jt{constructor(t){super(),this.value=t}type="Identifier"},Gn=class extends jt{constructor(t){super(),this.value=t}type="Literal"},r_=class extends Gn{type="NumericLiteral"},yd=class extends Gn{type="StringLiteral"},vd=class extends Gn{type="BooleanLiteral"},a_=class extends Gn{type="ArrayLiteral"},bd=class extends Gn{type="TupleLiteral"},i_=class extends Gn{type="ObjectLiteral"},wr=class extends jt{constructor(t,e,n){super(),this.operator=t,this.left=e,this.right=n}type="BinaryExpression"},s_=class extends jt{constructor(t,e){super(),this.operand=t,this.filter=e}type="FilterExpression"},o_=class extends jt{constructor(t,e,n){super(),this.operand=t,this.negate=e,this.test=n}type="TestExpression"},l_=class extends jt{constructor(t,e){super(),this.operator=t,this.argument=e}type="UnaryExpression"},u_=class extends jt{constructor(t=void 0,e=void 0,n=void 0){super(),this.start=t,this.stop=e,this.step=n}type="SliceExpression"},d_=class extends jt{constructor(t,e){super(),this.key=t,this.value=e}type="KeywordArgumentExpression"};function c_(t){const e=new Z0([]);let n=0;function r(B,U){const G=t[n++];if(!G||G.type!==B)throw new Error(`Parser Error: ${U}. ${G.type} !== ${B}.`);return G}function a(){switch(t[n].type){case D.Text:return o();case D.OpenStatement:return l();case D.OpenExpression:return d();default:throw new SyntaxError(`Unexpected token type: ${t[n].type}`)}}function i(...B){return n+B.length<=t.length&&B.some((U,G)=>U!==t[n+G].type)}function s(...B){return n+B.length<=t.length&&B.every((U,G)=>U===t[n+G].type)}function o(){return new yd(r(D.Text,"Expected text token").value)}function l(){r(D.OpenStatement,"Expected opening statement token");let B;switch(t[n].type){case D.Set:++n,B=p(),r(D.CloseStatement,"Expected closing statement token");break;case D.If:++n,B=u(),r(D.OpenStatement,"Expected {% token"),r(D.EndIf,"Expected endif token"),r(D.CloseStatement,"Expected %} token");break;case D.For:++n,B=m(),r(D.OpenStatement,"Expected {% token"),r(D.EndFor,"Expected endfor token"),r(D.CloseStatement,"Expected %} token");break;default:throw new SyntaxError(`Unknown statement type: ${t[n].type}`)}return B}function d(){r(D.OpenExpression,"Expected opening expression token");const B=_();return r(D.CloseExpression,"Expected closing expression token"),B}function p(){const B=_();if(s(D.Equals)){++n;const U=p();return new e_(B,U)}return B}function u(){const B=_();r(D.CloseStatement,"Expected closing statement token");const U=[],G=[];for(;!(t[n]?.type===D.OpenStatement&&(t[n+1]?.type===D.ElseIf||t[n+1]?.type===D.Else||t[n+1]?.type===D.EndIf));)U.push(a());if(t[n]?.type===D.OpenStatement&&t[n+1]?.type!==D.EndIf)if(++n,s(D.ElseIf))r(D.ElseIf,"Expected elseif token"),G.push(u());else for(r(D.Else,"Expected else token"),r(D.CloseStatement,"Expected closing statement token");!(t[n]?.type===D.OpenStatement&&t[n+1]?.type===D.EndIf);)G.push(a());return new wd(B,U,G)}function f(B=!1){const U=B?K:_,G=[U()],ne=s(D.Comma);for(;ne&&(++n,G.push(U()),!!s(D.Comma)););return ne?new bd(G):G[0]}function m(){const B=f(!0);if(!(B instanceof Bn||B instanceof bd))throw new SyntaxError(`Expected identifier/tuple for the loop variable, got ${B.type} instead`);r(D.In,"Expected `in` keyword following loop variable");const U=_();r(D.CloseStatement,"Expected closing statement token");const G=[];for(;i(D.OpenStatement,D.EndFor);)G.push(a());return new J0(B,U,G)}function _(){return v()}function v(){const B=$();if(s(D.If)){++n;const U=$();r(D.Else,"Expected else token");const G=$();return new wd(U,[B],[G])}return B}function $(){let B=b();for(;s(D.Or);){const U=t[n];++n;const G=b();B=new wr(U,B,G)}return B}function b(){let B=S();for(;s(D.And);){const U=t[n];++n;const G=S();B=new wr(U,B,G)}return B}function S(){let B;for(;s(D.Not);){const U=t[n];++n;const G=S();B=new l_(U,G)}return B??T()}function T(){let B=E();for(;s(D.ComparisonBinaryOperator)||s(D.In)||s(D.NotIn);){const U=t[n];++n;const G=E();B=new wr(U,B,G)}return B}function E(){let B=A();for(;s(D.AdditiveBinaryOperator);){const U=t[n];++n;const G=A();B=new wr(U,B,G)}return B}function I(){const B=X();return s(D.OpenParen)?M(B):B}function M(B){let U=new n_(B,F());return s(D.OpenParen)&&(U=M(U)),U}function F(){r(D.OpenParen,"Expected opening parenthesis for arguments list");const B=L();return r(D.CloseParen,"Expected closing parenthesis for arguments list"),B}function L(){const B=[];for(;!s(D.CloseParen);){let U=_();if(s(D.Equals)){if(++n,!(U instanceof Bn))throw new SyntaxError("Expected identifier for keyword argument");const G=_();U=new d_(U,G)}B.push(U),s(D.Comma)&&++n}return B}function W(){const B=[];let U=!1;for(;!s(D.CloseSquareBracket);)s(D.Colon)?(B.push(void 0),++n,U=!0):(B.push(_()),s(D.Colon)&&(++n,U=!0));if(B.length===0)throw new SyntaxError("Expected at least one argument for member/slice expression");if(U){if(B.length>3)throw new SyntaxError("Expected 0-3 arguments for slice expression");return new u_(...B)}return B[0]}function X(){let B=K();for(;s(D.Dot)||s(D.OpenSquareBracket);){const U=t[n];++n;let G;const ne=U.type!==D.Dot;if(ne)G=W(),r(D.CloseSquareBracket,"Expected closing square bracket");else if(G=K(),G.type!=="Identifier")throw new SyntaxError("Expected identifier following dot operator");B=new t_(B,G,ne)}return B}function A(){let B=q();for(;s(D.MultiplicativeBinaryOperator);){const U=t[n];++n;const G=q();B=new wr(U,B,G)}return B}function q(){let B=te();for(;s(D.Is);){++n;const U=s(D.Not);U&&++n;let G=K();if(G instanceof vd&&(G=new Bn(G.value.toString())),!(G instanceof Bn))throw new SyntaxError("Expected identifier for the test");B=new o_(B,U,G)}return B}function te(){let B=I();for(;s(D.Pipe);){++n;let U=K();if(!(U instanceof Bn))throw new SyntaxError("Expected identifier for the filter");s(D.OpenParen)&&(U=M(U)),B=new s_(B,U)}return B}function K(){const B=t[n];switch(B.type){case D.NumericLiteral:return++n,new r_(Number(B.value));case D.StringLiteral:return++n,new yd(B.value);case D.BooleanLiteral:return++n,new vd(B.value==="true");case D.Identifier:return++n,new Bn(B.value);case D.OpenParen:{++n;const U=f();if(t[n].type!==D.CloseParen)throw new SyntaxError(`Expected closing parenthesis, got ${t[n].type} instead`);return++n,U}case D.OpenSquareBracket:{++n;const U=[];for(;!s(D.CloseSquareBracket);)U.push(_()),s(D.Comma)&&++n;return++n,new a_(U)}case D.OpenCurlyBracket:{++n;const U=new Map;for(;!s(D.CloseCurlyBracket);){const G=_();r(D.Colon,"Expected colon between key and value in object literal");const ne=_();U.set(G,ne),s(D.Comma)&&++n}return++n,new i_(U)}default:throw new SyntaxError(`Unexpected token: ${B.type}`)}}for(;n<t.length;)e.body.push(a());return e}function p_(t,e,n=1){e===void 0&&(e=t,t=0);const r=[];for(let a=t;a<e;a+=n)r.push(a);return r}function $d(t,e,n,r=1){const a=Math.sign(r);a>=0?(e=(e??=0)<0?Math.max(t.length+e,0):Math.min(e,t.length),n=(n??=t.length)<0?Math.max(t.length+n,0):Math.min(n,t.length)):(e=(e??=t.length-1)<0?Math.max(t.length+e,-1):Math.min(e,t.length-1),n=(n??=-1)<-1?Math.max(t.length+n,-1):Math.min(n,t.length-1));const i=[];for(let s=e;a*s<a*n;s+=r)i.push(t[s]);return i}function Xh(t){return t.replace(/\b\w/g,e=>e.toUpperCase())}var en=class{type="RuntimeValue";value;builtins=new Map;constructor(t=void 0){this.value=t}__bool__(){return new Ze(!!this.value)}},Ge=class extends en{type="NumericValue"},Ae=class extends en{type="StringValue";builtins=new Map([["upper",new Jt(()=>new Ae(this.value.toUpperCase()))],["lower",new Jt(()=>new Ae(this.value.toLowerCase()))],["strip",new Jt(()=>new Ae(this.value.trim()))],["title",new Jt(()=>new Ae(Xh(this.value)))],["length",new Ge(this.value.length)]])},Ze=class extends en{type="BooleanValue"},Ot=class extends en{type="ObjectValue";__bool__(){return new Ze(this.value.size>0)}builtins=new Map([["get",new Jt(([t,e])=>{if(!(t instanceof Ae))throw new Error(`Object key must be a string: got ${t.type}`);return this.value.get(t.value)??e??new xr})],["items",new Jt(()=>new je(Array.from(this.value.entries()).map(([t,e])=>new je([new Ae(t),e]))))]])},je=class extends en{type="ArrayValue";builtins=new Map([["length",new Ge(this.value.length)]]);__bool__(){return new Ze(this.value.length>0)}},h_=class extends je{type="TupleValue"},Jt=class extends en{type="FunctionValue"},xr=class extends en{type="NullValue"},Mt=class extends en{type="UndefinedValue"},is=class{constructor(t){this.parent=t}variables=new Map([["namespace",new Jt(t=>{if(t.length===0)return new Ot(new Map);if(t.length!==1||!(t[0]instanceof Ot))throw new Error("`namespace` expects either zero arguments or a single object argument");return t[0]})]]);tests=new Map([["boolean",t=>t.type==="BooleanValue"],["callable",t=>t instanceof Jt],["odd",t=>{if(t.type!=="NumericValue")throw new Error(`Cannot apply test "odd" to type: ${t.type}`);return t.value%2!==0}],["even",t=>{if(t.type!=="NumericValue")throw new Error(`Cannot apply test "even" to type: ${t.type}`);return t.value%2===0}],["false",t=>t.type==="BooleanValue"&&!t.value],["true",t=>t.type==="BooleanValue"&&t.value],["number",t=>t.type==="NumericValue"],["integer",t=>t.type==="NumericValue"&&Number.isInteger(t.value)],["iterable",t=>t instanceof je||t instanceof Ae],["lower",t=>{const e=t.value;return t.type==="StringValue"&&e===e.toLowerCase()}],["upper",t=>{const e=t.value;return t.type==="StringValue"&&e===e.toUpperCase()}],["none",t=>t.type==="NullValue"],["defined",t=>t.type!=="UndefinedValue"],["undefined",t=>t.type==="UndefinedValue"],["equalto",(t,e)=>t.value===e.value]]);set(t,e){return this.declareVariable(t,Ca(e))}declareVariable(t,e){if(this.variables.has(t))throw new SyntaxError(`Variable already declared: ${t}`);return this.variables.set(t,e),e}setVariable(t,e){return this.variables.set(t,e),e}resolve(t){if(this.variables.has(t))return this;if(this.parent)return this.parent.resolve(t);throw new Error(`Unknown variable: ${t}`)}lookupVariable(t){try{return this.resolve(t).variables.get(t)??new Mt}catch{return new Mt}}},f_=class{global;constructor(t){this.global=t??new is}run(t){return this.evaluate(t,this.global)}evaluateBinaryExpression(t,e){const n=this.evaluate(t.left,e);switch(t.operator.value){case"and":return n.__bool__().value?this.evaluate(t.right,e):n;case"or":return n.__bool__().value?n:this.evaluate(t.right,e)}const r=this.evaluate(t.right,e);switch(t.operator.value){case"==":return new Ze(n.value==r.value);case"!=":return new Ze(n.value!=r.value)}if(n instanceof Mt||r instanceof Mt)throw new Error("Cannot perform operation on undefined values");if(n instanceof xr||r instanceof xr)throw new Error("Cannot perform operation on null values");if(n instanceof Ge&&r instanceof Ge)switch(t.operator.value){case"+":return new Ge(n.value+r.value);case"-":return new Ge(n.value-r.value);case"*":return new Ge(n.value*r.value);case"/":return new Ge(n.value/r.value);case"%":return new Ge(n.value%r.value);case"<":return new Ze(n.value<r.value);case">":return new Ze(n.value>r.value);case">=":return new Ze(n.value>=r.value);case"<=":return new Ze(n.value<=r.value)}else if(n instanceof je&&r instanceof je)switch(t.operator.value){case"+":return new je(n.value.concat(r.value))}else if(r instanceof je){const a=r.value.find(i=>i.value===n.value)!==void 0;switch(t.operator.value){case"in":return new Ze(a);case"not in":return new Ze(!a)}}if(n instanceof Ae||r instanceof Ae)switch(t.operator.value){case"+":return new Ae(n.value.toString()+r.value.toString())}if(n instanceof Ae&&r instanceof Ae)switch(t.operator.value){case"in":return new Ze(r.value.includes(n.value));case"not in":return new Ze(!r.value.includes(n.value))}if(n instanceof Ae&&r instanceof Ot)switch(t.operator.value){case"in":return new Ze(r.value.has(n.value));case"not in":return new Ze(!r.value.has(n.value))}throw new SyntaxError(`Unknown operator "${t.operator.value}" between ${n.type} and ${r.type}`)}evaluateFilterExpression(t,e){const n=this.evaluate(t.operand,e);if(t.filter.type==="Identifier"){const r=t.filter;if(n instanceof je)switch(r.value){case"list":return n;case"first":return n.value[0];case"last":return n.value[n.value.length-1];case"length":return new Ge(n.value.length);case"reverse":return new je(n.value.reverse());case"sort":return new je(n.value.sort((a,i)=>{if(a.type!==i.type)throw new Error(`Cannot compare different types: ${a.type} and ${i.type}`);switch(a.type){case"NumericValue":return a.value-i.value;case"StringValue":return a.value.localeCompare(i.value);default:throw new Error(`Cannot compare type: ${a.type}`)}}));default:throw new Error(`Unknown ArrayValue filter: ${r.value}`)}else if(n instanceof Ae)switch(r.value){case"length":return new Ge(n.value.length);case"upper":return new Ae(n.value.toUpperCase());case"lower":return new Ae(n.value.toLowerCase());case"title":return new Ae(Xh(n.value));case"capitalize":return new Ae(n.value.charAt(0).toUpperCase()+n.value.slice(1));case"trim":return new Ae(n.value.trim());default:throw new Error(`Unknown StringValue filter: ${r.value}`)}else if(n instanceof Ge)switch(r.value){case"abs":return new Ge(Math.abs(n.value));default:throw new Error(`Unknown NumericValue filter: ${r.value}`)}else if(n instanceof Ot)switch(r.value){case"items":return new je(Array.from(n.value.entries()).map(([a,i])=>new je([new Ae(a),i])));case"length":return new Ge(n.value.size);default:throw new Error(`Unknown ObjectValue filter: ${r.value}`)}throw new Error(`Cannot apply filter "${r.value}" to type: ${n.type}`)}else if(t.filter.type==="CallExpression"){const r=t.filter;if(r.callee.type!=="Identifier")throw new Error(`Unknown filter: ${r.callee.type}`);const a=r.callee.value;if(n instanceof je){switch(a){case"selectattr":{if(n.value.some(p=>!(p instanceof Ot)))throw new Error("`selectattr` can only be applied to array of objects");if(r.args.some(p=>p.type!=="StringLiteral"))throw new Error("arguments of `selectattr` must be strings");const[i,s,o]=r.args.map(p=>this.evaluate(p,e));let l;if(s){const p=e.tests.get(s.value);if(!p)throw new Error(`Unknown test: ${s.value}`);l=p}else l=(...p)=>p[0].__bool__().value;const d=n.value.filter(p=>{const u=p.value.get(i.value);return u?l(u,o):!1});return new je(d)}}throw new Error(`Unknown ArrayValue filter: ${a}`)}else throw new Error(`Cannot apply filter "${a}" to type: ${n.type}`)}throw new Error(`Unknown filter: ${t.filter.type}`)}evaluateTestExpression(t,e){const n=this.evaluate(t.operand,e),r=e.tests.get(t.test.value);if(!r)throw new Error(`Unknown test: ${t.test.value}`);const a=r(n);return new Ze(t.negate?!a:a)}evaluateUnaryExpression(t,e){const n=this.evaluate(t.argument,e);switch(t.operator.value){case"not":return new Ze(!n.value);default:throw new SyntaxError(`Unknown operator: ${t.operator.value}`)}}evalProgram(t,e){return this.evaluateBlock(t.body,e)}evaluateBlock(t,e){let n="";for(const r of t){const a=this.evaluate(r,e);a.type!=="NullValue"&&a.type!=="UndefinedValue"&&(n+=a.value)}return new Ae(n)}evaluateIdentifier(t,e){return e.lookupVariable(t.value)}evaluateCallExpression(t,e){const n=[],r=new Map;for(const i of t.args)if(i.type==="KeywordArgumentExpression"){const s=i;r.set(s.key.value,this.evaluate(s.value,e))}else n.push(this.evaluate(i,e));r.size>0&&n.push(new Ot(r));const a=this.evaluate(t.callee,e);if(a.type!=="FunctionValue")throw new Error(`Cannot call something that is not a function: got ${a.type}`);return a.value(n,e)}evaluateSliceExpression(t,e,n){if(!(t instanceof je||t instanceof Ae))throw new Error("Slice object must be an array or string");const r=this.evaluate(e.start,n),a=this.evaluate(e.stop,n),i=this.evaluate(e.step,n);if(!(r instanceof Ge||r instanceof Mt))throw new Error("Slice start must be numeric or undefined");if(!(a instanceof Ge||a instanceof Mt))throw new Error("Slice stop must be numeric or undefined");if(!(i instanceof Ge||i instanceof Mt))throw new Error("Slice step must be numeric or undefined");return t instanceof je?new je($d(t.value,r.value,a.value,i.value)):new Ae($d(Array.from(t.value),r.value,a.value,i.value).join(""))}evaluateMemberExpression(t,e){const n=this.evaluate(t.object,e);let r;if(t.computed){if(t.property.type==="SliceExpression")return this.evaluateSliceExpression(n,t.property,e);r=this.evaluate(t.property,e)}else r=new Ae(t.property.value);let a;if(n instanceof Ot){if(!(r instanceof Ae))throw new Error(`Cannot access property with non-string: got ${r.type}`);a=n.value.get(r.value)??n.builtins.get(r.value)}else if(n instanceof je||n instanceof Ae)if(r instanceof Ge)a=n.value.at(r.value),n instanceof Ae&&(a=new Ae(n.value.at(r.value)));else if(r instanceof Ae)a=n.builtins.get(r.value);else throw new Error(`Cannot access property with non-string/non-number: got ${r.type}`);else{if(!(r instanceof Ae))throw new Error(`Cannot access property with non-string: got ${r.type}`);a=n.builtins.get(r.value)}return a instanceof en?a:new Mt}evaluateSet(t,e){const n=this.evaluate(t.value,e);if(t.assignee.type==="Identifier"){const r=t.assignee.value;e.setVariable(r,n)}else if(t.assignee.type==="MemberExpression"){const r=t.assignee,a=this.evaluate(r.object,e);if(!(a instanceof Ot))throw new Error("Cannot assign to member of non-object");if(r.property.type!=="Identifier")throw new Error("Cannot assign to member with non-identifier property");a.value.set(r.property.value,n)}else throw new Error(`Invalid LHS inside assignment expression: ${JSON.stringify(t.assignee)}`);return new xr}evaluateIf(t,e){const n=this.evaluate(t.test,e);return this.evaluateBlock(n.__bool__().value?t.body:t.alternate,e)}evaluateFor(t,e){const n=new is(e),r=this.evaluate(t.iterable,n);if(!(r instanceof je))throw new Error(`Expected iterable type in for loop: got ${r.type}`);let a="";for(let i=0;i<r.value.length;++i){const s=new Map([["index",new Ge(i+1)],["index0",new Ge(i)],["revindex",new Ge(r.value.length-i)],["revindex0",new Ge(r.value.length-i-1)],["first",new Ze(i===0)],["last",new Ze(i===r.value.length-1)],["length",new Ge(r.value.length)],["previtem",i>0?r.value[i-1]:new Mt],["nextitem",i<r.value.length-1?r.value[i+1]:new Mt]]);n.setVariable("loop",new Ot(s));const o=r.value[i];if(t.loopvar.type==="Identifier")n.setVariable(t.loopvar.value,o);else if(t.loopvar.type==="TupleLiteral"){const d=t.loopvar;if(o.type!=="ArrayValue")throw new Error(`Cannot unpack non-iterable type: ${o.type}`);const p=o;if(d.value.length!==p.value.length)throw new Error(`Too ${d.value.length>p.value.length?"few":"many"} items to unpack`);for(let u=0;u<d.value.length;++u){if(d.value[u].type!=="Identifier")throw new Error(`Cannot unpack non-identifier type: ${d.value[u].type}`);n.setVariable(d.value[u].value,p.value[u])}}const l=this.evaluateBlock(t.body,n);a+=l.value}return new Ae(a)}evaluate(t,e){if(t===void 0)return new Mt;switch(t.type){case"Program":return this.evalProgram(t,e);case"Set":return this.evaluateSet(t,e);case"If":return this.evaluateIf(t,e);case"For":return this.evaluateFor(t,e);case"NumericLiteral":return new Ge(Number(t.value));case"StringLiteral":return new Ae(t.value);case"BooleanLiteral":return new Ze(t.value);case"ArrayLiteral":return new je(t.value.map(n=>this.evaluate(n,e)));case"TupleLiteral":return new h_(t.value.map(n=>this.evaluate(n,e)));case"ObjectLiteral":{const n=new Map;for(const[r,a]of t.value){const i=this.evaluate(r,e);if(!(i instanceof Ae))throw new Error(`Object keys must be strings: got ${i.type}`);n.set(i.value,this.evaluate(a,e))}return new Ot(n)}case"Identifier":return this.evaluateIdentifier(t,e);case"CallExpression":return this.evaluateCallExpression(t,e);case"MemberExpression":return this.evaluateMemberExpression(t,e);case"UnaryExpression":return this.evaluateUnaryExpression(t,e);case"BinaryExpression":return this.evaluateBinaryExpression(t,e);case"FilterExpression":return this.evaluateFilterExpression(t,e);case"TestExpression":return this.evaluateTestExpression(t,e);default:throw new SyntaxError(`Unknown node type: ${t.type}`)}}};function Ca(t){switch(typeof t){case"number":return new Ge(t);case"string":return new Ae(t);case"boolean":return new Ze(t);case"object":return t===null?new xr:Array.isArray(t)?new je(t.map(Ca)):new Ot(new Map(Object.entries(t).map(([e,n])=>[e,Ca(n)])));case"function":return new Jt((e,n)=>{const r=t(...e.map(a=>a.value))??null;return Ca(r)});default:throw new Error(`Cannot convert to runtime value: ${t}`)}}var m_=class{parsed;constructor(t){const e=Q0(t,{lstrip_blocks:!0,trim_blocks:!0});this.parsed=c_(e)}render(t){const e=new is;e.set("false",!1),e.set("true",!0),e.set("raise_exception",a=>{throw new Error(a)}),e.set("range",p_);for(const[a,i]of Object.entries(t))e.set(a,i);return new f_(e).run(this.parsed).value}};async function Qh(t,e){const n=await Promise.all([Er(t,"tokenizer.json",!0,e),Er(t,"tokenizer_config.json",!0,e)]);return e.legacy!==null&&(n[1].legacy=e.legacy),n}function g_(t,e){const n=[];let r=0;for(const a of t.matchAll(e)){const i=a[0];r<a.index&&n.push(t.slice(r,a.index)),i.length>0&&n.push(i),r=a.index+i.length}return r<t.length&&n.push(t.slice(r)),n}function Ga(t,e=!0){if(t.Regex!==void 0){let n=t.Regex.replace(/\\([#&~])/g,"$1");for(const[r,a]of v_)n=n.replaceAll(r,a);return new RegExp(n,"gu")}else if(t.String!==void 0){const n=kd(t.String);return new RegExp(e?n:`(${n})`,"gu")}else return console.warn("Unknown pattern type:",t),null}function Os(t){return new Map(Object.entries(t))}function Zh(t){const e=t.dims;switch(e.length){case 1:return t.tolist();case 2:if(e[0]!==1)throw new Error("Unable to decode tensor with `batch size !== 1`. Use `tokenizer.batch_decode(...)` for batched inputs.");return t.tolist()[0];default:throw new Error(`Expected tensor to have 1-2 dimensions, got ${e.length}.`)}}function zs(t){return t.replace(/ \./g,".").replace(/ \?/g,"?").replace(/ \!/g,"!").replace(/ ,/g,",").replace(/ \' /g,"'").replace(/ n\'t/g,"n't").replace(/ \'m/g,"'m").replace(/ \'s/g,"'s").replace(/ \'ve/g,"'ve").replace(/ \'re/g,"'re")}function Jh(t){return t.replace(/[\u0300-\u036f]/g,"")}function __(t){return Jh(t.toLowerCase())}function w_(t,e,n){const r=[];let a=0;for(;a<t.length;){if(r.push(t[a]),(n.get(t[a])??e)!==e){++a;continue}for(;a<t.length&&(n.get(t[a])??e)===e;)++a}return r}function y_(t){return t.match(/\S+/g)||[]}const Ir="\\p{P}\\u0021-\\u002F\\u003A-\\u0040\\u005B-\\u0060\\u007B-\\u007E",v_=new Map([["(?i:'s|'t|'re|'ve|'m|'ll|'d)","(?:'([sS]|[tT]|[rR][eE]|[vV][eE]|[mM]|[lL][lL]|[dD]))"]]);class b_{constructor(e){this.content=e.content,this.id=e.id,this.single_word=e.single_word??!1,this.lstrip=e.lstrip??!1,this.rstrip=e.rstrip??!1,this.special=e.special??!1,this.normalized=e.normalized??null}}class Rr extends qt{constructor(e){super(),this.config=e,this.vocab=[],this.tokens_to_ids=new Map,this.unk_token_id=void 0,this.unk_token=void 0,this.end_of_word_suffix=void 0,this.fuse_unk=this.config.fuse_unk??!1}static fromConfig(e,...n){switch(e.type){case"WordPiece":return new $_(e);case"Unigram":return new x_(e,...n);case"BPE":return new E_(e);default:if(e.vocab)return new k_(e,...n);throw new Error(`Unknown TokenizerModel type: ${e.type}`)}}_call(e){let n=this.encode(e);return this.fuse_unk&&(n=w_(n,this.unk_token_id,this.tokens_to_ids)),n}encode(e){throw Error("encode should be implemented in subclass.")}convert_tokens_to_ids(e){return e.map(n=>this.tokens_to_ids.get(n)??this.unk_token_id)}convert_ids_to_tokens(e){return e.map(n=>this.vocab[n]??this.unk_token)}}class $_ extends Rr{constructor(e){super(e),this.tokens_to_ids=Os(e.vocab),this.unk_token_id=this.tokens_to_ids.get(e.unk_token),this.unk_token=e.unk_token,this.max_input_chars_per_word=e.max_input_chars_per_word??100,this.vocab=new Array(this.tokens_to_ids.size);for(const[n,r]of this.tokens_to_ids)this.vocab[r]=n}encode(e){const n=[];for(const r of e){const a=[...r];if(a.length>this.max_input_chars_per_word){n.push(this.unk_token);continue}let i=!1,s=0;const o=[];for(;s<a.length;){let l=a.length,d=null;for(;s<l;){let p=a.slice(s,l).join("");if(s>0&&(p=this.config.continuing_subword_prefix+p),this.tokens_to_ids.has(p)){d=p;break}--l}if(d===null){i=!0;break}o.push(d),s=l}i?n.push(this.unk_token):n.push(...o)}return n}}class x_ extends Rr{constructor(e,n){super(e);const r=e.vocab.length;this.vocab=new Array(r),this.scores=new Array(r);for(let a=0;a<r;++a){const i=e.vocab[a];this.vocab[a]=i[0],this.scores[a]=i[1]}this.unk_token_id=e.unk_id,this.unk_token=this.vocab[e.unk_id],this.tokens_to_ids=new Map(this.vocab.map((a,i)=>[a,i])),this.bosToken=" ",this.bosTokenId=this.tokens_to_ids.get(this.bosToken),this.eosToken=n.eos_token,this.eosTokenId=this.tokens_to_ids.get(this.eosToken),this.unkToken=this.vocab[this.unk_token_id],this.minScore=rg(this.scores)[0],this.unkScore=this.minScore-10,this.scores[this.unk_token_id]=this.unkScore,this.trie=new q0,this.trie.extend(this.vocab),this.fuse_unk=!0}populateNodes(e){const n=e.sentence,r=n.length;let a=0;for(;a<r;){let s=!1;for(let o of this.trie.commonPrefixSearch(n.slice(a))){const l=this.tokens_to_ids.get(o),d=this.scores[l],p=o.length;e.insert(a,p,d,l),!s&&p===1&&(s=!0)}s||e.insert(a,1,this.unkScore,this.unk_token_id),a+=1}}tokenize(e){const n=new j0(e,this.bosTokenId,this.eosTokenId);return this.populateNodes(n),n.tokens()}encode(e){const n=[];for(const r of e){const a=this.tokenize(r);n.push(...a)}return n}}const ef=(()=>{const t=[...Array.from({length:94},(a,i)=>i+33),...Array.from({length:12},(a,i)=>i+161),...Array.from({length:82},(a,i)=>i+174)],e=t.slice();let n=0;for(let a=0;a<256;++a)t.includes(a)||(t.push(a),e.push(256+n),n+=1);const r=e.map(a=>String.fromCharCode(a));return Object.fromEntries(t.map((a,i)=>[a,r[i]]))})(),S_=Um(ef);class E_ extends Rr{constructor(e){super(e),this.BPE_SPLIT_TOKEN=" ",this.tokens_to_ids=Os(e.vocab),this.unk_token_id=this.tokens_to_ids.get(e.unk_token),this.unk_token=e.unk_token,this.vocab=new Array(this.tokens_to_ids.size);for(const[n,r]of this.tokens_to_ids)this.vocab[r]=n;this.bpe_ranks=new Map(e.merges.map((n,r)=>[n,r])),this.merges=e.merges.map(n=>n.split(this.BPE_SPLIT_TOKEN)),this.end_of_word_suffix=e.end_of_word_suffix,this.continuing_subword_suffix=e.continuing_subword_suffix??null,this.byte_fallback=this.config.byte_fallback??!1,this.byte_fallback&&(this.text_encoder=new TextEncoder),this.cache=new Map}bpe(e){if(e.length===0)return[];const n=this.cache.get(e);if(n!==void 0)return n;const r=Array.from(e);this.end_of_word_suffix&&(r[r.length-1]+=this.end_of_word_suffix);let a=[];if(r.length>1){const i=new H0((l,d)=>l.score<d.score);let s={token:r[0],bias:0,prev:null,next:null},o=s;for(let l=1;l<r.length;++l){const d={bias:l/r.length,token:r[l],prev:o,next:null};o.next=d,this._add_node(i,o),o=d}for(;!i.isEmpty();){const l=i.pop();if(l.deleted||!l.next||l.next.deleted)continue;if(l.deleted=!0,l.next.deleted=!0,l.prev){const p={...l.prev};l.prev.deleted=!0,l.prev=p,p.prev?p.prev.next=p:s=p}const d={token:l.token+l.next.token,bias:l.bias,prev:l.prev,next:l.next.next};d.prev?(d.prev.next=d,this._add_node(i,d.prev)):s=d,d.next&&(d.next.prev=d,this._add_node(i,d))}for(let l=s;l!==null;l=l.next)a.push(l.token)}else a=r;if(this.continuing_subword_suffix)for(let i=0;i<a.length-1;++i)a[i]+=this.continuing_subword_suffix;return this.cache.set(e,a),a}_add_node(e,n){const r=this.bpe_ranks.get(n.token+this.BPE_SPLIT_TOKEN+n.next.token);r!==void 0&&(n.score=r+n.bias,e.push(n))}encode(e){const n=[];for(const r of e){const a=this.bpe(r);for(const i of a)this.tokens_to_ids.has(i)?n.push(i):this.byte_fallback?n.push(...Array.from(this.text_encoder.encode(i)).map(s=>`<0x${s.toString(16).toUpperCase().padStart(2,"0")}>`)):n.push(this.unk_token)}return n}}class k_ extends Rr{constructor(e,n){super(e),this.tokens_to_ids=Os(n.target_lang?e.vocab[n.target_lang]:e.vocab),this.bos_token=n.bos_token,this.bos_token_id=this.tokens_to_ids.get(this.bos_token),this.eos_token=n.eos_token,this.eos_token_id=this.tokens_to_ids.get(this.eos_token),this.pad_token=n.pad_token,this.pad_token_id=this.tokens_to_ids.get(this.pad_token),this.unk_token=n.unk_token,this.unk_token_id=this.tokens_to_ids.get(this.unk_token),this.vocab=new Array(this.tokens_to_ids.size);for(const[r,a]of this.tokens_to_ids)this.vocab[a]=r}encode(e){return e}}class _t extends qt{constructor(e){super(),this.config=e}static fromConfig(e){if(e===null)return null;switch(e.type){case"BertNormalizer":return new P_(e);case"Precompiled":return new tw(e);case"Sequence":return new B_(e);case"Replace":return new T_(e);case"NFC":return new C_(e);case"NFKC":return new I_(e);case"NFKD":return new A_(e);case"Strip":return new M_(e);case"StripAccents":return new O_(e);case"Lowercase":return new z_(e);case"Prepend":return new R_(e);default:throw new Error(`Unknown Normalizer type: ${e.type}`)}}normalize(e){throw Error("normalize should be implemented in subclass.")}_call(e){return this.normalize(e)}}class T_ extends _t{normalize(e){const n=Ga(this.config.pattern);return n===null?e:e.replaceAll(n,this.config.content)}}class C_ extends _t{normalize(e){return e=e.normalize("NFC"),e}}class I_ extends _t{normalize(e){return e=e.normalize("NFKC"),e}}class A_ extends _t{normalize(e){return e=e.normalize("NFKD"),e}}class M_ extends _t{normalize(e){return this.config.strip_left&&this.config.strip_right?e=e.trim():(this.config.strip_left&&(e=e.trimStart()),this.config.strip_right&&(e=e.trimEnd())),e}}class O_ extends _t{normalize(e){return e=Jh(e),e}}class z_ extends _t{normalize(e){return e=e.toLowerCase(),e}}class R_ extends _t{normalize(e){return e=this.config.prepend+e,e}}class B_ extends _t{constructor(e){super(e),this.normalizers=e.normalizers.map(n=>_t.fromConfig(n))}normalize(e){return this.normalizers.reduce((n,r)=>r.normalize(n),e)}}class P_ extends _t{_tokenize_chinese_chars(e){const n=[];for(let r=0;r<e.length;++r){const a=e[r],i=a.charCodeAt(0);this._is_chinese_char(i)?(n.push(" "),n.push(a),n.push(" ")):n.push(a)}return n.join("")}_is_chinese_char(e){return e>=19968&&e<=40959||e>=13312&&e<=19903||e>=131072&&e<=173791||e>=173824&&e<=177983||e>=177984&&e<=178207||e>=178208&&e<=183983||e>=63744&&e<=64255||e>=194560&&e<=195103}stripAccents(e){return e.normalize("NFD").replace(/[\u0300-\u036f]/g,"")}_is_control(e){switch(e){case"	":case`
`:case"\r":return!1;default:return/^\p{Cc}|\p{Cf}|\p{Co}|\p{Cs}$/u.test(e)}}_clean_text(e){const n=[];for(const r of e){const a=r.charCodeAt(0);a===0||a===65533||this._is_control(r)||(/^\s$/.test(r)?n.push(" "):n.push(r))}return n.join("")}normalize(e){return this.config.clean_text&&(e=this._clean_text(e)),this.config.handle_chinese_chars&&(e=this._tokenize_chinese_chars(e)),this.config.lowercase?(e=e.toLowerCase(),this.config.strip_accents!==!1&&(e=this.stripAccents(e))):this.config.strip_accents&&(e=this.stripAccents(e)),e}}class St extends qt{static fromConfig(e){if(e===null)return null;switch(e.type){case"BertPreTokenizer":return new D_(e);case"Sequence":return new nw(e);case"Whitespace":return new rw(e);case"WhitespaceSplit":return new aw(e);case"Metaspace":return new rf(e);case"ByteLevel":return new N_(e);case"Split":return new L_(e);case"Punctuation":return new F_(e);case"Digits":return new U_(e);case"Replace":return new iw(e);default:throw new Error(`Unknown PreTokenizer type: ${e.type}`)}}pre_tokenize_text(e,n){throw Error("pre_tokenize_text should be implemented in subclass.")}pre_tokenize(e,n){return(Array.isArray(e)?e.map(r=>this.pre_tokenize_text(r,n)):this.pre_tokenize_text(e,n)).flat()}_call(e,n){return this.pre_tokenize(e,n)}}class D_ extends St{constructor(e){super(),this.pattern=new RegExp(`[^\\s${Ir}]+|[${Ir}]`,"gu")}pre_tokenize_text(e,n){return e.trim().match(this.pattern)||[]}}class N_ extends St{constructor(e){super(),this.config=e,this.add_prefix_space=this.config.add_prefix_space,this.trim_offsets=this.config.trim_offsets,this.use_regex=this.config.use_regex??!0,this.pattern=/'s|'t|'re|'ve|'m|'ll|'d| ?\p{L}+| ?\p{N}+| ?[^\s\p{L}\p{N}]+|\s+(?!\S)|\s+/gu,this.byte_encoder=ef,this.text_encoder=new TextEncoder}pre_tokenize_text(e,n){return this.add_prefix_space&&!e.startsWith(" ")&&(e=" "+e),(this.use_regex?e.match(this.pattern)||[]:[e]).map(a=>Array.from(this.text_encoder.encode(a),i=>this.byte_encoder[i]).join(""))}}class L_ extends St{constructor(e){super(),this.config=e,this.pattern=Ga(this.config.pattern,this.config.invert)}pre_tokenize_text(e,n){return this.pattern===null?[]:this.config.invert?e.match(this.pattern)||[]:g_(e,this.pattern)}}class F_ extends St{constructor(e){super(),this.config=e,this.pattern=new RegExp(`[^${Ir}]+|[${Ir}]+`,"gu")}pre_tokenize_text(e,n){return e.match(this.pattern)||[]}}class U_ extends St{constructor(e){super(),this.config=e;const n=`[^\\d]+|\\d${this.config.individual_digits?"":"+"}`;this.pattern=new RegExp(n,"gu")}pre_tokenize_text(e,n){return e.match(this.pattern)||[]}}class Ha extends qt{constructor(e){super(),this.config=e}static fromConfig(e){if(e===null)return null;switch(e.type){case"TemplateProcessing":return new W_(e);case"ByteLevel":return new V_(e);case"RobertaProcessing":return new nf(e);case"BertProcessing":return new tf(e);default:throw new Error(`Unknown PostProcessor type: ${e.type}`)}}post_process(e,...n){throw Error("post_process should be implemented in subclass.")}_call(e,...n){return this.post_process(e,...n)}}class tf extends Ha{constructor(e){super(e),this.cls=e.cls[0],this.sep=e.sep[0]}post_process(e,n=null,{add_special_tokens:r=!0}={}){r&&(e=st([this.cls],e,[this.sep]));let a=new Array(e.length).fill(0);if(n!==null){const i=r&&this instanceof nf?[this.sep]:[],s=r?[this.sep]:[];e=st(e,i,n,s),a=st(a,new Array(n.length+i.length+s.length).fill(1))}return{tokens:e,token_type_ids:a}}}class nf extends tf{}class W_ extends Ha{constructor(e){super(e),this.single=e.single,this.pair=e.pair}post_process(e,n=null,{add_special_tokens:r=!0}={}){const a=n===null?this.single:this.pair;let i=[],s=[];for(const o of a)"SpecialToken"in o?r&&(i.push(o.SpecialToken.id),s.push(o.SpecialToken.type_id)):"Sequence"in o&&(o.Sequence.id==="A"?(i=st(i,e),s=st(s,new Array(e.length).fill(o.Sequence.type_id))):o.Sequence.id==="B"&&(i=st(i,n),s=st(s,new Array(n.length).fill(o.Sequence.type_id))));return{tokens:i,token_type_ids:s}}}class V_ extends Ha{post_process(e,n=null){return n&&(e=st(e,n)),{tokens:e}}}class wt extends qt{constructor(e){super(),this.config=e,this.added_tokens=[],this.end_of_word_suffix=null,this.trim_offsets=e.trim_offsets}static fromConfig(e){if(e===null)return null;switch(e.type){case"WordPiece":return new K_(e);case"Metaspace":return new ew(e);case"ByteLevel":return new Y_(e);case"Replace":return new G_(e);case"ByteFallback":return new H_(e);case"Fuse":return new q_(e);case"Strip":return new j_(e);case"Sequence":return new Q_(e);case"CTC":return new X_(e);case"BPEDecoder":return new Z_(e);default:throw new Error(`Unknown Decoder type: ${e.type}`)}}_call(e){return this.decode(e)}decode(e){return this.decode_chain(e).join("")}decode_chain(e){throw Error("`decode_chain` should be implemented in subclass.")}}class G_ extends wt{decode_chain(e){const n=Ga(this.config.pattern);return n===null?e:e.map(r=>r.replaceAll(n,this.config.content))}}class H_ extends wt{constructor(e){super(e),this.text_decoder=new TextDecoder}decode_chain(e){const n=[];let r=[];for(const a of e){let i=null;if(a.length===6&&a.startsWith("<0x")&&a.endsWith(">")){const s=parseInt(a.slice(3,5),16);isNaN(s)||(i=s)}if(i!==null)r.push(i);else{if(r.length>0){const s=this.text_decoder.decode(Uint8Array.from(r));n.push(s),r=[]}n.push(a)}}if(r.length>0){const a=this.text_decoder.decode(Uint8Array.from(r));n.push(a),r=[]}return n}}class q_ extends wt{decode_chain(e){return[e.join("")]}}class j_ extends wt{constructor(e){super(e),this.content=this.config.content,this.start=this.config.start,this.stop=this.config.stop}decode_chain(e){return e.map(n=>{let r=0;for(let i=0;i<this.start&&n[i]===this.content;++i){r=i+1;continue}let a=n.length;for(let i=0;i<this.stop;++i){const s=n.length-i-1;if(n[s]===this.content){a=s;continue}else break}return n.slice(r,a)})}}class K_ extends wt{constructor(e){super(e),this.cleanup=e.cleanup}decode_chain(e){return e.map((n,r)=>(r!==0&&(n.startsWith(this.config.prefix)?n=n.replace(this.config.prefix,""):n=" "+n),this.cleanup&&(n=zs(n)),n))}}class Y_ extends wt{constructor(e){super(e),this.byte_decoder=S_,this.text_decoder=new TextDecoder("utf-8",{fatal:!1,ignoreBOM:!0}),this.end_of_word_suffix=null}convert_tokens_to_string(e){const n=e.join(""),r=new Uint8Array([...n].map(i=>this.byte_decoder[i]));return this.text_decoder.decode(r)}decode_chain(e){const n=[];let r=[];for(const a of e)this.added_tokens.find(i=>i.content===a)!==void 0?(r.length>0&&(n.push(this.convert_tokens_to_string(r)),r=[]),n.push(a)):r.push(a);return r.length>0&&n.push(this.convert_tokens_to_string(r)),n}}class X_ extends wt{constructor(e){super(e),this.pad_token=this.config.pad_token,this.word_delimiter_token=this.config.word_delimiter_token,this.cleanup=this.config.cleanup}convert_tokens_to_string(e){if(e.length===0)return"";const n=[e[0]];for(let i=1;i<e.length;++i)e[i]!==n.at(-1)&&n.push(e[i]);let a=n.filter(i=>i!==this.pad_token).join("");return this.cleanup&&(a=zs(a).replaceAll(this.word_delimiter_token," ").trim()),a}decode_chain(e){return[this.convert_tokens_to_string(e)]}}class Q_ extends wt{constructor(e){super(e),this.decoders=e.decoders.map(n=>wt.fromConfig(n))}decode_chain(e){return this.decoders.reduce((n,r)=>r.decode_chain(n),e)}}class Z_ extends wt{constructor(e){super(e),this.suffix=this.config.suffix}decode_chain(e){return e.map((n,r)=>n.replaceAll(this.suffix,r===e.length-1?"":" "))}}class J_ extends wt{decode_chain(e){let n="";for(let r=1;r<e.length;r+=2)n+=e[r];return[n]}}class rf extends St{constructor(e){super(),this.addPrefixSpace=e.add_prefix_space,this.replacement=e.replacement,this.strRep=e.str_rep||this.replacement,this.prepend_scheme=e.prepend_scheme??"always"}pre_tokenize_text(e,{section_index:n=void 0}={}){let r=e.replaceAll(" ",this.strRep);return this.addPrefixSpace&&!r.startsWith(this.replacement)&&(this.prepend_scheme==="always"||this.prepend_scheme==="first"&&n===0)&&(r=this.strRep+r),[r]}}class ew extends wt{constructor(e){super(e),this.addPrefixSpace=e.add_prefix_space,this.replacement=e.replacement}decode_chain(e){const n=[];for(let r=0;r<e.length;++r){let a=e[r].replaceAll(this.replacement," ");this.addPrefixSpace&&r==0&&a.startsWith(" ")&&(a=a.substring(1)),n.push(a)}return n}}class tw extends _t{constructor(e){super(e),this.charsmap=e.precompiled_charsmap}normalize(e){return e=e.replace(/[\u0001-\u0008\u000B\u000E-\u001F\u007F\u008F\u009F]/gm,""),e=e.replace(/[\u0009\u000A\u000C\u000D\u1680\u200B\u200C\u200E\u200F\u2028\u2029\u2581\uFEFF\uFFFD]/gm," "),e.includes("～")?e=e.split("～").map(r=>r.normalize("NFKC")).join("～"):e=e.normalize("NFKC"),e}}class nw extends St{constructor(e){super(),this.tokenizers=e.pretokenizers.map(n=>St.fromConfig(n))}pre_tokenize_text(e,n){return this.tokenizers.reduce((r,a)=>a.pre_tokenize(r,n),[e])}}class rw extends St{constructor(e){super()}pre_tokenize_text(e,n){return e.match(/\w+|[^\w\s]+/g)||[]}}class aw extends St{constructor(e){super()}pre_tokenize_text(e,n){return y_(e)}}class iw extends St{constructor(e){super(),this.config=e,this.pattern=Ga(this.config.pattern),this.content=this.config.content}pre_tokenize_text(e,n){return this.pattern===null?[e]:[e.replaceAll(this.pattern,this.config.content)]}}const sw=["bos_token","eos_token","unk_token","sep_token","pad_token","cls_token","mask_token"];function ow(t,e,n,r){for(const a of Object.keys(t)){const i=e-t[a].length,s=n(a),o=new Array(i).fill(s);t[a]=r==="right"?st(t[a],o):st(o,t[a])}}function lw(t,e){for(const n of Object.keys(t))t[n].length=e}class Se extends qt{return_token_type_ids=!1;_default_chat_template=`{% for message in messages %}{{'<|im_start|>' + message['role'] + '
' + message['content'] + '<|im_end|>' + '
'}}{% endfor %}{% if add_generation_prompt %}{{ '<|im_start|>assistant
' }}{% endif %}`;constructor(e,n){super(),this._tokenizer_config=n,this.normalizer=_t.fromConfig(e.normalizer),this.pre_tokenizer=St.fromConfig(e.pre_tokenizer),this.model=Rr.fromConfig(e.model,n),this.post_processor=Ha.fromConfig(e.post_processor),this.decoder=wt.fromConfig(e.decoder),this.special_tokens=[],this.all_special_ids=[],this.added_tokens=[];for(const r of e.added_tokens){const a=new b_(r);this.added_tokens.push(a),this.model.tokens_to_ids.set(a.content,a.id),this.model.vocab[a.id]=a.content,a.special&&(this.special_tokens.push(a.content),this.all_special_ids.push(a.id))}if(this.additional_special_tokens=n.additional_special_tokens??[],this.special_tokens.push(...this.additional_special_tokens),this.special_tokens=[...new Set(this.special_tokens)],this.decoder&&(this.decoder.added_tokens=this.added_tokens,this.decoder.end_of_word_suffix=this.model.end_of_word_suffix),this.added_tokens_regex=this.added_tokens.length>0?new RegExp(this.added_tokens.map(r=>`${r.lstrip?"\\s*":""}(${kd(r.content)})${r.rstrip?"\\s*":""}`).join("|")):null,this.mask_token=this.getToken("mask_token"),this.mask_token_id=this.model.tokens_to_ids.get(this.mask_token),this.pad_token=this.getToken("pad_token","eos_token"),this.pad_token_id=this.model.tokens_to_ids.get(this.pad_token),this.sep_token=this.getToken("sep_token"),this.sep_token_id=this.model.tokens_to_ids.get(this.sep_token),this.unk_token=this.getToken("unk_token"),this.unk_token_id=this.model.tokens_to_ids.get(this.unk_token),this.model_max_length=n.model_max_length,this.remove_space=n.remove_space,this.clean_up_tokenization_spaces=n.clean_up_tokenization_spaces??!0,this.do_lowercase_and_remove_accent=n.do_lowercase_and_remove_accent??!1,this.padding_side="right",this.legacy=!1,this.chat_template=n.chat_template??null,Array.isArray(this.chat_template)){const r=Object.create(null);for(const{name:a,template:i}of this.chat_template){if(typeof a!="string"||typeof i!="string")throw new Error('Chat template must be a list of objects with "name" and "template" properties');r[a]=i}this.chat_template=r}this._compiled_template_cache=new Map}getToken(...e){for(const n of e){const r=this._tokenizer_config[n];if(r)if(typeof r=="object"){if(r.__type==="AddedToken")return r.content;throw Error(`Unknown token: ${r}`)}else return r}return null}static async from_pretrained(e,{progress_callback:n=null,config:r=null,cache_dir:a=null,local_files_only:i=!1,revision:s="main",legacy:o=null}={}){const l=await Qh(e,{progress_callback:n,config:r,cache_dir:a,local_files_only:i,revision:s,legacy:o});return new this(...l)}_call(e,{text_pair:n=null,add_special_tokens:r=!0,padding:a=!1,truncation:i=null,max_length:s=null,return_tensor:o=!0}={}){const l=Array.isArray(e);let d;if(l){if(e.length===0)throw Error("text array must be non-empty");if(n!==null){if(Array.isArray(n)){if(e.length!==n.length)throw Error("text and text_pair must have the same length")}else throw Error("text_pair must also be an array");d=e.map((u,f)=>this._encode_plus(u,n[f],{add_special_tokens:r}))}else d=e.map(u=>this._encode_plus(u,null,{add_special_tokens:r}))}else{if(e===null)throw Error("text may not be null");if(Array.isArray(n))throw Error("When specifying `text_pair`, since `text` is a string, `text_pair` must also be a string (i.e., not an array).");d=[this._encode_plus(e,n,{add_special_tokens:r})]}if(s===null?a==="max_length"?s=this.model_max_length:s=Wa(d.map(u=>u.input_ids.length))[0]:i||console.warn("Truncation was not explicitly activated but `max_length` is provided a specific value, please use `truncation=true` to explicitly truncate examples to max length."),s=Math.min(s,this.model_max_length),a||i)for(let u=0;u<d.length;++u)d[u].input_ids.length!==s&&(d[u].input_ids.length>s?i&&lw(d[u],s):a&&ow(d[u],s,f=>f==="input_ids"?this.pad_token_id:0,this.padding_side));const p={};if(o){if(!(a&&i)&&d.some(f=>{for(const m of Object.keys(f))if(f[m].length!==d[0][m]?.length)return!0;return!1}))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=true' and 'truncation=true' to have batched tensors with the same length.");const u=[d.length,d[0].input_ids.length];for(const f of Object.keys(d[0]))p[f]=new le("int64",BigInt64Array.from(d.flatMap(m=>m[f]).map(BigInt)),u)}else{for(const u of Object.keys(d[0]))p[u]=d.map(f=>f[u]);if(!l)for(const u of Object.keys(p))p[u]=p[u][0]}return p}_encode_text(e){return e===null?null:(this.added_tokens_regex?e.split(this.added_tokens_regex).filter(a=>a):[e]).map((a,i)=>{if(this.added_tokens.find(o=>o.content===a)!==void 0)return a;{if(this.remove_space===!0&&(a=a.trim().split(/\s+/).join(" ")),this.do_lowercase_and_remove_accent&&(a=__(a)),this.normalizer!==null&&(a=this.normalizer(a)),a.length===0)return[];const o=this.pre_tokenizer!==null?this.pre_tokenizer(a,{section_index:i}):[a];return this.model(o)}}).flat()}_encode_plus(e,n=null,{add_special_tokens:r=!0}={}){const a=this._encode_text(e),i=this._encode_text(n),s=this.post_processor?this.post_processor(a,i,{add_special_tokens:r}):{tokens:st(a??[],i??[])},o=this.model.convert_tokens_to_ids(s.tokens),l={input_ids:o,attention_mask:new Array(o.length).fill(1)};return this.return_token_type_ids&&s.token_type_ids&&(l.token_type_ids=s.token_type_ids),l}encode(e,n=null,{add_special_tokens:r=!0}={}){const{input_ids:a}=this._encode_plus(e,n,{add_special_tokens:r});return a}batch_decode(e,n={}){return e instanceof le&&(e=e.tolist()),e.map(r=>this.decode(r,n))}decode(e,n={}){if(e instanceof le&&(e=Zh(e)),!Array.isArray(e)||e.length===0||!Td(e[0]))throw Error("token_ids must be a non-empty array of integers.");return this.decode_single(e,n)}decode_single(e,{skip_special_tokens:n=!1,clean_up_tokenization_spaces:r=null}){let a=this.model.convert_ids_to_tokens(e);n&&(a=a.filter(s=>!this.special_tokens.includes(s)));let i=this.decoder?this.decoder(a):a.join(" ");return this.decoder&&this.decoder.end_of_word_suffix&&(i=i.replaceAll(this.decoder.end_of_word_suffix," "),n&&(i=i.trim())),(r??this.clean_up_tokenization_spaces)&&(i=zs(i)),i}get default_chat_template(){return this._warned_about_chat_template||(console.warn("No chat template is defined for this tokenizer - using a default chat template that implements the ChatML format. If the default is not appropriate for your model, please set `tokenizer.chat_template` to an appropriate template. See https://huggingface.co/docs/transformers/main/chat_templating for more information."),this._warned_about_chat_template=!0),this._default_chat_template}apply_chat_template(e,{chat_template:n=null,add_generation_prompt:r=!1,tokenize:a=!0,padding:i=!1,truncation:s=!1,max_length:o=null,return_tensor:l=!0,tokenizer_kwargs:d={},...p}={}){if(this.chat_template&&typeof this.chat_template=="object"||this.chat_template===null&&this.default_chat_template&&typeof this.default_chat_template=="object"){const _=this.chat_template??this.default_chat_template;if(n!==null&&Object.hasOwn(_,n))n=_[n];else if(n===null&&"default"in _)n=_.default;else if(n===null)throw Error(`This model has multiple chat templates with no default specified! Please either pass a chat template or the name of the template you wish to use to the 'chat_template' argument. Available template names are ${Object.keys(_).sort()}.`)}else n??=this.chat_template??this.default_chat_template;if(typeof n!="string")throw Error(`chat_template must be a string, but got ${typeof n}`);let u=this._compiled_template_cache.get(n);u===void 0&&(u=new m_(n),this._compiled_template_cache.set(n,u));const f=Object.create(null);for(const _ of sw){const v=this.getToken(_);v&&(f[_]=v)}const m=u.render({messages:e,add_generation_prompt:r,...f,...p});return a?this._call(m,{add_special_tokens:!1,padding:i,truncation:s,max_length:o,return_tensor:l,...d}).input_ids:m}}class uw extends Se{return_token_type_ids=!0}class dw extends Se{return_token_type_ids=!0}class cw extends Se{return_token_type_ids=!0}class pw extends Se{return_token_type_ids=!0}class hw extends Se{return_token_type_ids=!0}class fw extends Se{return_token_type_ids=!0}class mw extends Se{return_token_type_ids=!0}class gw extends Se{return_token_type_ids=!0}class _w extends Se{return_token_type_ids=!0}class ww extends Se{}class yw extends Se{}class vw extends Se{return_token_type_ids=!0;constructor(e,n){super(e,n),console.warn('WARNING: `XLMTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}}class bw extends Se{return_token_type_ids=!0}class $w extends Se{}class af extends Se{_default_chat_template='{% for message in messages %}" "{{ message.content }}{{ eos_token }}" "{% endfor %}'}class xw extends Se{}class sf extends Se{constructor(e,n){super(e,n),this.languageRegex=/^[a-z]{2}_[A-Z]{2}$/,this.language_codes=this.special_tokens.filter(r=>this.languageRegex.test(r)),this.lang_to_token=r=>r}_build_translation_inputs(e,n,r){return Rs(this,e,n,r)}}class Sw extends sf{}class Ew extends Se{}class kw extends af{constructor(e,n){const r=".,!?…。，、।۔،",a=e.pre_tokenizer?.pretokenizers[0]?.pattern;a&&a.Regex===` ?[^(\\s|[${r}])]+`&&(a.Regex=` ?[^\\s${r}]+`),super(e,n)}}const ba="▁";class of extends Se{_default_chat_template=`{% if messages[0]['role'] == 'system' %}{% set loop_messages = messages[1:] %}{% set system_message = messages[0]['content'] %}{% elif USE_DEFAULT_PROMPT == true and not '<<SYS>>' in messages[0]['content'] %}{% set loop_messages = messages %}{% set system_message = 'DEFAULT_SYSTEM_MESSAGE' %}{% else %}{% set loop_messages = messages %}{% set system_message = false %}{% endif %}{% for message in loop_messages %}{% if (message['role'] == 'user') != (loop.index0 % 2 == 0) %}{{ raise_exception('Conversation roles must alternate user/assistant/user/assistant/...') }}{% endif %}{% if loop.index0 == 0 and system_message != false %}{% set content = '<<SYS>>
' + system_message + '
<</SYS>>

' + message['content'] %}{% else %}{% set content = message['content'] %}{% endif %}{% if message['role'] == 'user' %}{{ bos_token + '[INST] ' + content.strip() + ' [/INST]' }}{% elif message['role'] == 'system' %}{{ '<<SYS>>
' + content.strip() + '
<</SYS>>

' }}{% elif message['role'] == 'assistant' %}{{ ' '  + content.strip() + ' ' + eos_token }}{% endif %}{% endfor %}`;DEFAULT_SYSTEM_PROMPT=`You are a helpful, respectful and honest assistant. Always answer as helpfully as possible, while being safe. Your answers should not include any harmful, unethical, racist, sexist, toxic, dangerous, or illegal content. Please ensure that your responses are socially unbiased and positive in nature.

If a question does not make any sense, or is not factually coherent, explain why instead of answering something not correct. If you don't know the answer to a question, please don't share false information.`;constructor(e,n){super(e,n),this.use_default_system_prompt=n.use_default_system_prompt??!1,this.legacy=n.legacy??!0,this.legacy||(this.normalizer=null,this.pre_tokenizer=new rf({replacement:ba,add_prefix_space:!0,prepend_scheme:"first"}))}_encode_text(e){if(e===null)return null;if(this.legacy||e.length===0)return super._encode_text(e);let n=super._encode_text(ba+e.replaceAll(ba," "));return n.length>1&&n[0]===ba&&this.special_tokens.includes(n[1])&&(n=n.slice(1)),n}get default_chat_template(){return super.default_chat_template.replaceAll("USE_DEFAULT_PROMPT",this.use_default_system_prompt?"true":"false").replaceAll("DEFAULT_SYSTEM_MESSAGE",this.DEFAULT_SYSTEM_PROMPT.replaceAll(`
`,"\\n").replaceAll("'","\\'"))}}class Tw extends of{}class Cw extends Se{}class Iw extends Se{}class Aw extends Se{}class Mw extends Se{}class Ow extends Se{}class zw extends Se{}class Rw extends Se{_default_chat_template=`{% if messages[0]['role'] == 'system' %}{{ raise_exception('System role not supported') }}{% endif %}{% for message in messages %}{% if (message['role'] == 'user') != (loop.index0 % 2 == 0) %}{{ raise_exception('Conversation roles must alternate user/assistant/user/assistant/...') }}{% endif %}{% if (message['role'] == 'assistant') %}{% set role = 'model' %}{% else %}{% set role = message['role'] %}{% endif %}{{ '<start_of_turn>' + role + '
' + message['content'] | trim + '<end_of_turn>
' }}{% endfor %}{% if add_generation_prompt %}{{'<start_of_turn>model
'}}{% endif %}`}class Bw extends Se{}function Rs(t,e,n,r){if(!("language_codes"in t)||!Array.isArray(t.language_codes))throw new Error("Tokenizer must have `language_codes` attribute set and it should be an array of language ids.");if(!("languageRegex"in t)||!(t.languageRegex instanceof RegExp))throw new Error("Tokenizer must have `languageRegex` attribute set and it should be a regular expression.");if(!("lang_to_token"in t)||typeof t.lang_to_token!="function")throw new Error("Tokenizer must have `lang_to_token` attribute set and it should be a function.");const a=r.src_lang,i=r.tgt_lang;if(!t.language_codes.includes(i))throw new Error(`Target language code "${i}" is not valid. Must be one of: {${t.language_codes.join(", ")}}`);if(a!==void 0){if(!t.language_codes.includes(a))throw new Error(`Source language code "${a}" is not valid. Must be one of: {${t.language_codes.join(", ")}}`);for(const s of t.post_processor.config.single)if("SpecialToken"in s&&t.languageRegex.test(s.SpecialToken.id)){s.SpecialToken.id=t.lang_to_token(a);break}}return r.forced_bos_token_id=t.model.convert_tokens_to_ids([t.lang_to_token(i)])[0],t._call(e,n)}class Pw extends Se{constructor(e,n){super(e,n),this.languageRegex=/^[a-z]{3}_[A-Z][a-z]{3}$/,this.language_codes=this.special_tokens.filter(r=>this.languageRegex.test(r)),this.lang_to_token=r=>r}_build_translation_inputs(e,n,r){return Rs(this,e,n,r)}}class Dw extends Se{constructor(e,n){super(e,n),this.languageRegex=/^__[a-z]{2,3}__$/,this.language_codes=this.special_tokens.filter(r=>this.languageRegex.test(r)).map(r=>r.slice(2,-2)),this.lang_to_token=r=>`__${r}__`}_build_translation_inputs(e,n,r){return Rs(this,e,n,r)}}const lf=[["en","english"],["zh","chinese"],["de","german"],["es","spanish"],["ru","russian"],["ko","korean"],["fr","french"],["ja","japanese"],["pt","portuguese"],["tr","turkish"],["pl","polish"],["ca","catalan"],["nl","dutch"],["ar","arabic"],["sv","swedish"],["it","italian"],["id","indonesian"],["hi","hindi"],["fi","finnish"],["vi","vietnamese"],["he","hebrew"],["uk","ukrainian"],["el","greek"],["ms","malay"],["cs","czech"],["ro","romanian"],["da","danish"],["hu","hungarian"],["ta","tamil"],["no","norwegian"],["th","thai"],["ur","urdu"],["hr","croatian"],["bg","bulgarian"],["lt","lithuanian"],["la","latin"],["mi","maori"],["ml","malayalam"],["cy","welsh"],["sk","slovak"],["te","telugu"],["fa","persian"],["lv","latvian"],["bn","bengali"],["sr","serbian"],["az","azerbaijani"],["sl","slovenian"],["kn","kannada"],["et","estonian"],["mk","macedonian"],["br","breton"],["eu","basque"],["is","icelandic"],["hy","armenian"],["ne","nepali"],["mn","mongolian"],["bs","bosnian"],["kk","kazakh"],["sq","albanian"],["sw","swahili"],["gl","galician"],["mr","marathi"],["pa","punjabi"],["si","sinhala"],["km","khmer"],["sn","shona"],["yo","yoruba"],["so","somali"],["af","afrikaans"],["oc","occitan"],["ka","georgian"],["be","belarusian"],["tg","tajik"],["sd","sindhi"],["gu","gujarati"],["am","amharic"],["yi","yiddish"],["lo","lao"],["uz","uzbek"],["fo","faroese"],["ht","haitian creole"],["ps","pashto"],["tk","turkmen"],["nn","nynorsk"],["mt","maltese"],["sa","sanskrit"],["lb","luxembourgish"],["my","myanmar"],["bo","tibetan"],["tl","tagalog"],["mg","malagasy"],["as","assamese"],["tt","tatar"],["haw","hawaiian"],["ln","lingala"],["ha","hausa"],["ba","bashkir"],["jw","javanese"],["su","sundanese"]],$a=new Map(lf),Nw=new Map([...lf.map(([t,e])=>[e,t]),["burmese","my"],["valencian","ca"],["flemish","nl"],["haitian","ht"],["letzeburgesch","lb"],["pushto","ps"],["panjabi","pa"],["moldavian","ro"],["moldovan","ro"],["sinhalese","si"],["castilian","es"]]);class Lw extends Se{_default_chat_template='{% for message in messages %}" "{{ message.content }}{{ eos_token }}" "{% endfor %}';_decode_asr(e,{return_timestamps:n=!1,return_language:r=!1,time_precision:a=null,force_full_sequences:i=!0}={}){if(a===null)throw Error("Must specify time_precision");let s=null;const o=n==="word";function l(){return{language:s,timestamp:[null,null],text:""}}const d=[];let p=l(),u=0;const f=this.model.convert_tokens_to_ids(["<|notimestamps|>"])[0]+1;let m=[],_=[],v=!1,$=null;const b=new Set(this.all_special_ids);for(const E of e){const I=E.tokens,M=o?E.token_timestamps:null;let F=null,L=f;if("stride"in E){const[A,q,te]=E.stride;if(u-=q,$=A-te,q&&(L=q/a+f),te)for(let K=I.length-1;K>=0;--K){const B=I[K];if(B>=f){if(F!==null&&(B-f)*a<$)break;F=B}}}let W=[],X=[];for(let A=0;A<I.length;++A){const q=I[A];if(b.has(q)){const te=this.decode([q]),K=$a.get(te.slice(2,-2));if(K!==void 0){if(s!==null&&K!==s&&!n){m.push(W);const B=this.findLongestCommonSequence(m)[0],U=this.decode(B);p.text=U,d.push(p),m=[],W=[],p=l()}s=p.language=K}}else if(q>=f){const te=(q-f)*a+u,K=pa(te,2);if(F!==null&&q>=F)v=!0;else if(v||m.length>0&&q<L)v=!1;else if(p.timestamp[0]===null)p.timestamp[0]=K;else if(K!==p.timestamp[0]){p.timestamp[1]=K,m.push(W),o&&_.push(X);const[B,U]=this.findLongestCommonSequence(m,_),G=this.decode(B);p.text=G,o&&(p.words=this.collateWordTimestamps(B,U,s)),d.push(p),m=[],W=[],_=[],X=[],p=l()}}else if(W.push(q),o){let te=pa(M[A]+u,2),K;A+1<M.length?K=pa(M[A+1]+u,2):K=null,X.push([te,K])}}if("stride"in E){const[A,q,te]=E.stride;u+=A-te}W.length>0?(m.push(W),o&&_.push(X)):m.every(A=>A.length===0)&&(p=l(),m=[],W=[],_=[],X=[])}if(m.length>0){if(i&&n)throw new Error("Whisper did not predict an ending timestamp, which can happen if audio is cut off in the middle of a word. Also make sure WhisperTimeStampLogitsProcessor was used during generation.");const[E,I]=this.findLongestCommonSequence(m,_),M=this.decode(E);p.text=M,o&&(p.words=this.collateWordTimestamps(E,I,s)),d.push(p)}let S=Object.create(null);const T=d.map(E=>E.text).join("");if(n||r){for(let E=0;E<d.length;++E){const I=d[E];n||delete I.timestamp,r||delete I.language}if(o){const E=[];for(const I of d)for(const M of I.words)E.push(M);S={chunks:E}}else S={chunks:d}}return[T,S]}findLongestCommonSequence(e,n=null){let r=e[0],a=r.length,i=[];const s=Array.isArray(n)&&n.length>0;let o=s?[]:null,l=s?n[0]:null;for(let d=1;d<e.length;++d){const p=e[d];let u=0,f=[a,a,0,0];const m=p.length;for(let E=1;E<a+m;++E){const I=E/1e4,M=Math.max(0,a-E),F=Math.min(a,a+m-E),L=r.slice(M,F),W=Math.max(0,E-a),X=Math.min(m,E),A=p.slice(W,X);if(L.length!==A.length)throw new Error("There is a bug within whisper `decode_asr` function, please report it. Dropping to prevent bad inference.");const q=L.filter((K,B)=>K===A[B]).length,te=q/E+I;q>1&&te>u&&(u=te,f=[M,F,W,X])}const[_,v,$,b]=f,S=Math.floor((v+_)/2),T=Math.floor((b+$)/2);i.push(...r.slice(0,S)),r=p.slice(T),a=r.length,s&&(o.push(...l.slice(0,S)),l=n[d].slice(T))}return i.push(...r),s?(o.push(...l),[i,o]):[i,[]]}collateWordTimestamps(e,n,r){const[a,i,s]=this.combineTokensIntoWords(e,r),o=[];for(let l=0;l<a.length;++l){const d=s[l];o.push({text:a[l],timestamp:[n[d.at(0)][0],n[d.at(-1)][1]]})}return o}combineTokensIntoWords(e,n,r=`"'“¡¿([{-`,a=`"'.。,，!！?？:：”)]}、`){n=n??"english";let i,s,o;return["chinese","japanese","thai","lao","myanmar"].includes(n)?[i,s,o]=this.splitTokensOnUnicode(e):[i,s,o]=this.splitTokensOnSpaces(e),this.mergePunctuations(i,s,o,r,a)}decode(e,n){let r;return n&&n.decode_with_timestamps?(e instanceof le&&(e=Zh(e)),r=this.decodeWithTimestamps(e,n)):r=super.decode(e,n),r}decodeWithTimestamps(e,n){const r=n?.time_precision??.02,a=Array.from(this.all_special_ids).at(-1)+1;let i=[[]];for(const s of e)if(s>=a){const o=pa((s-a)*r,2);i.push(`<|${o}|>`),i.push([])}else i[i.length-1].push(s);return i=i.map(s=>typeof s=="string"?s:super.decode(s,n)),i.join("")}splitTokensOnUnicode(e){const n=this.decode(e,{decode_with_timestamps:!0}),r="�",a=[],i=[],s=[];let o=[],l=[],d=0;for(let p=0;p<e.length;++p){const u=e[p];o.push(u),l.push(p);const f=this.decode(o,{decode_with_timestamps:!0});(!f.includes(r)||n[d+f.indexOf(r)]===r)&&(a.push(f),i.push(o),s.push(l),o=[],l=[],d+=f.length)}return[a,i,s]}splitTokensOnSpaces(e){const[n,r,a]=this.splitTokensOnUnicode(e),i=[],s=[],o=[],l=new RegExp(`^[${Ir}]$`,"gu");for(let d=0;d<n.length;++d){const p=n[d],u=r[d],f=a[d],m=u[0]>=this.model.tokens_to_ids.get("<|endoftext|>"),_=p.startsWith(" "),v=p.trim(),$=l.test(v);if(m||_||$||i.length===0)i.push(p),s.push(u),o.push(f);else{const b=i.length-1;i[b]+=p,s[b].push(...u),o[b].push(...f)}}return[i,s,o]}mergePunctuations(e,n,r,a,i){const s=structuredClone(e),o=structuredClone(n),l=structuredClone(r);let d=s.length-2,p=s.length-1;for(;d>=0;)s[d].startsWith(" ")&&a.includes(s[d].trim())?(s[p]=s[d]+s[p],o[p]=st(o[d],o[p]),l[p]=st(l[d],l[p]),s[d]="",o[d]=[],l[d]=[]):p=d,--d;for(d=0,p=1;p<s.length;)!s[d].endsWith(" ")&&i.includes(s[p])?(s[d]+=s[p],o[d]=st(o[d],o[p]),l[d]=st(l[d],l[p]),s[p]="",o[p]=[],l[p]=[]):d=p,++p;return[s.filter(u=>u),o.filter(u=>u.length>0),l.filter(u=>u.length>0)]}get_decoder_prompt_ids({language:e=null,task:n=null,no_timestamps:r=!0}={}){const a=[];if(e){e=e.toLowerCase();let i=Nw.get(e);if(i===void 0)if($a.has(e))i=e;else{const l=e.length===2?$a.keys():$a.values();throw new Error(`Language "${e}" is not supported. Must be one of: ${JSON.stringify(l)}`)}const s=this.model.tokens_to_ids.get(`<|${i}|>`);if(s===void 0)throw new Error(`Unable to find language "${i}" in model vocabulary. Please report this issue at https://github.com/xenova/transformers.js/issues/new/choose.`);a.push(s)}else a.push(null);if(n){if(n=n.toLowerCase(),n!=="transcribe"&&n!=="translate")throw new Error(`Task "${n}" is not supported. Must be one of: ["transcribe", "translate"]`);const i=this.model.tokens_to_ids.get(`<|${n}|>`);if(i===void 0)throw new Error(`Unable to find task "${n}" in model vocabulary. Please report this issue at https://github.com/xenova/transformers.js/issues/new/choose.`);a.push(i)}else a.push(null);if(r){const i=this.model.tokens_to_ids.get("<|notimestamps|>");if(i===void 0)throw new Error('Unable to find "<|notimestamps|>" in model vocabulary. Please report this issue at https://github.com/xenova/transformers.js/issues/new/choose.');a.push(i)}return a.map((i,s)=>[s+1,i]).filter(i=>i[1]!==null)}}class Fw extends Se{}class Uw extends Se{}class Ww extends Se{}class Vw extends Se{constructor(e,n){super(e,n),this.languageRegex=/^(>>\w+<<)\s*/g,this.supported_language_codes=this.model.vocab.filter(r=>this.languageRegex.test(r)),console.warn('WARNING: `MarianTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}_encode_text(e){if(e===null)return null;const[n,...r]=e.trim().split(this.languageRegex);if(r.length===0)return super._encode_text(n);if(r.length===2){const[a,i]=r;return this.supported_language_codes.includes(a)||console.warn(`Unsupported language code "${a}" detected, which may lead to unexpected behavior. Should be one of: ${JSON.stringify(this.supported_language_codes)}`),st([a],super._encode_text(i))}}}class Gw extends Se{}class uf extends Se{_default_chat_template="{% for message in messages %}{% if message['role'] == 'user' %}{{ ' ' }}{% endif %}{{ message['content'] }}{% if not loop.last %}{{ '  ' }}{% endif %}{% endfor %}{{ eos_token }}"}class Hw extends uf{}class qw extends Se{}class jw extends Se{}class Kw extends Se{constructor(e,n){super(e,n),this.decoder=new J_({})}}class Yw extends Se{}class a1{static TOKENIZER_CLASS_MAPPING={T5Tokenizer:$w,DistilBertTokenizer:ww,CamembertTokenizer:yw,DebertaTokenizer:hw,DebertaV2Tokenizer:fw,BertTokenizer:uw,HerbertTokenizer:mw,ConvBertTokenizer:gw,RoFormerTokenizer:_w,XLMTokenizer:vw,ElectraTokenizer:bw,MobileBertTokenizer:cw,SqueezeBertTokenizer:pw,AlbertTokenizer:dw,GPT2Tokenizer:af,BartTokenizer:xw,MBartTokenizer:sf,MBart50Tokenizer:Sw,RobertaTokenizer:Ew,WhisperTokenizer:Lw,CodeGenTokenizer:Fw,CLIPTokenizer:Uw,SiglipTokenizer:Ww,MarianTokenizer:Vw,BloomTokenizer:kw,NllbTokenizer:Pw,M2M100Tokenizer:Dw,LlamaTokenizer:of,CodeLlamaTokenizer:Tw,XLMRobertaTokenizer:Cw,MPNetTokenizer:Iw,FalconTokenizer:Aw,GPTNeoXTokenizer:Mw,EsmTokenizer:Ow,Wav2Vec2CTCTokenizer:Gw,BlenderbotTokenizer:uf,BlenderbotSmallTokenizer:Hw,SpeechT5Tokenizer:qw,NougatTokenizer:jw,VitsTokenizer:Kw,Qwen2Tokenizer:zw,GemmaTokenizer:Rw,Grok1Tokenizer:Bw,CohereTokenizer:Yw,PreTrainedTokenizer:Se};static async from_pretrained(e,{quantized:n=!0,progress_callback:r=null,config:a=null,cache_dir:i=null,local_files_only:s=!1,revision:o="main",legacy:l=null}={}){const[d,p]=await Qh(e,{quantized:n,progress_callback:r,config:a,cache_dir:i,local_files_only:s,revision:o,legacy:l}),u=p.tokenizer_class?.replace(/Fast$/,"")??"PreTrainedTokenizer";let f=this.TOKENIZER_CLASS_MAPPING[u];return f||(console.warn(`Unknown tokenizer class "${u}", attempting to construct from base class.`),f=Se),new f(d,p)}}async function Xw(t,e){return await Er(t,"config.json",!0,e)}class Qw{constructor(e){this.model_type=null,this.is_encoder_decoder=!1,Object.assign(this,e)}static async from_pretrained(e,{progress_callback:n=null,config:r=null,cache_dir:a=null,local_files_only:i=!1,revision:s="main"}={}){let o=r??await Xw(e,{progress_callback:n,config:r,cache_dir:a,local_files_only:i,revision:s});return new this(o)}}class Pn{static async from_pretrained(...e){return Qw.from_pretrained(...e)}}const xa=Object.freeze({cpu:"cpu",gpu:"gpu",wasm:"wasm",webgpu:"webgpu"});async function Zw(){try{return(await navigator.gpu.requestAdapter()).features.has("shader-f16")}catch{return!1}}const df=await Zw(),Rt=Object.freeze({fp32:"fp32",fp16:"fp16",q8:"q8",int8:"int8",uint8:"uint8"}),xd=df?Rt.fp16:Rt.fp32,Jw=Object.freeze({[xa.cpu]:Rt.q8,[xa.gpu]:xd,[xa.wasm]:Rt.q8,[xa.webgpu]:xd}),Sd=Object.freeze({[Rt.fp32]:"",[Rt.fp16]:"_fp16",[Rt.int8]:"_int8",[Rt.uint8]:"_uint8",[Rt.q8]:"_quantized"});class Ed extends qt{constructor(){super(),this.processors=[]}push(e){this.processors.push(e)}extend(e){this.processors.push(...e)}_call(e,n){for(let r of n)this.processors.forEach(a=>a(e,r))}[Symbol.iterator](){return this.processors.values()}}class Kt extends qt{_call(e,n){throw Error("`_call` should be implemented in a subclass")}}class ey extends Kt{constructor(e){super(),this.force_token_map=Object.fromEntries(e??[])}_call(e,n){let r=this.force_token_map[e.length];return Vm(r)&&(n.data.fill(-1/0),n.data[r]=0),n}}class ty extends Kt{constructor(e){super(),this.bos_token_id=e}_call(e,n){return e.length===1&&(n.data.fill(-1/0),n.data[this.bos_token_id]=0),n}}class ny extends Kt{constructor(e,n){super(),this.max_length=e,this.forced_eos_token_id=n}_call(e,n){}}class ry extends Kt{constructor(e,n){super(),this.begin_suppress_tokens=e,this.begin_index=n}_call(e,n){if(e.length===this.begin_index)for(let r of this.begin_suppress_tokens)n.data[r]=-1/0;return n}}class ay extends Kt{constructor(e){super(),this.eos_token_id=e.eos_token_id,this.no_timestamps_token_id=e.no_timestamps_token_id,this.timestamp_begin=this.no_timestamps_token_id+1,this.begin_index=(e.forced_decoder_ids||[]).length+2,e.forced_decoder_ids.slice(-1)[0][1]===this.no_timestamps_token_id&&(this.begin_index-=1),this.max_initial_timestamp_index=e.max_initial_timestamp_index}_call(e,n){const r=n.data;if(r[this.no_timestamps_token_id]=-1/0,e.length===this.begin_index-1)return r.fill(-1/0),r[this.timestamp_begin]=0,n;const a=e.slice(this.begin_index),i=a.length>=1&&a[a.length-1]>=this.timestamp_begin,s=a.length<2||a[a.length-2]>=this.timestamp_begin;if(i&&(s?r.subarray(this.timestamp_begin).fill(-1/0):r.subarray(0,this.eos_token_id).fill(-1/0)),e.length===this.begin_index&&this.max_initial_timestamp_index!==null){const p=this.timestamp_begin+this.max_initial_timestamp_index;r.subarray(p+1).fill(-1/0)}const o=ng(r),l=Math.log(o.subarray(this.timestamp_begin).map(Math.exp).reduce((p,u)=>p+u)),d=Wa(o.subarray(0,this.timestamp_begin))[0];return l>d&&r.subarray(0,this.timestamp_begin).fill(-1/0),n}}class iy extends Kt{constructor(e){super(),this.no_repeat_ngram_size=e}getNgrams(e){const n=e.length,r=[];for(let i=0;i<n+1-this.no_repeat_ngram_size;++i){const s=[];for(let o=0;o<this.no_repeat_ngram_size;++o)s.push(e[i+o]);r.push(s)}const a=new Map;for(const i of r){const s=i.slice(0,i.length-1),o=JSON.stringify(s),l=a.get(o)??[];l.push(i[i.length-1]),a.set(o,l)}return a}getGeneratedNgrams(e,n){const r=n.slice(n.length+1-this.no_repeat_ngram_size,n.length);return e.get(JSON.stringify(r))??[]}calcBannedNgramTokens(e){const n=[];if(e.length+1<this.no_repeat_ngram_size)return n;{const r=this.getNgrams(e);return this.getGeneratedNgrams(r,e)}}_call(e,n){const r=this.calcBannedNgramTokens(e);for(const a of r)n.data[a]=-1/0;return n}}class sy extends Kt{constructor(e){super(),this.penalty=e}_call(e,n){for(const r of e)n.data[r]<0?n.data[r]*=this.penalty:n.data[r]/=this.penalty;return n}}class oy extends Kt{constructor(e,n){super(),this.min_length=e,this.eos_token_id=Array.isArray(n)?n:[n]}_call(e,n){if(e.length<this.min_length)for(const r of this.eos_token_id)n.data[r]=-1/0;return n}}class ly extends Kt{constructor(e,n,r){super(),this.prompt_length_to_skip=e,this.min_new_tokens=n,this.eos_token_id=Array.isArray(r)?r:[r]}_call(e,n){if(e.length-this.prompt_length_to_skip<this.min_new_tokens)for(const a of this.eos_token_id)n.data[a]=-1/0;return n}}class uy extends Kt{constructor(e,n){super(),this.bad_words_ids=e,this.eos_token_id=Array.isArray(n)?n:[n]}_call(e,n){for(const r of this.bad_words_ids){let a=!0;for(let i=1;i<=r.length-1&&r.length<e.length;++i)if(r.at(-i-1)!==e.at(-i)){a=!1;break}a&&(n.data[r.at(-1)]=-1/0)}return n}}const dy=class{constructor(t={}){this.max_length=t.max_length??20,this.max_new_tokens=t.max_new_tokens??null,this.min_length=t.min_length??0,this.min_new_tokens=t.min_new_tokens??null,this.early_stopping=t.early_stopping??!1,this.max_time=t.max_time??null,this.do_sample=t.do_sample??!1,this.num_beams=t.num_beams??1,this.num_beam_groups=t.num_beam_groups??1,this.penalty_alpha=t.penalty_alpha??null,this.use_cache=t.use_cache??!0,this.temperature=t.temperature??1,this.top_k=t.top_k??50,this.top_p=t.top_p??1,this.typical_p=t.typical_p??1,this.epsilon_cutoff=t.epsilon_cutoff??0,this.eta_cutoff=t.eta_cutoff??0,this.diversity_penalty=t.diversity_penalty??0,this.repetition_penalty=t.repetition_penalty??1,this.encoder_repetition_penalty=t.encoder_repetition_penalty??1,this.length_penalty=t.length_penalty??1,this.no_repeat_ngram_size=t.no_repeat_ngram_size??0,this.bad_words_ids=t.bad_words_ids??null,this.force_words_ids=t.force_words_ids??null,this.renormalize_logits=t.renormalize_logits??!1,this.constraints=t.constraints??null,this.forced_bos_token_id=t.forced_bos_token_id??null,this.forced_eos_token_id=t.forced_eos_token_id??null,this.remove_invalid_values=t.remove_invalid_values??!1,this.exponential_decay_length_penalty=t.exponential_decay_length_penalty??null,this.suppress_tokens=t.suppress_tokens??null,this.begin_suppress_tokens=t.begin_suppress_tokens??null,this.forced_decoder_ids=t.forced_decoder_ids??null,this.num_return_sequences=t.num_return_sequences??1,this.output_attentions=t.output_attentions??!1,this.output_hidden_states=t.output_hidden_states??!1,this.output_scores=t.output_scores??!1,this.return_dict_in_generate=t.return_dict_in_generate??!1,this.pad_token_id=t.pad_token_id??null,this.bos_token_id=t.bos_token_id??null,this.eos_token_id=t.eos_token_id??null,this.encoder_no_repeat_ngram_size=t.encoder_no_repeat_ngram_size??0,this.decoder_start_token_id=t.decoder_start_token_id??null,this.generation_kwargs=t.generation_kwargs??{}}};class qa extends qt{constructor(e){super(),this.generation_config=e}_call(e,n=-1){return this.sample(e,n)}sample(e,n){throw Error("sample should be implemented in subclasses.")}getLogits(e,n){let r=e.dims.at(-1),a=e.data;if(n===-1)a=a.slice(-r);else{let i=n*r;a=a.slice(i,i+r)}return this.generation_config.temperature>0&&(a=a.map(i=>i/this.generation_config.temperature)),a}randomSelect(e){let n=e.reduce((a,i)=>a+i,0),r=Math.random()*n;for(let a=0;a<e.length;++a)if(r-=e[a],r<=0)return a;return 0}static getSampler(e){if(e.do_sample)return new py(e);if(e.num_beams>1)return new hy(e);if(e.num_return_sequences>1)throw Error(`num_return_sequences has to be 1 when doing greedy search, but is ${e.num_return_sequences}.`);return new cy(e)}}class cy extends qa{sample(e,n=-1){let r=this.getLogits(e,n);return[[Wa(r)[1],0]]}}class py extends qa{sample(e,n=-1){let r=e.dims.at(-1);this.generation_config.top_k>0&&(r=Math.min(this.generation_config.top_k,r));const a=this.getLogits(e,n),i=Ad(a,r),s=ls(i.map(o=>o[1]));return Array.from({length:this.generation_config.num_beams},()=>{const o=this.randomSelect(s);return[i[o][0],Math.log(s[o])]})}}class hy extends qa{sample(e,n=-1){let r=e.dims.at(-1);this.generation_config.top_k>0&&(r=Math.min(this.generation_config.top_k,r));const a=this.getLogits(e,n),i=Ad(a,r),s=ls(i.map(o=>o[1]));return Array.from({length:this.generation_config.num_beams},(o,l)=>[i[l][0],Math.log(s[l])])}}const Ee={EncoderOnly:0,EncoderDecoder:1,Seq2Seq:2,Vision2Seq:3,DecoderOnly:4,MaskGeneration:5},Fa=new Map,cf=new Map,Sr=new Map;async function ln(t,e,n){const r=R0(n.device),a=n.dtype??Jw[r[0]];if(Sd.hasOwnProperty(a)){if(a===Rt.fp16&&!df)throw new Error("The device does not support fp16.")}else throw new Error(`Invalid dtype: ${a}. Should be one of: ${Object.keys(Rt).join(", ")}`);const i=Sd[a];let s=e;s=`onnx/${e}${i}.onnx`;const o=await Gi(t,s,!0,n),l=n.session_options??{};if(l.executionProviders??=r,l.externalData!==void 0)for(let d=0;d<l.externalData.length;++d){const p=l.externalData[d];if(typeof p.data=="string"){const u=await Gi(t,p.data,!0,n);p.data=u}}return await B0(o,l)}function fy(t,e){const n=Object.create(null),r=[];for(const s of t.inputNames){const o=e[s];if(!(o instanceof le)){r.push(s);continue}n[s]=P0()?o.clone():o}if(r.length>0)throw new Error(`An error occurred during model execution: "Missing the following inputs: ${r.join(", ")}.`);const a=Object.keys(e).length,i=t.inputNames.length;if(a>i){let s=Object.keys(e).filter(o=>!t.inputNames.includes(o));console.warn(`WARNING: Too many inputs were provided (${a} > ${i}). The following inputs will be ignored: "${s.join(", ")}".`)}return n}async function Fn(t,e){const n=fy(t,e);try{const r=Object.fromEntries(Object.entries(n).map(([i,s])=>[i,s.ort_tensor]));let a=await t.run(r);a=pf(a);for(const[i,s]of Object.entries(n))i.startsWith("past_key_values")&&s.dispose();return a}catch(r){throw console.error(`An error occurred during model execution: "${r}".`),console.error("Inputs given to model:",n),r}}function pf(t){for(let e in t)Kh(t[e])?t[e]=new le(t[e]):typeof t[e]=="object"&&pf(t[e]);return t}function my(t){if(t instanceof le)return t;if(t.length===0)throw Error("items must be non-empty");if(Array.isArray(t[0])){if(t.some(e=>e.length!==t[0].length))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=True' and/or 'truncation=True' to have batched tensors with the same length.");return new le("int64",BigInt64Array.from(t.flat().map(e=>BigInt(e))),[t.length,t[0].length])}else return new le("int64",BigInt64Array.from(t.map(e=>BigInt(e))),[1,t.length])}function Bs(t,e){let n=t.config.pad_token_id??null,r=t.config.eos_token_id??null;Td(r)&&(r=[r]);let a=e.indexOf(n)!==-1,i=r===null||!r.includes(n);if(a&&i){let s=BigInt64Array.from(e.data.map(o=>o!=n));return new le("int64",s,e.dims)}else return G0(e)}function hf(t,e,n){if(!t.inputNames.includes("position_ids"))return;const r=new BigInt64Array(e.attention_mask.data.length);for(let a=0;a<e.attention_mask.dims[0];++a){let i=a*e.attention_mask.dims[1],s=BigInt(0);for(let o=0;o<e.attention_mask.dims[1];++o){const l=i+o;e.attention_mask.data[l]===0n?r[l]=BigInt(1):(r[l]=s,s+=e.attention_mask.data[l])}}e.position_ids=new le("int64",r,e.attention_mask.dims),n&&(e.position_ids=e.position_ids.slice(null,-1).unsqueeze_(-1))}function Ps(t){return new le("bool",[t],[1])}async function gy(t,e){let{encoder_outputs:n,past_key_values:r}=e;n||(n=(await Ar(t,e)).last_hidden_state);let a={input_ids:e.decoder_input_ids,encoder_hidden_states:n};const i=!!r;t.decoder_merged_session.inputNames.includes("use_cache_branch")&&(a.use_cache_branch=Ps(i)),t.decoder_merged_session.inputNames.includes("encoder_attention_mask")&&(a.encoder_attention_mask=e.attention_mask),hf(t.decoder_merged_session,a,i),t.addPastKeyValues(a,r);const s=await Fn(t.decoder_merged_session,a);let o=s.logits;r=t.getPastKeyValues(s,r);const l=t.getAttentions(s);return new W$({logits:o,past_key_values:r,encoder_outputs:n,...l})}function _y(t,e,n,r){let a=[],i=0;const s=t.requires_attention_mask??!0;let o=n.decoder_input_ids??n.decoder_start_token_id??n.bos_token_id??n.eos_token_id;o instanceof le?o=o.tolist().flat():Array.isArray(o)||(o=[o]);for(let l of e){l.dims=[1,...l.dims];let d={inputs:l,encoder_outputs:null,prev_model_outputs:null,output_token_ids:o,done:!1,score:0,id:i++};s&&(d.attention_mask=Bs(t,l)),a.push(d)}return a}async function wy(t,e){const n=t.main_input_name;let r=e.output_token_ids;e.prev_model_outputs&&(r=r.slice(-1));let a={[n]:e.inputs,decoder_input_ids:my(r),encoder_outputs:e.encoder_outputs,past_key_values:e.prev_model_outputs?.past_key_values};e.attention_mask&&(a.attention_mask=e.attention_mask);let i=await t.forward(a);return e.prev_model_outputs=i,e.encoder_outputs=i.encoder_outputs,i}function yy(t,e){t.output_token_ids=[...t.output_token_ids,e]}async function Ar(t,e){const n=Object.create(null);for(const r of t.session.inputNames)n[r]=e[r];return t.session.inputNames.includes("token_type_ids")&&!n.token_type_ids&&(n.token_type_ids=new le("int64",new BigInt64Array(n.input_ids.data.length),n.input_ids.dims)),await Fn(t.session,n)}async function vy(t,e){let{input_ids:n,past_key_values:r,attention_mask:a}=e,i={input_ids:n,attention_mask:a??Bs(t,n)};const s=!!r;t.session.inputNames.includes("use_cache_branch")&&(i.use_cache_branch=Ps(s)),hf(t.session,i,s),t.addPastKeyValues(i,r);let o=await Fn(t.session,i),l=o.logits;return r=t.getPastKeyValues(o,r),{logits:l,past_key_values:r}}function by(t,e,n,r,a){let i=[],s=0;for(let o of e){let l=o.tolist().map(Number);o.dims=[1,...o.dims];let d;a?(d=a[s],d.dims=[1,...d.dims]):d=Bs(t,o);let p={input:o,model_input_ids:o,attention_mask:d,prev_model_outputs:null,output_token_ids:l,num_output_tokens:r,done:!1,score:0,id:s++};i.push(p)}return i}async function $y(t,e){let n=new BigInt64Array(e.output_token_ids.length).fill(1n),r={input_ids:e.model_input_ids,attention_mask:new le("int64",n,[1,n.length]),past_key_values:e.prev_model_outputs?.past_key_values},a=await t.forward(r);return e.prev_model_outputs=a,a}function xy(t,e){t.output_token_ids=[...t.output_token_ids,e],t.model_input_ids=new le("int64",[BigInt(e)],[1,1])}class Q extends qt{main_input_name="input_ids";constructor(e,n){super(),this.config=e,this.session=n;const r=Sr.get(this.constructor),a=Fa.get(r);this.can_generate=!1,this._runBeam=null,this._getStartBeams=null,this._updateBeam=null,this._forward=null,a===Ee.DecoderOnly?(this.can_generate=!0,this._runBeam=$y,this._getStartBeams=by,this._updateBeam=xy,this._forward=vy):a===Ee.Seq2Seq||a===Ee.Vision2Seq?(this.can_generate=!0,this._runBeam=wy,this._getStartBeams=_y,this._updateBeam=yy,this._forward=gy):a===Ee.EncoderDecoder?this._forward=Ar:this._forward=Ar}async dispose(){const e=[];for(let n of Object.keys(this)){let r=this[n];r?.handler?.dispose!==void 0&&e.push(r.handler.dispose())}return await Promise.all(e)}static async from_pretrained(e,{progress_callback:n=null,config:r=null,cache_dir:a=null,local_files_only:i=!1,revision:s="main",model_file_name:o=null,device:l=null,dtype:d=null,session_options:p={}}={}){let u={progress_callback:n,config:r,cache_dir:a,local_files_only:i,revision:s,model_file_name:o,device:l,dtype:d,session_options:p};const f=Sr.get(this),m=Fa.get(f);let _;return m===Ee.DecoderOnly?_=await Promise.all([Pn.from_pretrained(e,u),ln(e,u.model_file_name??"decoder_model_merged",u),Er(e,"generation_config.json",!1,u)]):m===Ee.Seq2Seq||m===Ee.Vision2Seq?_=await Promise.all([Pn.from_pretrained(e,u),ln(e,"encoder_model",u),ln(e,"decoder_model_merged",u),Er(e,"generation_config.json",!1,u)]):m===Ee.MaskGeneration?_=await Promise.all([Pn.from_pretrained(e,u),ln(e,"vision_encoder",u),ln(e,"prompt_encoder_mask_decoder",u)]):m===Ee.EncoderDecoder?_=await Promise.all([Pn.from_pretrained(e,u),ln(e,"encoder_model",u),ln(e,"decoder_model_merged",u)]):(m!==Ee.EncoderOnly&&console.warn(`Model type for '${f??r?.model_type}' not found, assuming encoder-only architecture. Please report this at https://github.com/xenova/transformers.js/issues/new/choose.`),_=await Promise.all([Pn.from_pretrained(e,u),ln(e,u.model_file_name??"model",u)])),new this(..._)}async _call(e){return await this.forward(e)}async forward(e){return await this._forward(this,e)}_get_logits_processor(e,n,r=null){const a=new Ed;if(e.repetition_penalty!==null&&e.repetition_penalty!==1&&a.push(new sy(e.repetition_penalty)),e.no_repeat_ngram_size!==null&&e.no_repeat_ngram_size>0&&a.push(new iy(e.no_repeat_ngram_size)),e.bad_words_ids!==null&&a.push(new uy(e.bad_words_ids,e.eos_token_id)),e.min_length!==null&&e.eos_token_id!==null&&e.min_length>0&&a.push(new oy(e.min_length,e.eos_token_id)),e.min_new_tokens!==null&&e.eos_token_id!==null&&e.min_new_tokens>0&&a.push(new ly(n,e.min_new_tokens,e.eos_token_id)),e.forced_bos_token_id!==null&&a.push(new ty(e.forced_bos_token_id)),e.forced_eos_token_id!==null&&a.push(new ny(e.max_length,e.forced_eos_token_id)),e.begin_suppress_tokens!==null){let i=n>1||e.forced_bos_token_id===null?n:n+1;e.forced_decoder_ids!==null&&(i+=e.forced_decoder_ids[e.forced_decoder_ids.length-1][0]),a.push(new ry(e.begin_suppress_tokens,i))}return e.forced_decoder_ids!==null&&a.push(new ey(e.forced_decoder_ids)),r!==null&&a.extend(r),a}_get_generation_config(e){let n=new dy(this.config);return"generation_config"in this&&Object.assign(n,this.generation_config),e!==null&&Object.assign(n,e),n}async generate(e,n=null,r=null,{inputs_attention_mask:a=null}={}){if(!this.can_generate){let $=`The current model class (${Sr.get(this.constructor)}) is not compatible with \`.generate()\`, as it doesn't have a language model head.`;const b=this.config.model_type,S=ei.get(b)??Vs.get(b)??Ws.get(b)??Gs.get(b);throw S&&($+=` Please use the following class instead: '${S[0]}'`),Error($)}if(!(e instanceof le)&&!Wm(e)&&!Array.isArray(e))throw Error(`\`inputs\` must be a Tensor, TypedArray, or Array, but is "${e.constructor.name}".`);let i;if(this.config.is_encoder_decoder)i=0;else if(i=e instanceof le?e.dims.at(-1):e.length,i===0)throw Error("Must supply a non-empty array of input token ids.");n=this._get_generation_config(n),r=r??new Ed,r=this._get_logits_processor(n,i,r);let s=n.eos_token_id;s!==null&&!Array.isArray(s)&&(s=[s]);let o=1;const l=o+(n.max_new_tokens??1/0),d=Number.isInteger(n.max_length)&&(n.max_new_tokens??null)===null;let p=qa.getSampler(n),u=this.getStartBeams(e,n,o,a);for(;u.some(v=>!v.done)&&o<l;){let v=[];for(let $ of u){if($.done){v.push($);continue}if(d&&$.output_token_ids.length>=n.max_length){$.done=!0,v.push($);continue}let b=await this.runBeam($);n.output_attentions&&this.addAttentionsToBeam($,b),n.output_scores;let S=b.logits.slice(null,-1,null);r($.output_token_ids,S);let T=p(S);for(let[E,I]of T){let M={...$};this.updateBeam(M,E),M.score+=I,s&&s.includes(E)&&(M.done=!0),v.push(M)}}++o,v=this.groupBeams(v).map($=>$.sort((b,S)=>S.score-b.score).slice(0,n.num_beams)),u=v.flat(),n.callback_function&&n.callback_function(u)}const f=this.groupBeams(u),m=v=>f.map($=>n.num_return_sequences>1?$.slice(0,n.num_return_sequences).map(b=>b[v]):[$[0][v]]).flat(),_=m("output_token_ids");if(n.return_dict_in_generate){const v=m("decoder_attentions"),$=m("cross_attentions");return{sequences:_,decoder_attentions:v,cross_attentions:$}}else return _}addAttentionsToBeam(e,n){if(this.config.is_encoder_decoder){if(!n.cross_attentions||n.cross_attentions.length===0)throw Error("`output_attentions` is true, but the model did not produce cross-attentions. This is most likely because the model was not exported with `output_attentions=True`.");e.cross_attentions||(e.cross_attentions=[]),e.cross_attentions.push(n.cross_attentions)}if(!n.decoder_attentions||n.decoder_attentions.length===0)throw Error("`output_attentions` is true, but the model did not produce decoder-attentions. This is most likely because the model was not exported with `output_attentions=True`.");e.decoder_attentions||(e.decoder_attentions=[]),e.decoder_attentions.push(n.decoder_attentions)}groupBeams(e){const n=Object.create(null);for(const r of e)n[r.id]===void 0?n[r.id]=[r]:n[r.id].push(r);return Object.values(n)}getPastKeyValues(e,n){const r=Object.create(null);for(const a in e)if(a.startsWith("present")){let i=a.replace("present","past_key_values");n&&a.includes("encoder")?r[i]=n[i]:r[i]=e[a]}return r}getAttentions(e){const n=Object.create(null);for(const r of["cross_attentions","decoder_attentions"]){const a=[];for(const i in e)if(i.startsWith(r)){const s=i.split(".").pop();a[s]=e[i]}n[r]=a}return n}addPastKeyValues(e,n){if(n)Object.assign(e,n);else{const a=this.config.precision||"float32",i=a==="float16"?new Uint16Array:[];if(this.config.is_encoder_decoder&&(this.add_encoder_pkv??!0)){let s=[1,this.num_encoder_heads,0,this.encoder_dim_kv],o=[1,this.num_decoder_heads,0,this.decoder_dim_kv];for(let l=0;l<this.num_decoder_layers;++l)e[`past_key_values.${l}.encoder.key`]=new le(a,i,s),e[`past_key_values.${l}.encoder.value`]=new le(a,i,s),e[`past_key_values.${l}.decoder.key`]=new le(a,i,o),e[`past_key_values.${l}.decoder.value`]=new le(a,i,o)}else if(this.config.model_type==="falcon"){let s=[1*this.num_heads,0,this.dim_kv];for(let o=0;o<this.num_layers;++o)e[`past_key_values.${o}.key`]=new le(a,i,s),e[`past_key_values.${o}.value`]=new le(a,i,s)}else if(this.config.multi_query){let s=[1*this.num_heads,0,2*this.dim_kv];for(let o=0;o<this.num_layers;++o)e[`past_key_values.${o}.key_value`]=new le(a,i,s)}else if(this.config.model_type==="bloom"){let s=[1*this.num_heads,this.dim_kv,0],o=[1*this.num_heads,0,this.dim_kv];for(let l=0;l<this.num_layers;++l)e[`past_key_values.${l}.key`]=new le(a,i,s),e[`past_key_values.${l}.value`]=new le(a,i,o)}else{let s=[1,this.num_heads,0,this.dim_kv];for(let o=0;o<this.num_layers;++o)e[`past_key_values.${o}.key`]=new le(a,i,s),e[`past_key_values.${o}.value`]=new le(a,i,s)}}}getStartBeams(e,n,r,a){return this._getStartBeams(this,e,n,r,a)}async runBeam(e){return await this._runBeam(this,e)}updateBeam(e,n){return this._updateBeam(e,n)}}class yt{}class Br extends Q{}class Sy extends Br{}class Ey extends Br{async _call(e){return new dt(await super._call(e))}}class ky extends Br{async _call(e){return new Me(await super._call(e))}}class Ty extends Br{async _call(e){return new ut(await super._call(e))}}class Cy extends Br{async _call(e){return new pt(await super._call(e))}}class Iy extends Q{}class Ay extends Iy{}class Pr extends Q{}class My extends Pr{}class Oy extends Pr{async _call(e){return new dt(await super._call(e))}}class zy extends Pr{async _call(e){return new Me(await super._call(e))}}class Ry extends Pr{async _call(e){return new ut(await super._call(e))}}class By extends Pr{async _call(e){return new pt(await super._call(e))}}class Dr extends Q{}class Py extends Dr{}class Dy extends Dr{async _call(e){return new dt(await super._call(e))}}class Ny extends Dr{async _call(e){return new Me(await super._call(e))}}class Ly extends Dr{async _call(e){return new ut(await super._call(e))}}class Fy extends Dr{async _call(e){return new pt(await super._call(e))}}class Nr extends Q{}class Uy extends Nr{}class Wy extends Nr{async _call(e){return new dt(await super._call(e))}}class Vy extends Nr{async _call(e){return new Me(await super._call(e))}}class Gy extends Nr{async _call(e){return new ut(await super._call(e))}}class Hy extends Nr{async _call(e){return new pt(await super._call(e))}}class Lr extends Q{}class qy extends Lr{}class jy extends Lr{async _call(e){return new dt(await super._call(e))}}class Ky extends Lr{async _call(e){return new Me(await super._call(e))}}class Yy extends Lr{async _call(e){return new ut(await super._call(e))}}class Xy extends Lr{async _call(e){return new pt(await super._call(e))}}class Fr extends Q{}class Qy extends Fr{}class Zy extends Fr{async _call(e){return new dt(await super._call(e))}}class Jy extends Fr{async _call(e){return new Me(await super._call(e))}}class ev extends Fr{async _call(e){return new ut(await super._call(e))}}class tv extends Fr{async _call(e){return new pt(await super._call(e))}}class Ur extends Q{}class nv extends Ur{}class rv extends Ur{async _call(e){return new dt(await super._call(e))}}class av extends Ur{async _call(e){return new Me(await super._call(e))}}class iv extends Ur{async _call(e){return new ut(await super._call(e))}}class sv extends Ur{async _call(e){return new pt(await super._call(e))}}class Wr extends Q{}class ov extends Wr{}class lv extends Wr{async _call(e){return new Me(await super._call(e))}}class uv extends Wr{async _call(e){return new ut(await super._call(e))}}class dv extends Wr{async _call(e){return new pt(await super._call(e))}}class cv extends Wr{async _call(e){return new dt(await super._call(e))}}class ja extends Q{}class pv extends ja{}class hv extends ja{async _call(e){return new dt(await super._call(e))}}class fv extends ja{async _call(e){return new Me(await super._call(e))}}class mv extends ja{async _call(e){return new ut(await super._call(e))}}class Ka extends Q{}class gv extends Ka{}class _v extends Ka{async _call(e){return new dt(await super._call(e))}}class wv extends Ka{async _call(e){return new Me(await super._call(e))}}class yv extends Ka{async _call(e){return new pt(await super._call(e))}}class Vr extends Q{}class vv extends Vr{}class bv extends Vr{async _call(e){return new dt(await super._call(e))}}class $v extends Vr{async _call(e){return new Me(await super._call(e))}}class xv extends Vr{async _call(e){return new ut(await super._call(e))}}class Sv extends Vr{async _call(e){return new pt(await super._call(e))}}class Ya extends Q{}class Ev extends Ya{}class kv extends Ya{async _call(e){return new dt(await super._call(e))}}class Tv extends Ya{async _call(e){return new Me(await super._call(e))}}class Cv extends Ya{async _call(e){return new pt(await super._call(e))}}class Xa extends Q{}class Iv extends Xa{}class Av extends Xa{async _call(e){return new Me(await super._call(e))}}class Mv extends Xa{async _call(e){return new pt(await super._call(e))}}class Ov extends Xa{async _call(e){return new dt(await super._call(e))}}class ff extends Q{}class zv extends ff{}class Rv extends ff{constructor(e,n,r,a){super(e,n),this.decoder_merged_session=r,this.generation_config=a,this.num_decoder_layers=this.config.num_decoder_layers,this.num_decoder_heads=this.config.num_heads,this.decoder_dim_kv=this.config.d_kv,this.num_encoder_layers=this.config.num_layers,this.num_encoder_heads=this.config.num_heads,this.encoder_dim_kv=this.config.d_kv}}class mf extends Q{}class Bv extends mf{}class Pv extends mf{constructor(e,n,r,a){super(e,n),this.decoder_merged_session=r,this.generation_config=a,this.num_decoder_layers=this.config.num_decoder_layers,this.num_decoder_heads=this.config.num_heads,this.decoder_dim_kv=this.config.d_kv,this.num_encoder_layers=this.config.num_layers,this.num_encoder_heads=this.config.num_heads,this.encoder_dim_kv=this.config.d_kv}}class gf extends Q{}class Dv extends gf{}class Nv extends gf{constructor(e,n,r,a){super(e,n),this.decoder_merged_session=r,this.generation_config=a,this.num_decoder_layers=this.config.num_decoder_layers,this.num_decoder_heads=this.config.num_heads,this.decoder_dim_kv=this.config.d_kv,this.num_encoder_layers=this.config.num_layers,this.num_encoder_heads=this.config.num_heads,this.encoder_dim_kv=this.config.d_kv}}class Ds extends Q{}class Lv extends Ds{}class Fv extends Ds{constructor(e,n,r,a){super(e,n),this.decoder_merged_session=r,this.generation_config=a,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class Uv extends Ds{async _call(e){return new Me(await super._call(e))}}class Qa extends Q{}class Wv extends Qa{}class Vv extends Qa{constructor(e,n,r,a){super(e,n),this.decoder_merged_session=r,this.generation_config=a,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class Gv extends Qa{async _call(e){return new Me(await super._call(e))}}class Hv extends Qa{constructor(e,n,r){super(e,n),this.generation_config=r,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class _f extends Q{}class qv extends _f{}class jv extends _f{constructor(e,n,r,a){super(e,n),this.decoder_merged_session=r,this.generation_config=a,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class wf extends Q{}class Kv extends wf{}class Yv extends wf{constructor(e,n,r,a){super(e,n),this.decoder_merged_session=r,this.generation_config=a,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class Gr extends Q{}class Xv extends Gr{}class Qv extends Gr{async _call(e){return new dt(await super._call(e))}}class Zv extends Gr{async _call(e){return new Me(await super._call(e))}}class Jv extends Gr{async _call(e){return new ut(await super._call(e))}}class eb extends Gr{async _call(e){return new pt(await super._call(e))}}class Hr extends Q{}class tb extends Hr{}class nb extends Hr{async _call(e){return new dt(await super._call(e))}}class rb extends Hr{async _call(e){return new Me(await super._call(e))}}class ab extends Hr{async _call(e){return new ut(await super._call(e))}}class ib extends Hr{async _call(e){return new pt(await super._call(e))}}class qr extends Q{}class sb extends qr{}class ob extends qr{async _call(e){return new dt(await super._call(e))}}class lb extends qr{async _call(e){return new Me(await super._call(e))}}class ub extends qr{async _call(e){return new ut(await super._call(e))}}class db extends qr{async _call(e){return new pt(await super._call(e))}}class yf extends Q{}class cb extends yf{}class pb extends yf{}class vf extends Q{}class hb extends vf{}class fb extends vf{requires_attention_mask=!1;main_input_name="input_features";constructor(e,n,r,a){super(e,n),this.decoder_merged_session=r,this.generation_config=a,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}async generate(e,n=null,r=null){if(n=this._get_generation_config(n),n.return_timestamps??=!1,n.return_timestamps&&(r=[new ay(n)]),n.return_token_timestamps&&(n.output_attentions=!0,n.return_dict_in_generate=!0,n.task==="translate"&&console.warn("Token-level timestamps may not be reliable for task 'translate'."),!n.alignment_heads))throw new Error("Model generation config has no `alignment_heads`, token-level timestamps not available. See https://gist.github.com/hollance/42e32852f24243b748ae6bc1f985b13a on how to add this property to the generation config.");const a=await super.generate(e,n,r);return n.return_token_timestamps&&n.alignment_heads&&(a.token_timestamps=this._extract_token_timestamps(a,n.alignment_heads,n.num_frames)),a}_extract_token_timestamps(e,n,r=null,a=.02){if(!e.cross_attentions)throw new Error("Model outputs must contain cross attentions to extract timestamps. This is most likely because the model was not exported with `output_attentions=True`.");let i=this.config.median_filter_width;i===void 0&&(console.warn("Model config has no `median_filter_width`, using default value of 7."),i=7);const s=e.cross_attentions.map(d=>{let p=Array.from({length:this.config.decoder_layers},($,b)=>Ms(d.map(S=>S[b]),2)),u=L0(n.map(([$,b])=>r?p[$].slice(null,b,null,[0,r]):p[$].slice(null,b)));u=u.transpose(1,0,2,3);let[f,m]=F0(u,-2,0,!0),_=u.clone();for(let $=0;$<_.dims[0];++$){let b=_[$];for(let S=0;S<b.dims[0];++S){let T=b[S];const E=f[$][S][0],I=m[$][S][0];for(let M=0;M<T.dims[0];++M){let F=T[M];for(let L=0;L<F.data.length;++L)F.data[L]=(F.data[L]-I.data[L])/E.data[L];F.data.set(ig(F.data,i))}}}return Yh(_,1)}),o=[e.sequences.length,e.sequences[0].length],l=new le("float32",new Float32Array(o[0]*o[1]),o);for(let d=0;d<o[0];++d){const p=s[d].neg().squeeze_(0);let[u,f]=U0(p),m=Array.from({length:u.length-1},($,b)=>u[b+1]-u[b]),_=st([1],m).map($=>!!$),v=[];for(let $=0;$<_.length;++$)_[$]&&v.push(f[$]*a);l[d].data.set(v,1)}return l}}class bf extends Q{main_input_name="pixel_values";constructor(e,n,r,a){super(e,n),this.decoder_merged_session=r,this.generation_config=a;const i=this.config.encoder,s=this.config.decoder,o=i.model_type;(lm.get(o)??um.get(o))||console.warn(`Model type for encoder '${o}' not found, assuming encoder-only architecture. Please report this at https://github.com/xenova/transformers.js/issues/new/choose.`);const d=ei.get(s.model_type);if(!d)throw new Error(`Unable to construct \`VisionEncoderDecoder\` due to unsupported decoder: "${this.config.decoder.model_type}"`);const p=d[1],u=new p(s,r,a);this.add_encoder_pkv="num_decoder_layers"in u,this.add_encoder_pkv?(this.num_decoder_layers=u.num_decoder_layers,this.num_decoder_heads=u.num_decoder_heads,this.decoder_dim_kv=u.decoder_dim_kv,this.num_encoder_layers=u.num_encoder_layers,this.num_encoder_heads=u.num_encoder_heads,this.encoder_dim_kv=u.encoder_dim_kv):(this.num_layers=u.num_layers,this.num_heads=u.num_heads,this.dim_kv=u.dim_kv)}}class Za extends Q{}class mb extends Za{}class gb extends Za{static async from_pretrained(e,n={}){return n.model_file_name??="text_model",super.from_pretrained(e,n)}}class _b extends Za{static async from_pretrained(e,n={}){return n.model_file_name??="vision_model",super.from_pretrained(e,n)}}class $f extends Q{}class wb extends $f{}class yb extends $f{static async from_pretrained(e,n={}){return n.model_file_name??="text_model",super.from_pretrained(e,n)}}class vb extends Za{static async from_pretrained(e,n={}){return n.model_file_name??="vision_model",super.from_pretrained(e,n)}}class bb extends Q{}class $b extends bb{}class xf extends Q{}class xb extends xf{}class Sb extends xf{}class Sf extends Q{constructor(e,n,r){super(e,n),this.generation_config=r,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.n_embd/this.num_heads}}class Eb extends Sf{}class kb extends Sf{}class Ef extends Q{constructor(e,n,r){super(e,n),this.generation_config=r,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_heads,this.num_layers=this.config.num_layers,this.dim_kv=this.config.hidden_size/this.num_heads}}class Tb extends Ef{}class Cb extends Ef{}class kf extends Q{constructor(e,n,r){super(e,n),this.generation_config=r,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.num_heads}}class Ib extends kf{}class Ab extends kf{}class Tf extends Q{constructor(e,n,r){super(e,n),this.generation_config=r,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.n_embd/this.num_heads}}class Mb extends Tf{}class Ob extends Tf{}class Cf extends Q{constructor(e,n,r){super(e,n),this.generation_config=r,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.n_embd/this.num_heads}}class zb extends Cf{}class Rb extends Cf{}class If extends Q{constructor(e,n,r){super(e,n),this.generation_config=r,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.n_embd/this.num_heads}}class Bb extends If{}class Pb extends If{}class Af extends Q{constructor(e,n,r){super(e,n),this.generation_config=r,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_key_value_heads??this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.config.num_attention_heads}}class Db extends Af{}class Nb extends Af{}class Mf extends Q{constructor(e,n,r){super(e,n),this.generation_config=r,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_key_value_heads??this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.config.num_attention_heads}}class Lb extends Mf{}class Fb extends Mf{}class Of extends Q{constructor(e,n,r){super(e,n),this.generation_config=r,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.num_heads}}class Ub extends Of{}class Wb extends Of{}class zf extends Q{constructor(e,n,r){super(e,n),this.generation_config=r,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.hidden_size/this.num_heads}}class Vb extends zf{}class Gb extends zf{}class Rf extends Q{constructor(e,n,r){super(e,n),this.generation_config=r,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_heads,this.num_layers=this.config.n_layers,this.dim_kv=this.config.d_model/this.num_heads}}class Hb extends Rf{}class qb extends Rf{}class Bf extends Q{constructor(e,n,r){super(e,n),this.generation_config=r,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.num_heads}}class jb extends Bf{}class Kb extends Bf{}class Pf extends Q{}class Yb extends Pf{}class Xb extends Pf{async _call(e){return new Me(await super._call(e))}}class Qb extends Q{}class Zb extends Qb{async _call(e){return new G$(await super._call(e))}}class Df extends Q{}class Jb extends Df{}class e2 extends Df{async _call(e){return new Me(await super._call(e))}}class Nf extends Q{}class t2 extends Nf{}class n2 extends Nf{}class Lf extends Q{}class r2 extends Lf{}class a2 extends Lf{}class Ff extends Q{}class i2 extends Ff{}class s2 extends Ff{async _call(e){return new Me(await super._call(e))}}class Ns extends Q{}class o2 extends Ns{}class l2 extends Ns{async _call(e){return new Uf(await super._call(e))}}class u2 extends Ns{async _call(e){return new d2(await super._call(e))}}class Uf extends yt{constructor({logits:e,pred_boxes:n}){super(),this.logits=e,this.pred_boxes=n}}class d2 extends yt{constructor({logits:e,pred_boxes:n,pred_masks:r}){super(),this.logits=e,this.pred_boxes=n,this.pred_masks=r}}class Wf extends Q{}class c2 extends Wf{}class p2 extends Wf{async _call(e){return new h2(await super._call(e))}}class h2 extends Uf{}class Vf extends Q{}class f2 extends Vf{}class m2 extends Vf{async _call(e){return new Me(await super._call(e))}}class Gf extends Q{}class g2 extends Gf{}class _2 extends Gf{async _call(e){return new Me(await super._call(e))}}class Hf extends Q{}class w2 extends Hf{}class y2 extends Hf{async _call(e){return new Me(await super._call(e))}}class qf extends Q{}class v2 extends qf{}class b2 extends qf{}class jf extends Q{}class $2 extends jf{}class x2 extends jf{}class S2 extends Q{}class E2 extends S2{}class Kf extends Q{}class k2 extends Kf{}class T2 extends Kf{}class C2 extends Q{}class I2 extends C2{}class Yf extends Q{}class A2 extends Yf{}class M2 extends Yf{async _call(e){return new Me(await super._call(e))}}class Xf extends Q{}class O2 extends Xf{}class z2 extends Xf{async _call(e){return new Me(await super._call(e))}}class Qf extends Q{}class R2 extends Qf{}class B2 extends Qf{async _call(e){return new Me(await super._call(e))}}class Zf extends Q{}class P2 extends Zf{}class D2 extends Zf{async _call(e){return new N2(await super._call(e))}}class N2 extends yt{constructor({logits:e,pred_boxes:n}){super(),this.logits=e,this.pred_boxes=n}}class L2 extends Q{}class F2 extends L2{constructor(e,n,r){super(e,n),this.prompt_encoder_mask_decoder=r}async get_image_embeddings({pixel_values:e}){return await Ar(this,{pixel_values:e})}async forward(e){if((!e.image_embeddings||!e.image_positional_embeddings)&&(e={...e,...await this.get_image_embeddings(e)}),!e.input_labels){const n=e.input_points.dims.slice(0,-1),r=n.reduce((a,i)=>a*i,1);e.input_labels=new le("int64",new BigInt64Array(r).fill(1n),n)}return await Fn(this.prompt_encoder_mask_decoder,{input_points:e.input_points,input_labels:e.input_labels,image_embeddings:e.image_embeddings,image_positional_embeddings:e.image_positional_embeddings})}async _call(e){return new U2(await super._call(e))}}class U2 extends yt{constructor({iou_scores:e,pred_masks:n}){super(),this.iou_scores=e,this.pred_masks=n}}class Jf extends Q{}class W2 extends Jf{}class V2 extends Jf{constructor(e,n,r,a){super(e,n),this.decoder_merged_session=r,this.generation_config=a,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class em extends Q{}class G2 extends em{}class H2 extends em{constructor(e,n,r,a){super(e,n),this.decoder_merged_session=r,this.generation_config=a,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class En extends Q{}class q2 extends En{}class j2 extends En{async _call(e){return new Hn(await super._call(e))}}class K2 extends En{async _call(e){return new Me(await super._call(e))}}class Y2 extends En{async _call(e){return new ut(await super._call(e))}}class Ls extends Q{}class X2 extends Ls{}class Q2 extends Ls{async _call(e){return new Hn(await super._call(e))}}class Z2 extends Ls{async _call(e){return new Me(await super._call(e))}}class Ja extends Q{}class J2 extends Ja{}class e$ extends Ja{async _call(e){return new Hn(await super._call(e))}}class t$ extends Ja{async _call(e){return new Me(await super._call(e))}}class n$ extends Ja{async _call(e){return new ut(await super._call(e))}}class Fs extends Q{}class r$ extends Fs{}class a$ extends Fs{async _call(e){return new Hn(await super._call(e))}}class i$ extends Fs{async _call(e){return new Me(await super._call(e))}}class s$ extends En{}class o$ extends En{async _call(e){return new Hn(await super._call(e))}}class l$ extends En{async _call(e){return new Me(await super._call(e))}}class jr extends Q{}class u$ extends jr{}class d$ extends jr{async _call(e){return new Hn(await super._call(e))}}class c$ extends jr{async _call(e){return new Me(await super._call(e))}}class p$ extends jr{async _call(e){return new V$(await super._call(e))}}class h$ extends jr{async _call(e){return new ut(await super._call(e))}}class tm extends Q{}class f$ extends tm{}class m$ extends tm{constructor(e,n,r,a){super(e,n),this.decoder_merged_session=r,this.generation_config=a,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.hidden_size/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.hidden_size/this.num_encoder_heads}async generate_speech(e,n,{threshold:r=.5,minlenratio:a=0,maxlenratio:i=20,vocoder:s=null}={}){const o={input_ids:e},{encoder_outputs:l,encoder_attention_mask:d}=await Ar(this,o),p=l.dims[1]/this.config.reduction_factor,u=Math.floor(p*i),f=Math.floor(p*a),m=this.config.num_mel_bins;let _=[],v=null,$=null,b=0;for(;;){++b;const E=Ps(!!$);let I;$?I=$.output_sequence_out:I=new le("float32",new Float32Array(m),[1,1,m]);let M={use_cache_branch:E,output_sequence:I,encoder_attention_mask:d,speaker_embeddings:n,encoder_hidden_states:l};this.addPastKeyValues(M,v),$=await Fn(this.decoder_merged_session,M),v=this.getPastKeyValues($,v);const{prob:F,spectrum:L}=$;if(_.push(L),b>=f&&(Array.from(F.data).filter(W=>W>=r).length>0||b>=u))break}const S=Ms(_),{waveform:T}=await Fn(s.session,{spectrogram:S});return{spectrogram:S,waveform:T}}}class g$ extends Q{main_input_name="spectrogram"}class _$ extends Q{constructor(e,n,r){super(e,n),this.generation_config=r,this.config.pad_token_id=this.config.eos_token_id,this.num_encoder_layers=this.num_decoder_layers=this.config.decoder_layers,this.num_encoder_heads=this.num_decoder_heads=this.config.decoder_attention_heads,this.encoder_dim_kv=this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads}}class w$ extends _${}class nm extends Q{constructor(e,n,r){super(e,n),this.generation_config=r,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_key_value_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.config.num_attention_heads}}class y$ extends nm{}class v$ extends nm{}class rm extends Q{constructor(e,n,r){super(e,n),this.generation_config=r,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_key_value_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.config.num_attention_heads}}class b$ extends rm{}class $$ extends rm{}class am extends Q{constructor(e,n,r){super(e,n),this.generation_config=r,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.config.num_attention_heads}}class x$ extends am{}class S$ extends am{}class Us extends Q{}class E$ extends Us{}class k$ extends Us{static async from_pretrained(e,n={}){return n.model_file_name??="text_model",super.from_pretrained(e,n)}}class T$ extends Us{static async from_pretrained(e,n={}){return n.model_file_name??="audio_model",super.from_pretrained(e,n)}}class C$ extends Q{}class im extends C${async _call(e){return new H$(await super._call(e))}}class sm extends Q{}class I$ extends sm{}class A$ extends sm{}class M$ extends Q{constructor(e,n,r){super(e,n),this.generation_config=r,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.num_heads}}class O$ extends M${}class om extends Q{}class z$ extends om{}class R$ extends om{async _call(e){return new Me(await super._call(e))}}class Xe{static MODEL_CLASS_MAPPINGS=null;static BASE_IF_FAIL=!1;static async from_pretrained(e,{progress_callback:n=null,config:r=null,cache_dir:a=null,local_files_only:i=!1,revision:s="main",model_file_name:o=null,device:l=null,dtype:d=null,session_options:p={}}={}){let u={progress_callback:n,config:r,cache_dir:a,local_files_only:i,revision:s,model_file_name:o,device:l,dtype:d,session_options:p};if(r=await Pn.from_pretrained(e,u),u.config||(u.config=r),!this.MODEL_CLASS_MAPPINGS)throw new Error("`MODEL_CLASS_MAPPINGS` not implemented for this type of `AutoClass`: "+this.name);for(let f of this.MODEL_CLASS_MAPPINGS){const m=f.get(r.model_type);if(m)return await m[1].from_pretrained(e,u)}if(this.BASE_IF_FAIL)return console.warn(`Unknown model class "${r.model_type}", attempting to construct from base class.`),await Q.from_pretrained(e,u);throw Error(`Unsupported model type: ${r.model_type}`)}}const lm=new Map([["bert",["BertModel",Sy]],["nomic_bert",["NomicBertModel",Ay]],["roformer",["RoFormerModel",My]],["electra",["ElectraModel",Uy]],["esm",["EsmModel",pv]],["convbert",["ConvBertModel",Py]],["camembert",["CamembertModel",qy]],["deberta",["DebertaModel",Qy]],["deberta-v2",["DebertaV2Model",nv]],["mpnet",["MPNetModel",vv]],["albert",["AlbertModel",Iv]],["distilbert",["DistilBertModel",ov]],["roberta",["RobertaModel",Xv]],["xlm",["XLMModel",tb]],["xlm-roberta",["XLMRobertaModel",sb]],["clap",["ClapModel",E$]],["clip",["CLIPModel",mb]],["clipseg",["CLIPSegModel",xb]],["chinese_clip",["ChineseCLIPModel",$b]],["siglip",["SiglipModel",wb]],["mobilebert",["MobileBertModel",gv]],["squeezebert",["SqueezeBertModel",Ev]],["wav2vec2",["Wav2Vec2Model",q2]],["wav2vec2-bert",["Wav2Vec2BertModel",r$]],["unispeech",["UniSpeechModel",X2]],["unispeech-sat",["UniSpeechSatModel",J2]],["hubert",["HubertModel",s$]],["wavlm",["WavLMModel",u$]],["audio-spectrogram-transformer",["ASTModel",cb]],["vits",["VitsModel",im]],["detr",["DetrModel",o2]],["table-transformer",["TableTransformerModel",c2]],["vit",["ViTModel",Yb]],["mobilevit",["MobileViTModel",Jb]],["owlvit",["OwlViTModel",t2]],["owlv2",["Owlv2Model",r2]],["beit",["BeitModel",i2]],["deit",["DeiTModel",f2]],["convnext",["ConvNextModel",A2]],["convnextv2",["ConvNextV2Model",O2]],["dinov2",["Dinov2Model",R2]],["resnet",["ResNetModel",g2]],["swin",["SwinModel",w2]],["swin2sr",["Swin2SRModel",v2]],["donut-swin",["DonutSwinModel",I2]],["yolos",["YolosModel",P2]],["dpt",["DPTModel",$2]],["glpn",["GLPNModel",k2]],["hifigan",["SpeechT5HifiGan",g$]],["efficientnet",["EfficientNetModel",z$]]]),um=new Map([["t5",["T5Model",zv]],["longt5",["LongT5Model",Bv]],["mt5",["MT5Model",Dv]],["bart",["BartModel",Lv]],["mbart",["MBartModel",Wv]],["marian",["MarianModel",W2]],["whisper",["WhisperModel",hb]],["m2m_100",["M2M100Model",G2]],["blenderbot",["BlenderbotModel",qv]],["blenderbot-small",["BlenderbotSmallModel",Kv]]]),B$=new Map([["bloom",["BloomModel",Vb]],["gpt2",["GPT2Model",Eb]],["gptj",["GPTJModel",Mb]],["gpt_bigcode",["GPTBigCodeModel",zb]],["gpt_neo",["GPTNeoModel",Tb]],["gpt_neox",["GPTNeoXModel",Ib]],["codegen",["CodeGenModel",Bb]],["llama",["LlamaModel",Db]],["qwen2",["Qwen2Model",Lb]],["phi",["PhiModel",Ub]],["mpt",["MptModel",Hb]],["opt",["OPTModel",jb]],["mistral",["MistralModel",y$]],["starcoder2",["Starcoder2Model",b$]],["falcon",["FalconModel",x$]]]),Ws=new Map([["speecht5",["SpeechT5ForSpeechToText",f$]],["whisper",["WhisperForConditionalGeneration",fb]]]),dm=new Map([["speecht5",["SpeechT5ForTextToSpeech",m$]]]),cm=new Map([["vits",["VitsModel",im]]]),pm=new Map([["bert",["BertForSequenceClassification",ky]],["roformer",["RoFormerForSequenceClassification",zy]],["electra",["ElectraForSequenceClassification",Vy]],["esm",["EsmForSequenceClassification",fv]],["convbert",["ConvBertForSequenceClassification",Ny]],["camembert",["CamembertForSequenceClassification",Ky]],["deberta",["DebertaForSequenceClassification",Jy]],["deberta-v2",["DebertaV2ForSequenceClassification",av]],["mpnet",["MPNetForSequenceClassification",$v]],["albert",["AlbertForSequenceClassification",Av]],["distilbert",["DistilBertForSequenceClassification",lv]],["roberta",["RobertaForSequenceClassification",Zv]],["xlm",["XLMForSequenceClassification",rb]],["xlm-roberta",["XLMRobertaForSequenceClassification",lb]],["bart",["BartForSequenceClassification",Uv]],["mbart",["MBartForSequenceClassification",Gv]],["mobilebert",["MobileBertForSequenceClassification",wv]],["squeezebert",["SqueezeBertForSequenceClassification",Tv]]]),hm=new Map([["bert",["BertForTokenClassification",Ty]],["roformer",["RoFormerForTokenClassification",Ry]],["electra",["ElectraForTokenClassification",Gy]],["esm",["EsmForTokenClassification",mv]],["convbert",["ConvBertForTokenClassification",Ly]],["camembert",["CamembertForTokenClassification",Yy]],["deberta",["DebertaForTokenClassification",ev]],["deberta-v2",["DebertaV2ForTokenClassification",iv]],["mpnet",["MPNetForTokenClassification",xv]],["distilbert",["DistilBertForTokenClassification",uv]],["roberta",["RobertaForTokenClassification",Jv]],["xlm",["XLMForTokenClassification",ab]],["xlm-roberta",["XLMRobertaForTokenClassification",ub]]]),Vs=new Map([["t5",["T5ForConditionalGeneration",Rv]],["longt5",["LongT5ForConditionalGeneration",Pv]],["mt5",["MT5ForConditionalGeneration",Nv]],["bart",["BartForConditionalGeneration",Fv]],["mbart",["MBartForConditionalGeneration",Vv]],["marian",["MarianMTModel",V2]],["m2m_100",["M2M100ForConditionalGeneration",H2]],["blenderbot",["BlenderbotForConditionalGeneration",jv]],["blenderbot-small",["BlenderbotSmallForConditionalGeneration",Yv]]]),ei=new Map([["bloom",["BloomForCausalLM",Gb]],["gpt2",["GPT2LMHeadModel",kb]],["gptj",["GPTJForCausalLM",Ob]],["gpt_bigcode",["GPTBigCodeForCausalLM",Rb]],["gpt_neo",["GPTNeoForCausalLM",Cb]],["gpt_neox",["GPTNeoXForCausalLM",Ab]],["codegen",["CodeGenForCausalLM",Pb]],["llama",["LlamaForCausalLM",Nb]],["qwen2",["Qwen2ForCausalLM",Fb]],["phi",["PhiForCausalLM",Wb]],["mpt",["MptForCausalLM",qb]],["opt",["OPTForCausalLM",Kb]],["mbart",["MBartForCausalLM",Hv]],["mistral",["MistralForCausalLM",v$]],["starcoder2",["Starcoder2ForCausalLM",$$]],["falcon",["FalconForCausalLM",S$]],["trocr",["TrOCRForCausalLM",w$]],["stablelm",["StableLmForCausalLM",O$]]]),fm=new Map([["bert",["BertForMaskedLM",Ey]],["roformer",["RoFormerForMaskedLM",Oy]],["electra",["ElectraForMaskedLM",Wy]],["esm",["EsmForMaskedLM",hv]],["convbert",["ConvBertForMaskedLM",Dy]],["camembert",["CamembertForMaskedLM",jy]],["deberta",["DebertaForMaskedLM",Zy]],["deberta-v2",["DebertaV2ForMaskedLM",rv]],["mpnet",["MPNetForMaskedLM",bv]],["albert",["AlbertForMaskedLM",Ov]],["distilbert",["DistilBertForMaskedLM",cv]],["roberta",["RobertaForMaskedLM",Qv]],["xlm",["XLMWithLMHeadModel",nb]],["xlm-roberta",["XLMRobertaForMaskedLM",ob]],["mobilebert",["MobileBertForMaskedLM",_v]],["squeezebert",["SqueezeBertForMaskedLM",kv]]]),mm=new Map([["bert",["BertForQuestionAnswering",Cy]],["roformer",["RoFormerForQuestionAnswering",By]],["electra",["ElectraForQuestionAnswering",Hy]],["convbert",["ConvBertForQuestionAnswering",Fy]],["camembert",["CamembertForQuestionAnswering",Xy]],["deberta",["DebertaForQuestionAnswering",tv]],["deberta-v2",["DebertaV2ForQuestionAnswering",sv]],["mpnet",["MPNetForQuestionAnswering",Sv]],["albert",["AlbertForQuestionAnswering",Mv]],["distilbert",["DistilBertForQuestionAnswering",dv]],["roberta",["RobertaForQuestionAnswering",eb]],["xlm",["XLMForQuestionAnswering",ib]],["xlm-roberta",["XLMRobertaForQuestionAnswering",db]],["mobilebert",["MobileBertForQuestionAnswering",yv]],["squeezebert",["SqueezeBertForQuestionAnswering",Cv]]]),Gs=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",bf]]]),P$=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",bf]]]),gm=new Map([["vit",["ViTForImageClassification",Xb]],["mobilevit",["MobileViTForImageClassification",e2]],["beit",["BeitForImageClassification",s2]],["deit",["DeiTForImageClassification",m2]],["convnext",["ConvNextForImageClassification",M2]],["convnextv2",["ConvNextV2ForImageClassification",z2]],["dinov2",["Dinov2ForImageClassification",B2]],["resnet",["ResNetForImageClassification",_2]],["swin",["SwinForImageClassification",y2]],["segformer",["SegformerForImageClassification",I$]],["efficientnet",["EfficientNetForImageClassification",R$]]]),_m=new Map([["detr",["DetrForObjectDetection",l2]],["table-transformer",["TableTransformerForObjectDetection",p2]],["yolos",["YolosForObjectDetection",D2]]]),wm=new Map([["owlvit",["OwlViTForObjectDetection",n2]],["owlv2",["Owlv2ForObjectDetection",a2]]]),ym=new Map([["detr",["DetrForSegmentation",u2]],["clipseg",["CLIPSegForImageSegmentation",Sb]]]),vm=new Map([["segformer",["SegformerForSemanticSegmentation",A$]]]),D$=new Map([["sam",["SamModel",F2]]]),bm=new Map([["wav2vec2",["Wav2Vec2ForCTC",j2]],["wav2vec2-bert",["Wav2Vec2BertForCTC",a$]],["unispeech",["UniSpeechForCTC",Q2]],["unispeech-sat",["UniSpeechSatForCTC",e$]],["wavlm",["WavLMForCTC",d$]],["hubert",["HubertForCTC",o$]]]),$m=new Map([["wav2vec2",["Wav2Vec2ForSequenceClassification",K2]],["wav2vec2-bert",["Wav2Vec2BertForSequenceClassification",i$]],["unispeech",["UniSpeechForSequenceClassification",Z2]],["unispeech-sat",["UniSpeechSatForSequenceClassification",t$]],["wavlm",["WavLMForSequenceClassification",c$]],["hubert",["HubertForSequenceClassification",l$]],["audio-spectrogram-transformer",["ASTForAudioClassification",pb]]]),N$=new Map([["wavlm",["WavLMForXVector",p$]]]),L$=new Map([["unispeech-sat",["UniSpeechSatForAudioFrameClassification",n$]],["wavlm",["WavLMForAudioFrameClassification",h$]],["wav2vec2",["Wav2Vec2ForAudioFrameClassification",Y2]]]),F$=new Map([["vitmatte",["VitMatteForImageMatting",Zb]]]),xm=new Map([["swin2sr",["Swin2SRForImageSuperResolution",b2]]]),Sm=new Map([["dpt",["DPTForDepthEstimation",x2]],["depth_anything",["DepthAnythingForDepthEstimation",E2]],["glpn",["GLPNForDepthEstimation",T2]]]),Em=new Map([["clip",["CLIPVisionModelWithProjection",_b]],["siglip",["SiglipVisionModel",vb]]]),km=[[lm,Ee.EncoderOnly],[um,Ee.EncoderDecoder],[B$,Ee.DecoderOnly],[pm,Ee.EncoderOnly],[hm,Ee.EncoderOnly],[Vs,Ee.Seq2Seq],[Ws,Ee.Seq2Seq],[ei,Ee.DecoderOnly],[fm,Ee.EncoderOnly],[mm,Ee.EncoderOnly],[Gs,Ee.Vision2Seq],[gm,Ee.EncoderOnly],[ym,Ee.EncoderOnly],[vm,Ee.EncoderOnly],[F$,Ee.EncoderOnly],[xm,Ee.EncoderOnly],[Sm,Ee.EncoderOnly],[_m,Ee.EncoderOnly],[wm,Ee.EncoderOnly],[D$,Ee.MaskGeneration],[bm,Ee.EncoderOnly],[$m,Ee.EncoderOnly],[dm,Ee.Seq2Seq],[cm,Ee.EncoderOnly],[N$,Ee.EncoderOnly],[L$,Ee.EncoderOnly],[Em,Ee.EncoderOnly]];for(const[t,e]of km)for(const[n,r]of t.values())Fa.set(n,e),Sr.set(r,n),cf.set(n,r);const U$=[["CLIPTextModelWithProjection",gb,Ee.EncoderOnly],["SiglipTextModel",yb,Ee.EncoderOnly],["ClapTextModelWithProjection",k$,Ee.EncoderOnly],["ClapAudioModelWithProjection",T$,Ee.EncoderOnly]];for(const[t,e,n]of U$)Fa.set(t,n),Sr.set(e,t),cf.set(t,e);class i1 extends Xe{static MODEL_CLASS_MAPPINGS=km.map(e=>e[0]);static BASE_IF_FAIL=!0}class s1 extends Xe{static MODEL_CLASS_MAPPINGS=[pm]}class o1 extends Xe{static MODEL_CLASS_MAPPINGS=[hm]}class l1 extends Xe{static MODEL_CLASS_MAPPINGS=[Vs]}class u1 extends Xe{static MODEL_CLASS_MAPPINGS=[Ws]}class d1 extends Xe{static MODEL_CLASS_MAPPINGS=[dm]}class c1 extends Xe{static MODEL_CLASS_MAPPINGS=[cm]}class p1 extends Xe{static MODEL_CLASS_MAPPINGS=[ei]}class h1 extends Xe{static MODEL_CLASS_MAPPINGS=[fm]}class f1 extends Xe{static MODEL_CLASS_MAPPINGS=[mm]}class m1 extends Xe{static MODEL_CLASS_MAPPINGS=[Gs]}class g1 extends Xe{static MODEL_CLASS_MAPPINGS=[gm]}class _1 extends Xe{static MODEL_CLASS_MAPPINGS=[ym]}class w1 extends Xe{static MODEL_CLASS_MAPPINGS=[vm]}class y1 extends Xe{static MODEL_CLASS_MAPPINGS=[_m]}class v1 extends Xe{static MODEL_CLASS_MAPPINGS=[wm]}class b1 extends Xe{static MODEL_CLASS_MAPPINGS=[bm]}class $1 extends Xe{static MODEL_CLASS_MAPPINGS=[$m]}class x1 extends Xe{static MODEL_CLASS_MAPPINGS=[P$]}class S1 extends Xe{static MODEL_CLASS_MAPPINGS=[xm]}class E1 extends Xe{static MODEL_CLASS_MAPPINGS=[Sm]}class k1 extends Xe{static MODEL_CLASS_MAPPINGS=[Em]}class W$ extends yt{constructor({logits:e,past_key_values:n,encoder_outputs:r,decoder_attentions:a=null,cross_attentions:i=null}){super(),this.logits=e,this.past_key_values=n,this.encoder_outputs=r,this.decoder_attentions=a,this.cross_attentions=i}}class Me extends yt{constructor({logits:e}){super(),this.logits=e}}class V$ extends yt{constructor({logits:e,embeddings:n}){super(),this.logits=e,this.embeddings=n}}class ut extends yt{constructor({logits:e}){super(),this.logits=e}}class dt extends yt{constructor({logits:e}){super(),this.logits=e}}class pt extends yt{constructor({start_logits:e,end_logits:n}){super(),this.start_logits=e,this.end_logits=n}}class Hn extends yt{constructor({logits:e}){super(),this.logits=e}}class G$ extends yt{constructor({alphas:e}){super(),this.alphas=e}}class H$ extends yt{constructor({waveform:e,spectrogram:n}){super(),this.waveform=e,this.spectrogram=n}}const $t=typeof self<"u",q$=$t&&self.constructor.name==="DedicatedWorkerGlobalScope";let vn,Tm,un;if($t)vn=(t,e)=>{if(!self.OffscreenCanvas)throw new Error("OffscreenCanvas not supported by this browser.");return new self.OffscreenCanvas(t,e)},un=self.createImageBitmap,Tm=self.ImageData;else if(Ke)un=async t=>{const n=(await t.metadata()).channels,{data:r,info:a}=await t.raw().toBuffer({resolveWithObject:!0}),i=new Wt(new Uint8ClampedArray(r),a.width,a.height,a.channels);return n!==void 0&&n!==a.channels&&i.convert(n),i};else throw new Error("Unable to load image processing library.");const j$={0:"nearest",1:"lanczos",2:"bilinear",3:"bicubic",4:"box",5:"hamming"},K$=new Map([["png","image/png"],["jpg","image/jpeg"],["jpeg","image/jpeg"],["gif","image/gif"]]);class Wt{constructor(e,n,r,a){this.data=e,this.width=n,this.height=r,this.channels=a}get size(){return[this.width,this.height]}static async read(e){if(e instanceof Wt)return e;if(typeof e=="string"||e instanceof URL)return await this.fromURL(e);throw new Error(`Unsupported input type: ${typeof e}`)}static fromCanvas(e){if(!$t)throw new Error("fromCanvas() is only supported in browser environments.");const r=e.getContext("2d").getImageData(0,0,e.width,e.height).data;return new Wt(r,e.width,e.height,4)}static async fromURL(e){const n=await Vi(e);if(n.status!==200)throw new Error(`Unable to read image from "${e}" (${n.status} ${n.statusText})`);const r=await n.blob();return this.fromBlob(r)}static async fromBlob(e){if($t){const n=await un(e),r=vn(n.width,n.height).getContext("2d");return r.drawImage(n,0,0),new this(r.getImageData(0,0,n.width,n.height).data,n.width,n.height,4)}else{const n=Ke(await e.arrayBuffer());return await un(n)}}static fromTensor(e,n="CHW"){if(e.dims.length!==3)throw new Error(`Tensor should have 3 dimensions, but has ${e.dims.length} dimensions.`);if(n==="CHW")e=e.transpose(1,2,0);else if(n!=="HWC")throw new Error(`Unsupported channel format: ${n}`);if(!(e.data instanceof Uint8ClampedArray||e.data instanceof Uint8Array))throw new Error(`Unsupported tensor type: ${e.type}`);switch(e.dims[2]){case 1:case 2:case 3:case 4:return new Wt(e.data,e.dims[1],e.dims[0],e.dims[2]);default:throw new Error(`Unsupported number of channels: ${e.dims[2]}`)}}grayscale(){if(this.channels===1)return this;const e=new Uint8ClampedArray(this.width*this.height*1);switch(this.channels){case 3:case 4:for(let n=0,r=0;n<this.data.length;n+=this.channels){const a=this.data[n],i=this.data[n+1],s=this.data[n+2];e[r++]=Math.round(.2989*a+.587*i+.114*s)}break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(e,this.width,this.height,1)}rgb(){if(this.channels===3)return this;const e=new Uint8ClampedArray(this.width*this.height*3);switch(this.channels){case 1:for(let n=0,r=0;n<this.data.length;++n)e[r++]=this.data[n],e[r++]=this.data[n],e[r++]=this.data[n];break;case 4:for(let n=0,r=0;n<this.data.length;n+=4)e[r++]=this.data[n],e[r++]=this.data[n+1],e[r++]=this.data[n+2];break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(e,this.width,this.height,3)}rgba(){if(this.channels===4)return this;const e=new Uint8ClampedArray(this.width*this.height*4);switch(this.channels){case 1:for(let n=0,r=0;n<this.data.length;++n)e[r++]=this.data[n],e[r++]=this.data[n],e[r++]=this.data[n],e[r++]=255;break;case 3:for(let n=0,r=0;n<this.data.length;n+=3)e[r++]=this.data[n],e[r++]=this.data[n+1],e[r++]=this.data[n+2],e[r++]=255;break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(e,this.width,this.height,4)}async resize(e,n,{resample:r=2}={}){let a=j$[r]??r;if($t){const i=this.channels,s=this.toCanvas(),o=vn(e,n).getContext("2d");return o.drawImage(s,0,0,e,n),new Wt(o.getImageData(0,0,e,n).data,e,n,4).convert(i)}else{let i=this.toSharp();switch(a){case"box":case"hamming":(a==="box"||a==="hamming")&&(console.warn(`Resampling method ${a} is not yet supported. Using bilinear instead.`),a="bilinear");case"nearest":case"bilinear":case"bicubic":i=i.affine([e/this.width,0,0,n/this.height],{interpolator:a});break;case"lanczos":i=i.resize({width:e,height:n,fit:"fill",kernel:"lanczos3"});break;default:throw new Error(`Resampling method ${a} is not supported.`)}return await un(i)}}async pad([e,n,r,a]){if(e=Math.max(e,0),n=Math.max(n,0),r=Math.max(r,0),a=Math.max(a,0),e===0&&n===0&&r===0&&a===0)return this;if($t){const i=this.channels,s=this.toCanvas(),o=this.width+e+n,l=this.height+r+a,d=vn(o,l).getContext("2d");return d.drawImage(s,0,0,this.width,this.height,e,r,o,l),new Wt(d.getImageData(0,0,o,l).data,o,l,4).convert(i)}else{const i=this.toSharp().extend({left:e,right:n,top:r,bottom:a});return await un(i)}}async crop([e,n,r,a]){if(e=Math.max(e,0),n=Math.max(n,0),r=Math.min(r,this.width-1),a=Math.min(a,this.height-1),e===0&&n===0&&r===this.width-1&&a===this.height-1)return this;const i=r-e+1,s=a-n+1;if($t){const o=this.channels,l=this.toCanvas(),d=vn(i,s).getContext("2d");return d.drawImage(l,e,n,i,s,0,0,i,s),new Wt(d.getImageData(0,0,i,s).data,i,s,4).convert(o)}else{const o=this.toSharp().extract({left:e,top:n,width:i,height:s});return await un(o)}}async center_crop(e,n){if(this.width===e&&this.height===n)return this;const r=(this.width-e)/2,a=(this.height-n)/2;if($t){const i=this.channels,s=this.toCanvas(),o=vn(e,n).getContext("2d");let l=0,d=0,p=0,u=0;return r>=0?l=r:p=-r,a>=0?d=a:u=-a,o.drawImage(s,l,d,e,n,p,u,e,n),new Wt(o.getImageData(0,0,e,n).data,e,n,4).convert(i)}else{let i=this.toSharp();if(r>=0&&a>=0)i=i.extract({left:Math.floor(r),top:Math.floor(a),width:e,height:n});else if(r<=0&&a<=0){const s=Math.floor(-a),o=Math.floor(-r);i=i.extend({top:s,left:o,right:e-this.width-o,bottom:n-this.height-s})}else{let s=[0,0],o=0;a<0?(s[0]=Math.floor(-a),s[1]=n-this.height-s[0]):o=Math.floor(a);let l=[0,0],d=0;r<0?(l[0]=Math.floor(-r),l[1]=e-this.width-l[0]):d=Math.floor(r),i=i.extend({top:s[0],bottom:s[1],left:l[0],right:l[1]}).extract({left:d,top:o,width:e,height:n})}return await un(i)}}async toBlob(e="image/png",n=1){if(!$t)throw new Error("toBlob() is only supported in browser environments.");return await this.toCanvas().convertToBlob({type:e,quality:n})}toTensor(e="CHW"){let n=new le("uint8",new Uint8Array(this.data),[this.height,this.width,this.channels]);if(e!=="HWC")if(e==="CHW")n=n.permute(2,0,1);else throw new Error(`Unsupported channel format: ${e}`);return n}toCanvas(){if(!$t)throw new Error("toCanvas() is only supported in browser environments.");const e=this.clone().rgba(),n=vn(e.width,e.height),r=new Tm(e.data,e.width,e.height);return n.getContext("2d").putImageData(r,0,0),n}_update(e,n,r,a=null){return this.data=e,this.width=n,this.height=r,a!==null&&(this.channels=a),this}clone(){return new Wt(this.data.slice(),this.width,this.height,this.channels)}convert(e){if(this.channels===e)return this;switch(e){case 1:this.grayscale();break;case 3:this.rgb();break;case 4:this.rgba();break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this}async save(e){if($t){if(q$)throw new Error("Unable to save an image from a Web Worker.");const n=e.split(".").pop().toLowerCase(),r=K$.get(n)??"image/png",a=await this.toBlob(r),i=URL.createObjectURL(a),s=document.createElement("a");s.href=i,s.download=e,s.click(),s.remove()}else{if(ot.useFS)return await this.toSharp().toFile(e);throw new Error("Unable to save the image because filesystem is disabled in this environment.")}}toSharp(){if($t)throw new Error("toSharp() is only supported in server-side environments.");return Ke(this.data,{raw:{width:this.width,height:this.height,channels:this.channels}})}}export{a1 as A,Wa as B,Q$ as C,r1 as D,X$ as E,pa as F,n1 as G,qt as H,J$ as I,Z$ as J,Vi as K,Er as L,rg as M,L0 as N,Y$ as O,Ms as P,e1 as Q,Wt as R,le as T,i1 as a,s1 as b,o1 as c,lr as d,ot as e,f1 as f,h1 as g,l1 as h,p1 as i,$1 as j,u1 as k,b1 as l,c1 as m,d1 as n,m1 as o,g1 as p,_1 as q,w1 as r,y1 as s,v1 as t,x1 as u,S1 as v,E1 as w,k1 as x,ls as y,Ad as z};
