import{I as ht,J as V,B as O,K as ft,L as ut,M as _t,T as F,N as Z,G as D,y as st,O as Q,P as dt,H as nt,Q as mt}from"./image-O15s_1zf.js";async function ne(r,t){if(typeof AudioContext>"u")throw Error("Unable to load audio from path/URL since `AudioContext` is not available in your environment. Instead, audio data should be passed directly to the pipeline/processor. For more information and some example code, see https://huggingface.co/docs/transformers.js/guides/node-audio-processing.");const e=await(await ft(r)).arrayBuffer(),s=new AudioContext({sampleRate:t});typeof t>"u"&&console.warn(`No sampling rate provided, using default of ${s.sampleRate}Hz.`);const i=await s.decodeAudioData(e);let n;if(i.numberOfChannels===2){const a=Math.sqrt(2),c=i.getChannelData(0),l=i.getChannelData(1);n=new Float32Array(c.length);for(let o=0;o<i.length;++o)n[o]=a*(c[o]+l[o])/2}else n=i.getChannelData(0);return n}function Y(r){if(r<1)return new Float64Array;if(r===1)return new Float64Array([1]);const t=r-1,e=Math.PI/t,s=new Float64Array(r);for(let i=0;i<r;++i){const n=2*i-t;s[i]=.5+.5*Math.cos(e*n)}return s}const gt={htk:r=>2595*Math.log10(1+r/700),kaldi:r=>1127*Math.log(1+r/700),slaney:(r,t=1e3,e=15,s=27/Math.log(6.4))=>r>=t?e+Math.log(r/t)*s:3*r/200};function q(r,t="htk"){const e=gt[t];if(!e)throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');return typeof r=="number"?e(r):r.map(s=>e(s))}const pt={htk:r=>700*(10**(r/2595)-1),kaldi:r=>700*(Math.exp(r/1127)-1),slaney:(r,t=1e3,e=15,s=Math.log(6.4)/27)=>r>=e?t*Math.exp(s*(r-e)):200*r/3};function wt(r,t="htk"){const e=pt[t];if(!e)throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');return typeof r=="number"?e(r):r.map(s=>e(s))}function xt(r,t){const e=Float64Array.from({length:t.length-1},(a,c)=>t[c+1]-t[c]),s=Array.from({length:r.length},()=>new Array(t.length));for(let a=0;a<r.length;++a){const c=s[a];for(let l=0;l<t.length;++l)c[l]=t[l]-r[a]}const i=t.length-2,n=Array.from({length:i},()=>new Array(r.length));for(let a=0;a<r.length;++a){const c=s[a];for(let l=0;l<i;++l){const o=-c[l]/e[l],h=c[l+2]/e[l+1];n[l][a]=Math.max(0,Math.min(o,h))}}return n}function tt(r,t,e){const s=(t-r)/(e-1);return Float64Array.from({length:e},(i,n)=>r+s*n)}function W(r,t,e,s,i,n=null,a="htk",c=!1){if(n!==null&&n!=="slaney")throw new Error('norm must be one of null or "slaney"');const l=q(e,a),o=q(s,a),h=tt(l,o,t+2);let g=wt(h,a),u;if(c){const _=i/(r*2);u=q(Float64Array.from({length:r},(f,d)=>d*_),a),g=h}else u=tt(0,Math.floor(i/2),r);const p=xt(u,g);if(n!==null&&n==="slaney")for(let _=0;_<t;++_){const f=p[_],d=2/(g[_+2]-g[_]);for(let m=0;m<r;++m)f[m]*=d}return p}function yt(r,t,e){const s=new r.constructor(r.length+t+e),i=r.length-1;for(let n=0;n<r.length;++n)s[t+n]=r[n];for(let n=1;n<=t;++n)s[t-n]=r[V(n,i)];for(let n=1;n<=e;++n)s[i+t+n]=r[V(i-n,i)];return s}function rt(r,t,e,s,i){if(e<=0)throw new Error("reference must be greater than zero");if(s<=0)throw new Error("min_value must be greater than zero");e=Math.max(s,e);const n=Math.log10(e);for(let a=0;a<r.length;++a)r[a]=t*Math.log10(Math.max(s,r[a])-n);if(i!==null){if(i<=0)throw new Error("db_range must be greater than zero");const a=O(r)[0]-i;for(let c=0;c<r.length;++c)r[c]=Math.max(r[c],a)}return r}function bt(r,t=1,e=1e-5,s=null){return rt(r,20,t,e,s)}function At(r,t=1,e=1e-10,s=null){return rt(r,10,t,e,s)}function G(r,t,e,s,{fft_length:i=null,power:n=1,center:a=!0,pad_mode:c="reflect",onesided:l=!0,preemphasis:o=null,mel_filters:h=null,mel_floor:g=1e-10,log_mel:u=null,reference:p=1,min_value:_=1e-10,db_range:f=null,remove_dc_offset:d=null,max_num_frames:m=null,do_pad:w=!0,transpose:y=!1}={}){const z=t.length;if(i===null&&(i=e),e>i)throw Error(`frame_length (${e}) may not be larger than fft_length (${i})`);if(z!==e)throw new Error(`Length of the window (${z}) must equal frame_length (${e})`);if(s<=0)throw new Error("hop_length must be greater than zero");if(a){if(c!=="reflect")throw new Error(`pad_mode="${c}" not implemented yet.`);const M=Math.floor((i-1)/2)+1;r=yt(r,M,M)}const b=Math.floor(1+Math.floor((r.length-e)/s)),T=l?Math.floor(i/2)+1:i;let k=b,C=b;m!==null&&(m>b?w&&(C=m):C=k=m);const L=new ht(i),v=new Float64Array(i),J=new Float64Array(L.outputBufferSize),B=new Array(k);for(let M=0;M<k;++M){const E=M*s;for(let x=0;x<e;++x)v[x]=r[E+x];if(d){let x=0;for(let P=0;P<e;++P)x+=v[P];const R=x/e;for(let P=0;P<e;++P)v[P]-=R}if(o!==null){for(let x=e-1;x>=1;--x)v[x]-=o*v[x-1];v[0]*=1-o}for(let x=0;x<t.length;++x)v[x]*=t[x];L.realTransform(J,v);const I=new Array(T);for(let x=0;x<I.length;++x){const R=x<<1;I[x]=J[R]**2+J[R+1]**2}B[M]=I}if(n!==null&&n!==2){const M=2/n;for(let E=0;E<B.length;++E){const I=B[E];for(let x=0;x<I.length;++x)I[x]**=M}}const $=h.length,j=new Float32Array($*C),ct=y?[C,$]:[$,C];for(let M=0;M<$;++M){const E=h[M];for(let I=0;I<k;++I){const x=B[I];let R=0;for(let P=0;P<T;++P)R+=E[P]*x[P];j[y?I*$+M:M*k+I]=Math.max(g,R)}}if(n!==null&&u!==null){const M=Math.min(j.length,k*$);switch(u){case"log":for(let E=0;E<M;++E)j[E]=Math.log(j[E]);break;case"log10":for(let E=0;E<M;++E)j[E]=Math.log10(j[E]);break;case"dB":if(n===1)bt(j,p,_,f);else if(n===2)At(j,p,_,f);else throw new Error(`Cannot use log_mel option '${u}' with power ${n}`);break;default:throw new Error(`log_mel must be one of null, 'log', 'log10' or 'dB'. Got '${u}'`)}}return{data:j,dims:ct}}function U(r,t,{periodic:e=!0,frame_length:s=null,center:i=!0}={}){const n=e?r+1:r;let a;switch(t){case"boxcar":a=new Float64Array(n).fill(1);break;case"hann":case"hann_window":a=Y(n);break;case"povey":a=Y(n).map(c=>Math.pow(c,.85));break;default:throw new Error(`Unknown window type ${t}.`)}if(e&&(a=a.subarray(0,r)),s===null)return a;if(r>s)throw new Error(`Length of the window (${r}) may not be larger than frame_length (${s})`);return a}function zt([r,t,e,s]){return[r-e/2,t-s/2,r+e/2,t+s/2]}function K(r,t=.5,e=null,s=!1){const i=r.logits,n=r.pred_boxes,[a,c,l]=i.dims;if(e!==null&&e.length!==a)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let o=[];for(let h=0;h<a;++h){let g=e!==null?e[h]:null,u={boxes:[],classes:[],scores:[]},p=i[h],_=n[h];for(let f=0;f<c;++f){let d=p[f],m=[],w;if(s){w=d.sigmoid().data;for(let y=0;y<w.length;++y)w[y]>t&&m.push(y)}else{let y=O(d.data)[1];if(y===l-1||(w=st(d.data),w[y]<t))continue;m.push(y)}for(const y of m){let z=_[f].data;z=zt(z),g!==null&&(z=z.map((b,T)=>b*g[(T+1)%2])),u.boxes.push(z),u.classes.push(y),u.scores.push(w[y])}}o.push(u)}return o}function H(r,t){if(!(r instanceof Float32Array||r instanceof Float64Array))throw new Error(`${t} expects input to be a Float32Array or a Float64Array, but got ${r?.constructor?.name??typeof r} instead. If using the feature extractor directly, remember to use \`read_audio(url, sampling_rate)\` to obtain the raw audio data of the file/url.`)}function et(r,t,e=0,s=null){const i=r/t;let n=mt(i)*t;return s!==null&&n>s&&(n=Math.floor(i)*t),n<e&&(n=Math.ceil(i)*t),n}function X([r,t],e){return[Math.max(Math.floor(r/e),1)*e,Math.max(Math.floor(t/e),1)*e]}class S extends nt{constructor(t){super(),this.config=t}}class A extends S{constructor(t){super(t),this.image_mean=this.config.image_mean??this.config.mean,this.image_std=this.config.image_std??this.config.std,this.resample=this.config.resample??2,this.do_rescale=this.config.do_rescale??!0,this.rescale_factor=this.config.rescale_factor??1/255,this.do_normalize=this.config.do_normalize,this.do_resize=this.config.do_resize,this.do_thumbnail=this.config.do_thumbnail,this.size=this.config.size,this.size_divisibility=this.config.size_divisibility??this.config.size_divisor,this.do_center_crop=this.config.do_center_crop,this.crop_size=this.config.crop_size,this.do_convert_rgb=this.config.do_convert_rgb??!0,this.do_crop_margin=this.config.do_crop_margin,this.pad_size=this.config.pad_size,this.do_pad=this.config.do_pad,this.do_pad&&!this.pad_size&&this.size&&this.size.width!==void 0&&this.size.height!==void 0&&(this.pad_size=this.size)}async thumbnail(t,e,s=2){const i=t.height,n=t.width,a=e.height,c=e.width;let l=Math.min(i,a),o=Math.min(n,c);return l===i&&o===n?t:(i>n?o=Math.floor(n*l/i):n>i&&(l=Math.floor(i*o/n)),await t.resize(o,l,{resample:s}))}async crop_margin(t,e=200){const s=t.clone().grayscale(),i=_t(s.data)[0],a=O(s.data)[0]-i;if(a===0)return t;const c=e/255;let l=s.width,o=s.height,h=0,g=0;for(let u=0;u<s.height;++u){const p=u*s.width;for(let _=0;_<s.width;++_)(s.data[p+_]-i)/a<c&&(l=Math.min(l,_),o=Math.min(o,u),h=Math.max(h,_),g=Math.max(g,u))}return t=await t.crop([l,o,h,g]),t}pad_image(t,e,s,{mode:i="constant",center:n=!1,constant_values:a=0}={}){const[c,l,o]=e;let h,g;if(typeof s=="number"?(h=s,g=s):(h=s.width,g=s.height),h!==l||g!==c){const u=new Float32Array(h*g*o);if(Array.isArray(a))for(let f=0;f<u.length;++f)u[f]=a[f%o];else a!==0&&u.fill(a);const[p,_]=n?[Math.floor((h-l)/2),Math.floor((g-c)/2)]:[0,0];for(let f=0;f<c;++f){const d=(f+_)*h,m=f*l;for(let w=0;w<l;++w){const y=(d+w+p)*o,z=(m+w)*o;for(let b=0;b<o;++b)u[y+b]=t[z+b]}}if(i==="symmetric"){if(n)throw new Error("`center` padding is not supported when `mode` is set to `symmetric`.");const f=c-1,d=l-1;for(let m=0;m<g;++m){const w=m*h,y=V(m,f)*l;for(let z=0;z<h;++z){if(m<c&&z<l)continue;const b=(w+z)*o,T=(y+V(z,d))*o;for(let k=0;k<o;++k)u[b+k]=t[T+k]}}}t=u,e=[g,h,o]}return[t,e]}rescale(t){for(let e=0;e<t.length;++e)t[e]=this.rescale_factor*t[e]}get_resize_output_image_size(t,e){const[s,i]=t.size;let n,a;if(this.do_thumbnail){const{height:c,width:l}=e;n=Math.min(c,l)}else Number.isInteger(e)?(n=e,a=this.config.max_size??n):e!==void 0&&(n=e.shortest_edge,a=e.longest_edge);if(n!==void 0||a!==void 0){const c=n===void 0?1:Math.max(n/s,n/i),l=s*c,o=i*c,h=a===void 0?1:Math.min(a/l,a/o);let g=Math.floor(Number((l*h).toFixed(2))),u=Math.floor(Number((o*h).toFixed(2)));return this.size_divisibility!==void 0&&([g,u]=X([g,u],this.size_divisibility)),[g,u]}else if(e!==void 0&&e.width!==void 0&&e.height!==void 0){let c=e.width,l=e.height;if(this.config.keep_aspect_ratio&&this.config.ensure_multiple_of){let o=l/i,h=c/s;Math.abs(1-h)<Math.abs(1-o)?o=h:h=o,l=et(o*i,this.config.ensure_multiple_of),c=et(h*s,this.config.ensure_multiple_of)}return[c,l]}else{if(this.size_divisibility!==void 0)return X([s,i],this.size_divisibility);throw new Error(`Could not resize image due to unsupported \`this.size\` option in config: ${JSON.stringify(e)}`)}}async resize(t){const[e,s]=this.get_resize_output_image_size(t,this.size);return await t.resize(e,s,{resample:this.resample})}async preprocess(t,{do_normalize:e=null,do_pad:s=null,do_convert_rgb:i=null,do_convert_grayscale:n=null}={}){this.do_crop_margin&&(t=await this.crop_margin(t));const[a,c]=t.size;if(i??this.do_convert_rgb?t=t.rgb():n&&(t=t.grayscale()),this.do_resize&&(t=await this.resize(t)),this.do_thumbnail&&(t=await this.thumbnail(t,this.size,this.resample)),this.do_center_crop){let u,p;Number.isInteger(this.crop_size)?(u=this.crop_size,p=this.crop_size):(u=this.crop_size.width,p=this.crop_size.height),t=await t.center_crop(u,p)}const l=[t.height,t.width];let o=Float32Array.from(t.data),h=[t.height,t.width,t.channels];if(this.do_rescale&&this.rescale(o),e??this.do_normalize){let u=this.image_mean;Array.isArray(this.image_mean)||(u=new Array(t.channels).fill(u));let p=this.image_std;if(Array.isArray(this.image_std)||(p=new Array(t.channels).fill(u)),u.length!==t.channels||p.length!==t.channels)throw new Error(`When set to arrays, the length of \`image_mean\` (${u.length}) and \`image_std\` (${p.length}) must match the number of channels in the image (${t.channels}).`);for(let _=0;_<o.length;_+=t.channels)for(let f=0;f<t.channels;++f)o[_+f]=(o[_+f]-u[f])/p[f]}if(s??this.do_pad){if(this.pad_size)[o,h]=this.pad_image(o,[t.height,t.width,t.channels],this.pad_size);else if(this.size_divisibility){const[u,p]=X([h[1],h[0]],this.size_divisibility);[o,h]=this.pad_image(o,h,{width:u,height:p})}}const g=new F("float32",o,h).permute(2,0,1);return{original_size:[c,a],reshaped_input_size:l,pixel_values:g}}async _call(t,...e){Array.isArray(t)||(t=[t]);const s=await Promise.all(t.map(n=>this.preprocess(n)));return{pixel_values:Z(s.map(n=>n.pixel_values),0),original_sizes:s.map(n=>n.original_size),reshaped_input_sizes:s.map(n=>n.reshaped_input_size)}}}class Mt extends A{post_process_semantic_segmentation(t,e=null){const s=t.logits,i=s.dims[0];if(e!==null&&e.length!==i)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");const n=[];for(let a=0;a<i;++a){const c=e!==null?e[a]:null;let l=s[a];c!==null&&(l=D(l,c,"bilinear",!1));const[o,h]=c??l.dims.slice(-2),g=new F("int32",new Int32Array(o*h),[o,h]),u=l[0].data;for(let d=1;d<l.dims[0];++d){const m=l[d].data;for(let w=0;w<m.length;++w)m[w]>u[w]&&(u[w]=m[w],g.data[w]=d)}const p=new Array(l.dims[0]),_=g.data;for(let d=0;d<_.length;++d){const m=_[d];p[m]=m}const f=p.filter(d=>d!==void 0);n.push({segmentation:g,labels:f})}return n}}class it extends A{}class Et extends it{}class Ft extends A{}class kt extends A{}class It extends A{}class Pt extends A{}class Tt extends A{}class at extends A{constructor(t){super(t),this.crop_pct=this.config.crop_pct??224/256}async resize(t){const e=this.size?.shortest_edge;if(e===void 0)throw new Error("Size dictionary must contain 'shortest_edge' key.");if(e<384){const s=Math.floor(e/this.crop_pct),[i,n]=this.get_resize_output_image_size(t,{shortest_edge:s});t=await t.resize(i,n,{resample:this.resample}),t=await t.center_crop(e,e)}else t=await t.resize(e,e,{resample:this.resample});return t}}class jt extends at{}class Ct extends A{}class vt extends A{}class Rt extends A{constructor(t){super(t),this.include_top=this.config.include_top??!0,this.include_top&&(this.image_std=this.image_std.map(e=>e*e))}}class St extends A{}class ot extends A{post_process_object_detection(...t){return K(...t)}}class $t extends ot{}class Nt extends A{}class Wt extends A{}class lt extends A{pad_image(t,e,s,i={}){const[n,a,c]=e;let l=this.image_mean;Array.isArray(this.image_mean)||(l=new Array(c).fill(l));let o=this.image_std;Array.isArray(o)||(o=new Array(c).fill(l));const h=l.map((g,u)=>-g/o[u]);return super.pad_image(t,e,s,{center:!0,constant_values:h,...i})}}class Ot extends lt{}class Ht extends A{async _call(t){const e=await super._call(t),s=[e.pixel_values.dims[0],64,64],i=new F("int64",new BigInt64Array(s.reduce((n,a)=>n*a)).fill(1n),s);return{...e,pixel_mask:i}}post_process_object_detection(...t){return K(...t)}remove_low_and_no_objects(t,e,s,i){let n=[],a=[],c=[];for(let l=0;l<t.dims[0];++l){let o=t[l],h=e[l],g=O(o.data)[1];if(g===i)continue;let p=st(o.data)[g];p>s&&(n.push(h),a.push(p),c.push(g))}return[n,a,c]}check_segment_validity(t,e,s,i=.5,n=.8){let a=[],c=0,l=0;for(let h=0;h<t.length;++h)t[h]===s&&(a.push(h),++c),e[s].data[h]>=i&&++l;let o=c>0&&l>0;return o&&(o=c/l>n),[o,a]}compute_segments(t,e,s,i,n,a=null,c=null){let[l,o]=c??t[0].dims,h=new F("int32",new Int32Array(l*o),[l,o]),g=[];if(c!==null)for(let f=0;f<t.length;++f)t[f]=D(t[f],c,"bilinear",!1);let u=new Int32Array(t[0].data.length),p=new Float32Array(t[0].data.length);for(let f=0;f<t.length;++f){let d=e[f];for(let m=0;m<t[f].data.length;++m)t[f].data[m]*=d,t[f].data[m]>p[m]&&(u[m]=f,p[m]=t[f].data[m])}let _=0;for(let f=0;f<s.length;++f){let d=s[f],[m,w]=this.check_segment_validity(u,t,f,i,n);if(m){++_;for(let y of w)h.data[y]=_;g.push({id:_,label_id:d,score:e[f]})}}return[h,g]}post_process_panoptic_segmentation(t,e=.5,s=.5,i=.8,n=null,a=null){n===null&&(console.warn("`label_ids_to_fuse` unset. No instance will be fused."),n=new Set);const c=t.logits,o=t.pred_masks.sigmoid();let[h,g,u]=c.dims;if(u-=1,a!==null&&a.length!==h)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let p=[];for(let _=0;_<h;++_){let f=a!==null?a[_]:null,d=c[_],m=o[_],[w,y,z]=this.remove_low_and_no_objects(d,m,e,u);if(z.length===0){let[k,C]=f??m.dims.slice(-2),L=new F("int32",new Int32Array(k*C).fill(-1),[k,C]);p.push({segmentation:L,segments_info:[]});continue}let[b,T]=this.compute_segments(w,y,z,s,i,n,f);p.push({segmentation:b,segments_info:T})}return p}post_process_instance_segmentation(){throw Error("Not implemented yet")}}class Lt extends A{post_process_object_detection(...t){return K(...t)}}class Bt extends A{reshape_input_points(t,e,s){t=structuredClone(t);let i=Q(t);if(i.length===3)i=[1,...i],t=[t];else if(i.length!==4)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");for(let n=0;n<t.length;++n){let a=e[n],c=s[n],l=[c[0]/a[0],c[1]/a[1]];for(let o=0;o<t[n].length;++o)for(let h=0;h<t[n][o].length;++h)for(let g=0;g<t[n][o][h].length;++g)t[n][o][h][g]*=l[g]}return new F("float32",Float32Array.from(t.flat(1/0)),i)}add_input_labels(t,e){let s=Q(t);if(s.length===2)s=[1,...s],t=[t];else if(s.length!==3)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");if(s.some((i,n)=>i!==e.dims[n]))throw Error(`The first ${s.length} dimensions of 'input_points' and 'input_labels' must be the same.`);return new F("int64",t.flat(1/0).map(BigInt),s)}async _call(t,e=null,s=null){const i=await super._call(t);if(e&&(i.input_points=this.reshape_input_points(e,i.original_sizes,i.reshaped_input_sizes)),s){if(!i.input_points)throw Error("`input_points` must be provided if `input_labels` are provided.");i.input_labels=this.add_input_labels(s,i.input_points)}return i}post_process_masks(t,e,s,{mask_threshold:i=0,binarize:n=!0,pad_size:a=null}={}){const c=[];a=a??this.pad_size;const l=[a.height,a.width];for(let o=0;o<e.length;++o){const h=e[o],g=s[o],u=t[o],p=[];for(let _=0;_<u.dims[0];++_){const f=u[_];let d=D(f,l,"bilinear",!1);if(d=d.slice(null,[0,g[0]],[0,g[1]]),d=D(d,h,"bilinear",!1),n){const m=new Uint8Array(d.data.length);for(let w=0;w<d.data.length;++w)d.data[w]>i&&(m[w]=1);d=new F("bool",m,d.dims)}p.push(d)}c.push(Z(p))}return c}generate_crop_boxes(t,e,{crop_n_layers:s=0,overlap_ratio:i=512/1500,points_per_crop:n=32,crop_n_points_downscale_factor:a=1}={}){}}class Vt extends A{pad_image(t,e,s,i={}){const[n,a,c]=e;return super.pad_image(t,e,{width:a+(s-a%s)%s,height:n+(s-n%s)%s},{mode:"symmetric",center:!1,constant_values:-1,...i})}}class Dt extends A{async _call(t,e){Array.isArray(t)||(t=[t]),Array.isArray(e)||(e=[e]);const s=await Promise.all(t.map(a=>this.preprocess(a))),i=await Promise.all(e.map(a=>this.preprocess(a,{do_normalize:!1,do_convert_rgb:!1,do_convert_grayscale:!0})));return{pixel_values:Z(s.map((a,c)=>dt([a.pixel_values,i[c].pixel_values],0)),0),original_sizes:s.map(a=>a.original_size),reshaped_input_sizes:s.map(a=>a.reshaped_input_size)}}}class Gt extends S{constructor(t){super(t),this.config.mel_filters??=W(Math.floor(1+this.config.n_fft/2),this.config.feature_size,0,8e3,this.config.sampling_rate,"slaney","slaney"),this.window=U(this.config.n_fft,"hann")}_extract_fbank_features(t){const{data:e,dims:s}=G(t,this.window,this.config.n_fft,this.config.hop_length,{power:2,mel_filters:this.config.mel_filters,log_mel:"log10",max_num_frames:this.config.nb_max_frames}),i=O(e)[0];for(let n=0;n<e.length;++n)e[n]=(Math.max(e[n],i-8)+4)/4;return{data:e,dims:s}}async _call(t){H(t,"WhisperFeatureExtractor");let e;t.length>this.config.n_samples?(console.warn("Attempting to extract features for audio longer than 30 seconds. If using a pipeline to extract transcript from a long audio clip, remember to specify `chunk_length_s` and/or `stride_length_s`."),e=t.slice(0,this.config.n_samples)):(e=new Float32Array(this.config.n_samples),e.set(t));const{data:s,dims:i}=this._extract_fbank_features(e);return{input_features:new F("float32",s,[1,...i])}}}class Ut extends S{_zero_mean_unit_var_norm(t){const s=t.reduce((n,a)=>n+a,0)/t.length,i=t.reduce((n,a)=>n+(a-s)**2,0)/t.length;return t.map(n=>(n-s)/Math.sqrt(i+1e-7))}async _call(t){H(t,"Wav2Vec2FeatureExtractor"),t instanceof Float64Array&&(t=new Float32Array(t));let e=t;this.config.do_normalize&&(e=this._zero_mean_unit_var_norm(e));const s=[1,e.length];return{input_values:new F("float32",e,s),attention_mask:new F("int64",new BigInt64Array(e.length).fill(1n),s)}}}class Jt extends S{constructor(t){super(t);const e=this.config.sampling_rate,s=W(256,this.config.num_mel_bins,20,Math.floor(e/2),e,null,"kaldi",!0);for(let i=0;i<s.length;++i)s[i].push(0);this.mel_filters=s,this.window=U(400,"povey",{periodic:!1})}_extract_fbank_features(t,e){return t=t.map(s=>s*32768),G(t,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,max_num_frames:e,transpose:!0})}async _call(t,{padding:e=!0,pad_to_multiple_of:s=2,do_normalize_per_mel_bins:i=!0,return_attention_mask:n=!0}={}){H(t,"SeamlessM4TFeatureExtractor");let a=this._extract_fbank_features(t,this.config.max_length);if(i){const[_,f]=a.dims;for(let d=0;d<f;++d){let m=0;for(let b=0;b<_;++b)m+=a.data[b*f+d];const w=m/_;let y=0;for(let b=0;b<_;++b)y+=(a.data[b*f+d]-w)**2;y/=_-1;const z=Math.sqrt(y+1e-7);for(let b=0;b<_;++b){const T=b*f+d;a.data[T]=(a.data[T]-w)/z}}}let c;if(e){const[_,f]=a.dims,d=_%s;if(d>0){const m=new Float32Array(f*(_+d));m.set(a.data),m.fill(this.config.padding_value,a.data.length);const w=_+d;a={data:m,dims:[w,f]},n&&(c=new F("int64",new BigInt64Array(w),[1,w]),c.data.fill(1n,0,_))}}const[l,o]=a.dims,h=this.config.stride;if(l%h!==0)throw new Error(`The number of frames (${l}) must be a multiple of the stride (${h}).`);const u=new F("float32",a.data,a.dims).view(1,Math.floor(l/h),o*h),p={input_features:u};if(n){const _=u.dims[1],f=new F("int64",new BigInt64Array(_),[1,_]);if(c)for(let d=1,m=0;d<l;d+=h,++m)f.data[m]=c.data[d];else f.data.fill(1n);p.attention_mask=f}return p}}class qt extends S{constructor(t){super(t);const e=this.config.sampling_rate,s=W(256,this.config.num_mel_bins,20,Math.floor(e/2),e,null,"kaldi",!0);for(let i=0;i<s.length;++i)s[i].push(0);this.mel_filters=s,this.window=U(400,"hann",{periodic:!1}),this.mean=this.config.mean,this.std=this.config.std}_extract_fbank_features(t,e){return G(t,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,max_num_frames:e,transpose:!0})}async _call(t){H(t,"ASTFeatureExtractor");const e=this._extract_fbank_features(t,this.config.max_length);if(this.config.do_normalize){const s=this.std*2;for(let i=0;i<e.data.length;++i)e.data[i]=(e.data[i]-this.mean)/s}return{input_values:new F("float32",e.data,[1,...e.dims])}}}class Xt extends S{constructor(t){super(t),this.mel_filters=W(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,null,"htk"),this.mel_filters_slaney=W(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,"slaney","slaney"),this.window=U(this.config.fft_window_size,"hann")}_get_input_mel(t,e,s,i){let n,a=!1;const c=t.length-e;if(c>0)if(s==="rand_trunc"){a=!0;const l=Math.floor(Math.random()*(c+1));t=t.subarray(l,l+e),n=this._extract_fbank_features(t,this.mel_filters_slaney,this.config.nb_max_samples),n.dims=[1,...n.dims]}else throw new Error(`Truncation strategy "${s}" not implemented`);else{if(c<0){let l=new Float64Array(e);if(l.set(t),i==="repeat")for(let o=t.length;o<e;o+=t.length)l.set(t.subarray(0,Math.min(t.length,e-o)),o);else if(i==="repeatpad")for(let o=t.length;o<-c;o+=t.length)l.set(t,o);t=l}if(s==="fusion")throw new Error(`Truncation strategy "${s}" not implemented`);n=this._extract_fbank_features(t,this.mel_filters_slaney,this.config.nb_max_samples),n.dims=[1,...n.dims]}return{...n,longer:a}}_extract_fbank_features(t,e,s=null){return G(t,this.window,this.config.fft_window_size,this.config.hop_length,{power:2,mel_filters:e,log_mel:"dB",max_num_frames:s,do_pad:!1,transpose:!0})}async _call(t,{max_length:e=null}={}){H(t,"ClapFeatureExtractor");const s=this._get_input_mel(t,e??this.config.nb_max_samples,this.config.truncation,this.config.padding);return{input_features:new F("float32",s.data,[1,...s.dims])}}}class Zt extends S{}class N extends nt{constructor(t){super(),this.feature_extractor=t}async _call(t,...e){return await this.feature_extractor(t,...e)}}class Kt extends N{async _call(...t){return await this.feature_extractor(...t)}post_process_masks(...t){return this.feature_extractor.post_process_masks(...t)}reshape_input_points(...t){return this.feature_extractor.reshape_input_points(...t)}}class Qt extends N{async _call(t){return await this.feature_extractor(t)}}class Yt extends N{async _call(t){return await this.feature_extractor(t)}}class te extends N{async _call(t){return await this.feature_extractor(t)}}class ee extends N{}class re{static FEATURE_EXTRACTOR_CLASS_MAPPING={ImageFeatureExtractor:A,WhisperFeatureExtractor:Gt,ViTFeatureExtractor:Ct,MobileViTFeatureExtractor:St,OwlViTFeatureExtractor:ot,Owlv2ImageProcessor:$t,CLIPFeatureExtractor:It,ChineseCLIPFeatureExtractor:Pt,SiglipImageProcessor:Tt,ConvNextFeatureExtractor:at,ConvNextImageProcessor:jt,SegformerFeatureExtractor:Mt,BitImageProcessor:Ft,DPTImageProcessor:Et,DPTFeatureExtractor:it,GLPNFeatureExtractor:kt,BeitFeatureExtractor:Wt,DeiTFeatureExtractor:Nt,DetrFeatureExtractor:Ht,YolosFeatureExtractor:Lt,DonutFeatureExtractor:lt,NougatImageProcessor:Ot,EfficientNetImageProcessor:Rt,ViTImageProcessor:vt,VitMatteImageProcessor:Dt,SamImageProcessor:Bt,Swin2SRImageProcessor:Vt,Wav2Vec2FeatureExtractor:Ut,SeamlessM4TFeatureExtractor:Jt,SpeechT5FeatureExtractor:Zt,ASTFeatureExtractor:qt,ClapFeatureExtractor:Xt};static PROCESSOR_CLASS_MAPPING={WhisperProcessor:Qt,Wav2Vec2ProcessorWithLM:Yt,SamProcessor:Kt,SpeechT5Processor:te,OwlViTProcessor:ee};static async from_pretrained(t,{progress_callback:e=null,config:s=null,cache_dir:i=null,local_files_only:n=!1,revision:a="main"}={}){let c=s??await ut(t,"preprocessor_config.json",!0,{progress_callback:e,config:s,cache_dir:i,local_files_only:n,revision:a}),l=c.feature_extractor_type??c.image_processor_type,o=this.FEATURE_EXTRACTOR_CLASS_MAPPING[l];if(!o)if(c.size!==void 0)console.warn(`Feature extractor type "${l}" not found, assuming ImageFeatureExtractor due to size parameter in config.`),o=A;else throw new Error(`Unknown Feature Extractor type: ${l}`);let h=this.PROCESSOR_CLASS_MAPPING[c.processor_class]??N,g=new o(c);return new h(g)}}export{re as A,ne as r};
